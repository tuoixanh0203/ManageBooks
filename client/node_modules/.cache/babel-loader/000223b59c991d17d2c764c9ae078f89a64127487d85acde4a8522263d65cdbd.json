{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildServiceDefinition = void 0;\nconst graphql_1 = require(\"graphql\");\nconst graphql_2 = require(\"./utilities/graphql\");\nconst predicates_1 = require(\"./utilities/predicates\");\nfunction flattened(arr) {\n  return new Array().concat(...arr);\n}\nfunction buildServiceDefinition(modules) {\n  const errors = [];\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directivesMap = Object.create(null);\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n  for (let module of modules) {\n    if ((0, graphql_2.isNode)(module) && (0, graphql_2.isDocumentNode)(module)) {\n      module = {\n        typeDefs: module\n      };\n    }\n    for (const definition of module.typeDefs.definitions) {\n      if ((0, graphql_1.isTypeDefinitionNode)(definition)) {\n        const typeName = definition.name.value;\n        if (typeDefinitionsMap[typeName]) {\n          typeDefinitionsMap[typeName].push(definition);\n        } else {\n          typeDefinitionsMap[typeName] = [definition];\n        }\n      } else if ((0, graphql_1.isTypeExtensionNode)(definition)) {\n        const typeName = definition.name.value;\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push(definition);\n        } else {\n          typeExtensionsMap[typeName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n        const directiveName = definition.name.value;\n        if (directivesMap[directiveName]) {\n          directivesMap[directiveName].push(definition);\n        } else {\n          directivesMap[directiveName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n        schemaDefinitions.push(definition);\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(definition);\n      }\n    }\n  }\n  for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {\n    if (typeDefinitions.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Type \"${typeName}\" was defined more than once.`, typeDefinitions));\n    }\n  }\n  for (const [directiveName, directives] of Object.entries(directivesMap)) {\n    if (directives.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Directive \"${directiveName}\" was defined more than once.`, directives));\n    }\n  }\n  let operationTypeMap;\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n    const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map(node => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));\n    for (const operationType of operationTypes) {\n      const typeName = operationType.type.name.value;\n      const operation = operationType.operation;\n      if (operationTypeMap[operation]) {\n        throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);\n      }\n      if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n        throw new graphql_1.GraphQLError(`Specified ${operation} type \"${typeName}\" not found in document.`, [schemaDefinition]);\n      }\n      operationTypeMap[operation] = typeName;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n  for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n    if (!typeDefinitionsMap[typeName]) {\n      if (Object.values(operationTypeMap).includes(typeName)) {\n        typeDefinitionsMap[typeName] = [{\n          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: typeName\n          }\n        }];\n      } else {\n        errors.push(new graphql_1.GraphQLError(`Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`, typeExtensions));\n      }\n    }\n  }\n  if (errors.length > 0) {\n    return {\n      errors\n    };\n  }\n  try {\n    const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n    const directives = flattened(Object.values(directivesMap));\n    let schema = (0, graphql_1.buildASTSchema)({\n      kind: graphql_1.Kind.DOCUMENT,\n      definitions: [...typeDefinitions, ...directives]\n    });\n    const typeExtensions = flattened(Object.values(typeExtensionsMap));\n    if (typeExtensions.length > 0) {\n      schema = (0, graphql_1.extendSchema)(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: typeExtensions\n      });\n    }\n    for (const module of modules) {\n      if (\"kind\" in module || !module.resolvers) continue;\n      addResolversToSchema(schema, module.resolvers);\n    }\n    return {\n      schema\n    };\n  } catch (error) {\n    return {\n      errors: [error]\n    };\n  }\n}\nexports.buildServiceDefinition = buildServiceDefinition;\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n    if (!(0, graphql_1.isObjectType)(type)) continue;\n    const fieldMap = type.getFields();\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        if (fieldConfig.resolve) {\n          field.resolve = fieldConfig.resolve;\n        }\n        if (fieldConfig.subscribe) {\n          field.subscribe = fieldConfig.subscribe;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["flattened","arr","Array","concat","buildServiceDefinition","modules","errors","typeDefinitionsMap","Object","create","typeExtensionsMap","directivesMap","schemaDefinitions","schemaExtensions","module","typeDefs","definition","definitions","typeName","name","value","push","kind","graphql_1","DIRECTIVE_DEFINITION","directiveName","SCHEMA_DEFINITION","SCHEMA_EXTENSION","typeDefinitions","entries","length","directives","operationTypeMap","schemaDefinition","operationTypes","map","node","filter","predicates_1","operationType","type","operation","query","mutation","subscription","typeExtensions","values","includes","OBJECT_TYPE_DEFINITION","NAME","schema","DOCUMENT","resolvers","addResolversToSchema","error","exports","fieldConfigs","getType","fieldMap","getFields","fieldName","fieldConfig","startsWith","substring","field","resolve","subscribe"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\@apollographql\\apollo-tools\\src\\buildServiceDefinition.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  DocumentNode,\n  TypeDefinitionNode,\n  DirectiveDefinitionNode,\n  isTypeDefinitionNode,\n  TypeExtensionNode,\n  isTypeExtensionNode,\n  GraphQLError,\n  buildASTSchema,\n  Kind,\n  extendSchema,\n  isObjectType,\n  SchemaDefinitionNode,\n  OperationTypeNode,\n  SchemaExtensionNode,\n} from \"graphql\";\nimport { isNode, isDocumentNode } from \"./utilities/graphql\";\nimport { GraphQLResolverMap } from \"./schema/resolverMap\";\nimport { isNotNullOrUndefined } from \"./utilities/predicates\";\n\nexport interface GraphQLSchemaModule {\n  typeDefs: DocumentNode;\n  resolvers?: GraphQLResolverMap<any>;\n}\n\ninterface GraphQLServiceDefinition {\n  schema?: GraphQLSchema;\n  errors?: GraphQLError[];\n}\n\nfunction flattened<T>(arr: ReadonlyArray<ReadonlyArray<T>>): ReadonlyArray<T> {\n  return new Array<T>().concat(...arr);\n}\n\nexport function buildServiceDefinition(\n  modules: (GraphQLSchemaModule | DocumentNode)[]\n): GraphQLServiceDefinition {\n  const errors: GraphQLError[] = [];\n\n  const typeDefinitionsMap: {\n    [name: string]: TypeDefinitionNode[];\n  } = Object.create(null);\n\n  const typeExtensionsMap: {\n    [name: string]: TypeExtensionNode[];\n  } = Object.create(null);\n\n  const directivesMap: {\n    [name: string]: DirectiveDefinitionNode[];\n  } = Object.create(null);\n\n  const schemaDefinitions: SchemaDefinitionNode[] = [];\n  const schemaExtensions: SchemaExtensionNode[] = [];\n\n  for (let module of modules) {\n    if (isNode(module) && isDocumentNode(module)) {\n      module = { typeDefs: module };\n    }\n    for (const definition of module.typeDefs.definitions) {\n      if (isTypeDefinitionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (typeDefinitionsMap[typeName]) {\n          typeDefinitionsMap[typeName].push(definition);\n        } else {\n          typeDefinitionsMap[typeName] = [definition];\n        }\n      } else if (isTypeExtensionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push(definition);\n        } else {\n          typeExtensionsMap[typeName] = [definition];\n        }\n      } else if (definition.kind === Kind.DIRECTIVE_DEFINITION) {\n        const directiveName = definition.name.value;\n\n        if (directivesMap[directiveName]) {\n          directivesMap[directiveName].push(definition);\n        } else {\n          directivesMap[directiveName] = [definition];\n        }\n      } else if (definition.kind === Kind.SCHEMA_DEFINITION) {\n        schemaDefinitions.push(definition);\n      } else if (definition.kind === Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(definition);\n      }\n    }\n  }\n\n  for (const [typeName, typeDefinitions] of Object.entries(\n    typeDefinitionsMap\n  )) {\n    if (typeDefinitions.length > 1) {\n      errors.push(\n        new GraphQLError(\n          `Type \"${typeName}\" was defined more than once.`,\n          typeDefinitions\n        )\n      );\n    }\n  }\n\n  for (const [directiveName, directives] of Object.entries(directivesMap)) {\n    if (directives.length > 1) {\n      errors.push(\n        new GraphQLError(\n          `Directive \"${directiveName}\" was defined more than once.`,\n          directives\n        )\n      );\n    }\n  }\n\n  let operationTypeMap: { [operation in OperationTypeNode]?: string };\n\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n\n    // We should report an error if more than one schema definition is included,\n    // but this matches the current 'last definition wins' behavior of `buildASTSchema`.\n    const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n\n    const operationTypes = flattened(\n      [schemaDefinition, ...schemaExtensions]\n        .map((node) => node.operationTypes)\n        .filter(isNotNullOrUndefined)\n    );\n\n    for (const operationType of operationTypes) {\n      const typeName = operationType.type.name.value;\n      const operation = operationType.operation;\n\n      if (operationTypeMap[operation]) {\n        throw new GraphQLError(\n          `Must provide only one ${operation} type in schema.`,\n          [schemaDefinition]\n        );\n      }\n      if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n        throw new GraphQLError(\n          `Specified ${operation} type \"${typeName}\" not found in document.`,\n          [schemaDefinition]\n        );\n      }\n      operationTypeMap[operation] = typeName;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\",\n    };\n  }\n\n  for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n    if (!typeDefinitionsMap[typeName]) {\n      if (Object.values(operationTypeMap).includes(typeName)) {\n        typeDefinitionsMap[typeName] = [\n          {\n            kind: Kind.OBJECT_TYPE_DEFINITION,\n            name: {\n              kind: Kind.NAME,\n              value: typeName,\n            },\n          },\n        ];\n      } else {\n        errors.push(\n          new GraphQLError(\n            `Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`,\n            typeExtensions\n          )\n        );\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    return { errors };\n  }\n\n  try {\n    const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n    const directives = flattened(Object.values(directivesMap));\n\n    let schema = buildASTSchema({\n      kind: Kind.DOCUMENT,\n      definitions: [...typeDefinitions, ...directives],\n    });\n\n    const typeExtensions = flattened(Object.values(typeExtensionsMap));\n\n    if (typeExtensions.length > 0) {\n      schema = extendSchema(schema, {\n        kind: Kind.DOCUMENT,\n        definitions: typeExtensions,\n      });\n    }\n\n    for (const module of modules) {\n      if (\"kind\" in module || !module.resolvers) continue;\n\n      addResolversToSchema(schema, module.resolvers);\n    }\n\n    return { schema };\n  } catch (error) {\n    return { errors: [error] };\n  }\n}\n\nfunction addResolversToSchema(\n  schema: GraphQLSchema,\n  resolvers: GraphQLResolverMap<any>\n) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n    if (!isObjectType(type)) continue;\n\n    const fieldMap = type.getFields();\n\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        (type as any)[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        if (fieldConfig.resolve) {\n          field.resolve = fieldConfig.resolve;\n        }\n        if (fieldConfig.subscribe) {\n          field.subscribe = fieldConfig.subscribe;\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}