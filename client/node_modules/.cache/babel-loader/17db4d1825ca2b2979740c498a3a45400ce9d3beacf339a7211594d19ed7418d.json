{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitResult = exports.visitErrors = exports.visitData = void 0;\nconst getOperationASTFromRequest_js_1 = require(\"./getOperationASTFromRequest.js\");\nconst graphql_1 = require(\"graphql\");\nconst collectFields_js_1 = require(\"./collectFields.js\");\nfunction visitData(data, enter, leave) {\n  if (Array.isArray(data)) {\n    return data.map(value => visitData(value, enter, leave));\n  } else if (typeof data === 'object') {\n    const newData = enter != null ? enter(data) : data;\n    if (newData != null) {\n      for (const key in newData) {\n        const value = newData[key];\n        Object.defineProperty(newData, key, {\n          value: visitData(value, enter, leave)\n        });\n      }\n    }\n    return leave != null ? leave(newData) : newData;\n  }\n  return data;\n}\nexports.visitData = visitData;\nfunction visitErrors(errors, visitor) {\n  return errors.map(error => visitor(error));\n}\nexports.visitErrors = visitErrors;\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n  const fragments = request.document.definitions.reduce((acc, def) => {\n    if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n      acc[def.name.value] = def;\n    }\n    return acc;\n  }, {});\n  const variableValues = request.variables || {};\n  const errorInfo = {\n    segmentInfoMap: new Map(),\n    unpathedErrors: new Set()\n  };\n  const data = result.data;\n  const errors = result.errors;\n  const visitingErrors = errors != null && errorVisitorMap != null;\n  const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);\n  if (data != null && operationDocumentNode != null) {\n    result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n  }\n  if (errors != null && errorVisitorMap) {\n    result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n  }\n  return result;\n}\nexports.visitResult = visitResult;\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n  const segmentInfoMap = errorInfo.segmentInfoMap;\n  const unpathedErrors = errorInfo.unpathedErrors;\n  const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n  return errors.map(originalError => {\n    const pathSegmentsInfo = segmentInfoMap.get(originalError);\n    const newError = pathSegmentsInfo == null ? originalError : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n      const typeName = segmentInfo.type.name;\n      const typeVisitorMap = errorVisitorMap[typeName];\n      if (typeVisitorMap == null) {\n        return acc;\n      }\n      const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n      return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n    }, originalError);\n    if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n      return unpathedErrorVisitor(newError);\n    }\n    return newError;\n  });\n}\nfunction getOperationRootType(schema, operationDef) {\n  switch (operationDef.operation) {\n    case 'query':\n      return schema.getQueryType();\n    case 'mutation':\n      return schema.getMutationType();\n    case 'subscription':\n      return schema.getSubscriptionType();\n  }\n}\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n  const operationRootType = getOperationRootType(schema, operation);\n  const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n  return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  var _a;\n  const fieldMap = type.getFields();\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n  const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n  const newObject = enterObject != null ? enterObject(object) : object;\n  let sortedErrors;\n  let errorMap = null;\n  if (errors != null) {\n    sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n    errorMap = sortedErrors.errorMap;\n    for (const error of sortedErrors.unpathedErrors) {\n      errorInfo.unpathedErrors.add(error);\n    }\n  }\n  for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n    const fieldName = subFieldNodes[0].name.value;\n    let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;\n    if (fieldType == null) {\n      switch (fieldName) {\n        case '__typename':\n          fieldType = graphql_1.TypeNameMetaFieldDef.type;\n          break;\n        case '__schema':\n          fieldType = graphql_1.SchemaMetaFieldDef.type;\n          break;\n      }\n    }\n    const newPathIndex = pathIndex + 1;\n    let fieldErrors;\n    if (errorMap) {\n      fieldErrors = errorMap[responseKey];\n      if (fieldErrors != null) {\n        delete errorMap[responseKey];\n      }\n      addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n    }\n    const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n    updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n  }\n  const oldTypename = newObject.__typename;\n  if (oldTypename != null) {\n    updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n  }\n  if (errorMap) {\n    for (const errorsKey in errorMap) {\n      const errors = errorMap[errorsKey];\n      for (const error of errors) {\n        errorInfo.unpathedErrors.add(error);\n      }\n    }\n  }\n  const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n  return leaveObject != null ? leaveObject(newObject) : newObject;\n}\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n  if (typeVisitorMap == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n  const fieldVisitor = typeVisitorMap[fieldName];\n  if (fieldVisitor == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n  const visitedValue = fieldVisitor(newValue);\n  if (visitedValue === undefined) {\n    delete object[responseKey];\n    return;\n  }\n  object[responseKey] = visitedValue;\n}\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n  return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex) {\n  let errors = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n  let errorInfo = arguments.length > 9 ? arguments[9] : undefined;\n  if (value == null) {\n    return value;\n  }\n  const nullableType = (0, graphql_1.getNullableType)(returnType);\n  if ((0, graphql_1.isListType)(nullableType)) {\n    return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if ((0, graphql_1.isAbstractType)(nullableType)) {\n    const finalType = schema.getType(value.__typename);\n    const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);\n    return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if ((0, graphql_1.isObjectType)(nullableType)) {\n    const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);\n    return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n  }\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n  if (typeVisitorMap == null) {\n    return value;\n  }\n  const visitedValue = typeVisitorMap(value);\n  return visitedValue === undefined ? value : visitedValue;\n}\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n  var _a;\n  const errorMap = Object.create(null);\n  const unpathedErrors = new Set();\n  for (const error of errors) {\n    const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n    if (pathSegment == null) {\n      unpathedErrors.add(error);\n      continue;\n    }\n    if (pathSegment in errorMap) {\n      errorMap[pathSegment].push(error);\n    } else {\n      errorMap[pathSegment] = [error];\n    }\n  }\n  return {\n    errorMap,\n    unpathedErrors\n  };\n}\nfunction addPathSegmentInfo(type, fieldName, pathIndex) {\n  let errors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let errorInfo = arguments.length > 4 ? arguments[4] : undefined;\n  for (const error of errors) {\n    const segmentInfo = {\n      type,\n      fieldName,\n      pathIndex\n    };\n    const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n    if (pathSegmentsInfo == null) {\n      errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n    } else {\n      pathSegmentsInfo.push(segmentInfo);\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","visitResult","visitErrors","visitData","getOperationASTFromRequest_js_1","require","graphql_1","collectFields_js_1","data","enter","leave","Array","isArray","map","newData","key","errors","visitor","error","result","request","schema","resultVisitorMap","errorVisitorMap","fragments","document","definitions","reduce","acc","def","kind","Kind","FRAGMENT_DEFINITION","name","variableValues","variables","errorInfo","segmentInfoMap","Map","unpathedErrors","Set","visitingErrors","operationDocumentNode","getOperationASTFromRequest","visitRoot","undefined","visitErrorsByType","unpathedErrorVisitor","originalError","pathSegmentsInfo","get","newError","reduceRight","segmentInfo","typeName","type","typeVisitorMap","errorVisitor","fieldName","pathIndex","has","getOperationRootType","operationDef","operation","getQueryType","getMutationType","getSubscriptionType","root","operationRootType","collectedFields","collectFields","selectionSet","visitObjectValue","object","fieldNodeMap","_a","fieldMap","getFields","enterObject","__enter","newObject","sortedErrors","errorMap","sortErrorsByPathSegment","add","responseKey","subFieldNodes","fieldType","TypeNameMetaFieldDef","SchemaMetaFieldDef","newPathIndex","fieldErrors","addPathSegmentInfo","newValue","visitFieldValue","updateObject","oldTypename","__typename","errorsKey","leaveObject","__leave","fieldVisitor","visitedValue","visitListValue","list","returnType","fieldNodes","listMember","nullableType","getNullableType","isListType","ofType","isAbstractType","finalType","getType","collectSubFields","isObjectType","create","pathSegment","path","push","set"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/visitResult.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitResult = exports.visitErrors = exports.visitData = void 0;\nconst getOperationASTFromRequest_js_1 = require(\"./getOperationASTFromRequest.js\");\nconst graphql_1 = require(\"graphql\");\nconst collectFields_js_1 = require(\"./collectFields.js\");\nfunction visitData(data, enter, leave) {\n    if (Array.isArray(data)) {\n        return data.map(value => visitData(value, enter, leave));\n    }\n    else if (typeof data === 'object') {\n        const newData = enter != null ? enter(data) : data;\n        if (newData != null) {\n            for (const key in newData) {\n                const value = newData[key];\n                Object.defineProperty(newData, key, {\n                    value: visitData(value, enter, leave),\n                });\n            }\n        }\n        return leave != null ? leave(newData) : newData;\n    }\n    return data;\n}\nexports.visitData = visitData;\nfunction visitErrors(errors, visitor) {\n    return errors.map(error => visitor(error));\n}\nexports.visitErrors = visitErrors;\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n    const fragments = request.document.definitions.reduce((acc, def) => {\n        if (def.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n            acc[def.name.value] = def;\n        }\n        return acc;\n    }, {});\n    const variableValues = request.variables || {};\n    const errorInfo = {\n        segmentInfoMap: new Map(),\n        unpathedErrors: new Set(),\n    };\n    const data = result.data;\n    const errors = result.errors;\n    const visitingErrors = errors != null && errorVisitorMap != null;\n    const operationDocumentNode = (0, getOperationASTFromRequest_js_1.getOperationASTFromRequest)(request);\n    if (data != null && operationDocumentNode != null) {\n        result.data = visitRoot(data, operationDocumentNode, schema, fragments, variableValues, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n    }\n    if (errors != null && errorVisitorMap) {\n        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n    }\n    return result;\n}\nexports.visitResult = visitResult;\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n    const segmentInfoMap = errorInfo.segmentInfoMap;\n    const unpathedErrors = errorInfo.unpathedErrors;\n    const unpathedErrorVisitor = errorVisitorMap['__unpathed'];\n    return errors.map(originalError => {\n        const pathSegmentsInfo = segmentInfoMap.get(originalError);\n        const newError = pathSegmentsInfo == null\n            ? originalError\n            : pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n                const typeName = segmentInfo.type.name;\n                const typeVisitorMap = errorVisitorMap[typeName];\n                if (typeVisitorMap == null) {\n                    return acc;\n                }\n                const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n                return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n            }, originalError);\n        if (unpathedErrorVisitor && unpathedErrors.has(originalError)) {\n            return unpathedErrorVisitor(newError);\n        }\n        return newError;\n    });\n}\nfunction getOperationRootType(schema, operationDef) {\n    switch (operationDef.operation) {\n        case 'query':\n            return schema.getQueryType();\n        case 'mutation':\n            return schema.getMutationType();\n        case 'subscription':\n            return schema.getSubscriptionType();\n    }\n}\nfunction visitRoot(root, operation, schema, fragments, variableValues, resultVisitorMap, errors, errorInfo) {\n    const operationRootType = getOperationRootType(schema, operation);\n    const collectedFields = (0, collectFields_js_1.collectFields)(schema, fragments, variableValues, operationRootType, operation.selectionSet, new Map(), new Set());\n    return visitObjectValue(root, operationRootType, collectedFields, schema, fragments, variableValues, resultVisitorMap, 0, errors, errorInfo);\n}\nfunction visitObjectValue(object, type, fieldNodeMap, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    var _a;\n    const fieldMap = type.getFields();\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n    const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n    const newObject = enterObject != null ? enterObject(object) : object;\n    let sortedErrors;\n    let errorMap = null;\n    if (errors != null) {\n        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n        errorMap = sortedErrors.errorMap;\n        for (const error of sortedErrors.unpathedErrors) {\n            errorInfo.unpathedErrors.add(error);\n        }\n    }\n    for (const [responseKey, subFieldNodes] of fieldNodeMap) {\n        const fieldName = subFieldNodes[0].name.value;\n        let fieldType = (_a = fieldMap[fieldName]) === null || _a === void 0 ? void 0 : _a.type;\n        if (fieldType == null) {\n            switch (fieldName) {\n                case '__typename':\n                    fieldType = graphql_1.TypeNameMetaFieldDef.type;\n                    break;\n                case '__schema':\n                    fieldType = graphql_1.SchemaMetaFieldDef.type;\n                    break;\n            }\n        }\n        const newPathIndex = pathIndex + 1;\n        let fieldErrors;\n        if (errorMap) {\n            fieldErrors = errorMap[responseKey];\n            if (fieldErrors != null) {\n                delete errorMap[responseKey];\n            }\n            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n        }\n        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, schema, fragments, variableValues, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n    }\n    const oldTypename = newObject.__typename;\n    if (oldTypename != null) {\n        updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n    }\n    if (errorMap) {\n        for (const errorsKey in errorMap) {\n            const errors = errorMap[errorsKey];\n            for (const error of errors) {\n                errorInfo.unpathedErrors.add(error);\n            }\n        }\n    }\n    const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n    return leaveObject != null ? leaveObject(newObject) : newObject;\n}\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n    if (typeVisitorMap == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const fieldVisitor = typeVisitorMap[fieldName];\n    if (fieldVisitor == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const visitedValue = fieldVisitor(newValue);\n    if (visitedValue === undefined) {\n        delete object[responseKey];\n        return;\n    }\n    object[responseKey] = visitedValue;\n}\nfunction visitListValue(list, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo) {\n    return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\nfunction visitFieldValue(value, returnType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors = [], errorInfo) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = (0, graphql_1.getNullableType)(returnType);\n    if ((0, graphql_1.isListType)(nullableType)) {\n        return visitListValue(value, nullableType.ofType, fieldNodes, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if ((0, graphql_1.isAbstractType)(nullableType)) {\n        const finalType = schema.getType(value.__typename);\n        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, finalType, fieldNodes);\n        return visitObjectValue(value, finalType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if ((0, graphql_1.isObjectType)(nullableType)) {\n        const collectedFields = (0, collectFields_js_1.collectSubFields)(schema, fragments, variableValues, nullableType, fieldNodes);\n        return visitObjectValue(value, nullableType, collectedFields, schema, fragments, variableValues, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n    if (typeVisitorMap == null) {\n        return value;\n    }\n    const visitedValue = typeVisitorMap(value);\n    return visitedValue === undefined ? value : visitedValue;\n}\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n    var _a;\n    const errorMap = Object.create(null);\n    const unpathedErrors = new Set();\n    for (const error of errors) {\n        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n        if (pathSegment == null) {\n            unpathedErrors.add(error);\n            continue;\n        }\n        if (pathSegment in errorMap) {\n            errorMap[pathSegment].push(error);\n        }\n        else {\n            errorMap[pathSegment] = [error];\n        }\n    }\n    return {\n        errorMap,\n        unpathedErrors,\n    };\n}\nfunction addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {\n    for (const error of errors) {\n        const segmentInfo = {\n            type,\n            fieldName,\n            pathIndex,\n        };\n        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n        if (pathSegmentsInfo == null) {\n            errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n        }\n        else {\n            pathSegmentsInfo.push(segmentInfo);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}