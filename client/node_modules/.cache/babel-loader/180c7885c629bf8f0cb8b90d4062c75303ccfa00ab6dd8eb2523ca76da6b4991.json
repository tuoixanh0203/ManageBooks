{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stopper = void 0;\nconst https_1 = __importDefault(require(\"https\"));\nclass Stopper {\n  constructor(server) {\n    this.server = server;\n    this.requestCountPerSocket = new Map();\n    this.stopped = false;\n    server.on(server instanceof https_1.default.Server ? 'secureConnection' : 'connection', socket => {\n      this.requestCountPerSocket.set(socket, 0);\n      socket.once('close', () => this.requestCountPerSocket.delete(socket));\n    });\n    server.on('request', (req, res) => {\n      var _a;\n      this.requestCountPerSocket.set(req.socket, ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) + 1);\n      res.once('finish', () => {\n        var _a;\n        const pending = ((_a = this.requestCountPerSocket.get(req.socket)) !== null && _a !== void 0 ? _a : 0) - 1;\n        this.requestCountPerSocket.set(req.socket, pending);\n        if (this.stopped && pending === 0) {\n          req.socket.end();\n        }\n      });\n    });\n  }\n  async stop() {\n    let stopGracePeriodMillis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n    let gracefully = true;\n    await new Promise(resolve => setImmediate(resolve));\n    this.stopped = true;\n    let timeout = null;\n    if (stopGracePeriodMillis < Infinity) {\n      timeout = setTimeout(() => {\n        gracefully = false;\n        this.requestCountPerSocket.forEach((_, socket) => socket.end());\n        setImmediate(() => {\n          this.requestCountPerSocket.forEach((_, socket) => socket.destroy());\n        });\n      }, stopGracePeriodMillis);\n    }\n    const closePromise = new Promise(resolve => this.server.close(() => {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      resolve();\n    }));\n    this.requestCountPerSocket.forEach((requests, socket) => {\n      if (requests === 0) socket.end();\n    });\n    await closePromise;\n    return gracefully;\n  }\n}\nexports.Stopper = Stopper;","map":{"version":3,"mappings":";;;;;;;;;;;AA6BA;AAGA,MAAaA,OAAO;EAIlBC,YAAoBC,MAAkC;IAAlC,WAAM,GAANA,MAAM;IAHlB,0BAAqB,GAAG,IAAIC,GAAG,EAAkB;IACjD,YAAO,GAAG,KAAK;IAIrBD,MAAM,CAACE,EAAE,CACPF,MAAM,YAAYG,eAAK,CAACC,MAAM,GAAG,kBAAkB,GAAG,YAAY,EACjEC,MAAc,IAAI;MACjB,IAAI,CAACC,qBAAqB,CAACC,GAAG,CAACF,MAAM,EAAE,CAAC,CAAC;MACzCA,MAAM,CAACG,IAAI,CAAC,OAAO,EAAE,MAAM,IAAI,CAACF,qBAAqB,CAACG,MAAM,CAACJ,MAAM,CAAC,CAAC;IACvE,CAAC,CACF;IAGDL,MAAM,CAACE,EAAE,CACP,SAAS,EACT,CAACQ,GAAyB,EAAEC,GAAwB,KAAI;;MACtD,IAAI,CAACL,qBAAqB,CAACC,GAAG,CAC5BG,GAAG,CAACL,MAAM,EACV,CAAC,UAAI,CAACC,qBAAqB,CAACM,GAAG,CAACF,GAAG,CAACL,MAAM,CAAC,mCAAI,CAAC,IAAI,CAAC,CACtD;MACDM,GAAG,CAACH,IAAI,CAAC,QAAQ,EAAE,MAAK;;QACtB,MAAMK,OAAO,GAAG,CAAC,UAAI,CAACP,qBAAqB,CAACM,GAAG,CAACF,GAAG,CAACL,MAAM,CAAC,mCAAI,CAAC,IAAI,CAAC;QACrE,IAAI,CAACC,qBAAqB,CAACC,GAAG,CAACG,GAAG,CAACL,MAAM,EAAEQ,OAAO,CAAC;QAGnD,IAAI,IAAI,CAACC,OAAO,IAAID,OAAO,KAAK,CAAC,EAAE;UACjCH,GAAG,CAACL,MAAM,CAACU,GAAG,EAAE;;MAEpB,CAAC,CAAC;IACJ,CAAC,CACF;EACH;EAEA,MAAMC,IAAI,GAAyC;IAAA,IAAxCC,4FAAgCC,QAAQ;IACjD,IAAIC,UAAU,GAAG,IAAI;IAMrB,MAAM,IAAIC,OAAO,CAAQC,OAAO,IAAKC,YAAY,CAACD,OAAO,CAAC,CAAC;IAC3D,IAAI,CAACP,OAAO,GAAG,IAAI;IAEnB,IAAIS,OAAO,GAA0B,IAAI;IAEzC,IAAIN,qBAAqB,GAAGC,QAAQ,EAAE;MACpCK,OAAO,GAAGC,UAAU,CAAC,MAAK;QACxBL,UAAU,GAAG,KAAK;QAClB,IAAI,CAACb,qBAAqB,CAACmB,OAAO,CAAC,CAACC,CAAC,EAAErB,MAAM,KAAKA,MAAM,CAACU,GAAG,EAAE,CAAC;QAG/DO,YAAY,CAAC,MAAK;UAChB,IAAI,CAAChB,qBAAqB,CAACmB,OAAO,CAAC,CAACC,CAAC,EAAErB,MAAM,KAAKA,MAAM,CAACsB,OAAO,EAAE,CAAC;QACrE,CAAC,CAAC;MACJ,CAAC,EAAEV,qBAAqB,CAAC;;IAK3B,MAAMW,YAAY,GAAG,IAAIR,OAAO,CAAQC,OAAO,IAC7C,IAAI,CAACrB,MAAM,CAAC6B,KAAK,CAAC,MAAK;MACrB,IAAIN,OAAO,EAAE;QACXO,YAAY,CAACP,OAAO,CAAC;QACrBA,OAAO,GAAG,IAAI;;MAEhBF,OAAO,EAAE;IACX,CAAC,CAAC,CACH;IAGD,IAAI,CAACf,qBAAqB,CAACmB,OAAO,CAAC,CAACM,QAAQ,EAAE1B,MAAM,KAAI;MACtD,IAAI0B,QAAQ,KAAK,CAAC,EAAE1B,MAAM,CAACU,GAAG,EAAE;IAClC,CAAC,CAAC;IAGF,MAAMa,YAAY;IAElB,OAAOT,UAAU;EACnB;;AAhFFa","names":["Stopper","constructor","server","Map","on","https_1","Server","socket","requestCountPerSocket","set","once","delete","req","res","get","pending","stopped","end","stop","stopGracePeriodMillis","Infinity","gracefully","Promise","resolve","setImmediate","timeout","setTimeout","forEach","_","destroy","closePromise","close","clearTimeout","requests","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\drainHttpServer\\stoppable.ts"],"sourcesContent":["// This file is adapted from the stoppable npm package:\n// https://github.com/hunterloftis/stoppable\n//\n// We've ported it to TypeScript and simplified the API and fixed some bugs.\n// Here's the license of the original code:\n//\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Hunter Loftis <hunter@hunterloftis.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport type http from 'http';\nimport https from 'https';\nimport type { Socket } from 'net';\n\nexport class Stopper {\n  private requestCountPerSocket = new Map<Socket, number>();\n  private stopped = false;\n\n  constructor(private server: http.Server | https.Server) {\n    // Keep a number in requestCountPerSocket for each current connection.\n    server.on(\n      server instanceof https.Server ? 'secureConnection' : 'connection',\n      (socket: Socket) => {\n        this.requestCountPerSocket.set(socket, 0);\n        socket.once('close', () => this.requestCountPerSocket.delete(socket));\n      },\n    );\n\n    // Track how many HTTP requests are active on the socket.\n    server.on(\n      'request',\n      (req: http.IncomingMessage, res: http.ServerResponse) => {\n        this.requestCountPerSocket.set(\n          req.socket,\n          (this.requestCountPerSocket.get(req.socket) ?? 0) + 1,\n        );\n        res.once('finish', () => {\n          const pending = (this.requestCountPerSocket.get(req.socket) ?? 0) - 1;\n          this.requestCountPerSocket.set(req.socket, pending);\n          // If we're in the process of stopping and it's gone idle, close the\n          // socket.\n          if (this.stopped && pending === 0) {\n            req.socket.end();\n          }\n        });\n      },\n    );\n  }\n\n  async stop(stopGracePeriodMillis: number = Infinity): Promise<boolean> {\n    let gracefully = true;\n\n    // In the off-chance that we are calling `stop` directly from within the\n    // HTTP server's request handler (and so we haven't gotten to the\n    // `connection` event yet), wait a moment so that `connection` can be called\n    // and this request can actually count.\n    await new Promise<void>((resolve) => setImmediate(resolve));\n    this.stopped = true;\n\n    let timeout: NodeJS.Timeout | null = null;\n    // Soon, hard-destroy everything.\n    if (stopGracePeriodMillis < Infinity) {\n      timeout = setTimeout(() => {\n        gracefully = false;\n        this.requestCountPerSocket.forEach((_, socket) => socket.end());\n        // (FYI, when importing from upstream, not sure why we need setImmediate\n        // here.)\n        setImmediate(() => {\n          this.requestCountPerSocket.forEach((_, socket) => socket.destroy());\n        });\n      }, stopGracePeriodMillis);\n    }\n\n    // Close the server and create a Promise that resolves when all connections\n    // are closed. Note that we ignore any error from `close` here.\n    const closePromise = new Promise<void>((resolve) =>\n      this.server.close(() => {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        resolve();\n      }),\n    );\n\n    // Immediately close any idle sockets.\n    this.requestCountPerSocket.forEach((requests, socket) => {\n      if (requests === 0) socket.end();\n    });\n\n    // Wait for all connections to be closed.\n    await closePromise;\n\n    return gracefully;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}