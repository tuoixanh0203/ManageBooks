{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InMemoryLRUCache = void 0;\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nclass InMemoryLRUCache {\n  constructor(lruCacheOpts) {\n    this.cache = new lru_cache_1.default({\n      sizeCalculation: InMemoryLRUCache.sizeCalculation,\n      maxSize: Math.pow(2, 20) * 30,\n      ...lruCacheOpts\n    });\n  }\n  static sizeCalculation(item) {\n    if (typeof item === \"string\") {\n      return item.length;\n    }\n    if (typeof item === \"object\") {\n      return Buffer.byteLength(JSON.stringify(item), \"utf8\");\n    }\n    return 1;\n  }\n  async set(key, value, options) {\n    if (options === null || options === void 0 ? void 0 : options.ttl) {\n      this.cache.set(key, value, {\n        ttl: options.ttl * 1000\n      });\n    } else {\n      this.cache.set(key, value);\n    }\n  }\n  async get(key) {\n    return this.cache.get(key);\n  }\n  async delete(key) {\n    return this.cache.delete(key);\n  }\n  clear() {\n    this.cache.clear();\n  }\n  keys() {\n    return [...this.cache.keys()];\n  }\n}\nexports.InMemoryLRUCache = InMemoryLRUCache;","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;AAIA,MAAaA,gBAAgB;EAG3BC,YAAYC,YAA0C;IACpD,IAAI,CAACC,KAAK,GAAG,IAAIC,mBAAQ,CAAC;MACxBC,eAAe,EAAEL,gBAAgB,CAACK,eAAe;MAGjDC,OAAO,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE;MAC7B,GAAGN;KACJ,CAAC;EACJ;EAMA,OAAOG,eAAe,CAAII,IAAO;IAC/B,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC5B,OAAOA,IAAI,CAACC,MAAM;;IAEpB,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;MAE5B,OAAOE,MAAM,CAACC,UAAU,CAACC,IAAI,CAACC,SAAS,CAACL,IAAI,CAAC,EAAE,MAAM,CAAC;;IAExD,OAAO,CAAC;EACV;EAEA,MAAMM,GAAG,CAACC,GAAW,EAAEC,KAAQ,EAAEC,OAAiC;IAChE,IAAIA,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEC,GAAG,EAAE;MAChB,IAAI,CAAChB,KAAK,CAACY,GAAG,CAACC,GAAG,EAAEC,KAAK,EAAE;QAAEE,GAAG,EAAED,OAAO,CAACC,GAAG,GAAG;MAAI,CAAE,CAAC;KACxD,MAAM;MACL,IAAI,CAAChB,KAAK,CAACY,GAAG,CAACC,GAAG,EAAEC,KAAK,CAAC;;EAE9B;EAEA,MAAMG,GAAG,CAACJ,GAAW;IACnB,OAAO,IAAI,CAACb,KAAK,CAACiB,GAAG,CAACJ,GAAG,CAAC;EAC5B;EAEA,MAAMK,MAAM,CAACL,GAAW;IACtB,OAAO,IAAI,CAACb,KAAK,CAACkB,MAAM,CAACL,GAAG,CAAC;EAC/B;EAEAM,KAAK;IACH,IAAI,CAACnB,KAAK,CAACmB,KAAK,EAAE;EACpB;EAEAC,IAAI;IAEF,OAAO,CAAC,GAAG,IAAI,CAACpB,KAAK,CAACoB,IAAI,EAAE,CAAC;EAC/B;;AAnDFC","names":["InMemoryLRUCache","constructor","lruCacheOpts","cache","lru_cache_1","sizeCalculation","maxSize","Math","pow","item","length","Buffer","byteLength","JSON","stringify","set","key","value","options","ttl","get","delete","clear","keys","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\@apollo\\utils.keyvaluecache\\src\\InMemoryLRUCache.ts"],"sourcesContent":["import LRUCache from \"lru-cache\";\nimport type { KeyValueCache, KeyValueCacheSetOptions } from \"./KeyValueCache\";\n\n// LRUCache wrapper to implement the KeyValueCache interface.\nexport class InMemoryLRUCache<T = string> implements KeyValueCache<T> {\n  private cache: LRUCache<string, T>;\n\n  constructor(lruCacheOpts?: LRUCache.Options<string, T>) {\n    this.cache = new LRUCache({\n      sizeCalculation: InMemoryLRUCache.sizeCalculation,\n      // Create ~about~ a 30MiB cache by default. Configurable by providing\n      // `lruCacheOpts`.\n      maxSize: Math.pow(2, 20) * 30,\n      ...lruCacheOpts,\n    });\n  }\n\n  /**\n   * default size calculator for strings and serializable objects, else naively\n   * return 1\n   */\n  static sizeCalculation<T>(item: T) {\n    if (typeof item === \"string\") {\n      return item.length;\n    }\n    if (typeof item === \"object\") {\n      // will throw if the object has circular references\n      return Buffer.byteLength(JSON.stringify(item), \"utf8\");\n    }\n    return 1;\n  }\n\n  async set(key: string, value: T, options?: KeyValueCacheSetOptions) {\n    if (options?.ttl) {\n      this.cache.set(key, value, { ttl: options.ttl * 1000 });\n    } else {\n      this.cache.set(key, value);\n    }\n  }\n\n  async get(key: string) {\n    return this.cache.get(key);\n  }\n\n  async delete(key: string) {\n    return this.cache.delete(key);\n  }\n\n  clear() {\n    this.cache.clear();\n  }\n\n  keys() {\n    // LRUCache.keys() returns a generator (we just want an array)\n    return [...this.cache.keys()];\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}