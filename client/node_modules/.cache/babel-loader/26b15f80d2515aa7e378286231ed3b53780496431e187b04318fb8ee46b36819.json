{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeExecutableSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst addResolversToSchema_js_1 = require(\"./addResolversToSchema.js\");\nconst assertResolversPresent_js_1 = require(\"./assertResolversPresent.js\");\nconst merge_1 = require(\"@graphql-tools/merge\");\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use GraphQL magic comment provide additional syntax\n * highlighting in your editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = /* GraphQL *\\/ `\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema(_ref) {\n  let {\n    typeDefs,\n    resolvers = {},\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false,\n    schemaExtensions,\n    ...otherOptions\n  } = _ref;\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n  let schema;\n  if ((0, graphql_1.isSchema)(typeDefs)) {\n    schema = typeDefs;\n  } else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {\n    const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {\n      ...otherOptions,\n      commentDescriptions: true\n    });\n    schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);\n  } else {\n    const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);\n    schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);\n  }\n  // We allow passing in an array of resolver maps, in which case we merge them\n  schema = (0, addResolversToSchema_js_1.addResolversToSchema)({\n    schema,\n    resolvers: (0, merge_1.mergeResolvers)(resolvers),\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n    updateResolversInPlace\n  });\n  if (Object.keys(resolverValidationOptions).length > 0) {\n    (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);\n  }\n  if (schemaExtensions) {\n    schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));\n    (0, merge_1.applyExtensions)(schema, schemaExtensions);\n  }\n  return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;","map":{"version":3,"names":["Object","defineProperty","exports","value","makeExecutableSchema","graphql_1","require","utils_1","addResolversToSchema_js_1","assertResolversPresent_js_1","merge_1","typeDefs","resolvers","resolverValidationOptions","inheritResolversFromInterfaces","updateResolversInPlace","schemaExtensions","otherOptions","Error","schema","isSchema","commentDescriptions","mergedTypeDefs","mergeTypeDefs","buildSchema","buildASTSchema","addResolversToSchema","mergeResolvers","keys","length","assertResolversPresent","mergeExtensions","asArray","applyExtensions"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeExecutableSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst addResolversToSchema_js_1 = require(\"./addResolversToSchema.js\");\nconst assertResolversPresent_js_1 = require(\"./assertResolversPresent.js\");\nconst merge_1 = require(\"@graphql-tools/merge\");\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use GraphQL magic comment provide additional syntax\n * highlighting in your editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = /* GraphQL *\\/ `\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, ...otherOptions }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if ((0, graphql_1.isSchema)(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.commentDescriptions) {\n        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {\n            ...otherOptions,\n            commentDescriptions: true,\n        });\n        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, otherOptions);\n    }\n    else {\n        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, otherOptions);\n        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, otherOptions);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = (0, addResolversToSchema_js_1.addResolversToSchema)({\n        schema,\n        resolvers: (0, merge_1.mergeResolvers)(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));\n        (0, merge_1.applyExtensions)(schema, schemaExtensions);\n    }\n    return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}