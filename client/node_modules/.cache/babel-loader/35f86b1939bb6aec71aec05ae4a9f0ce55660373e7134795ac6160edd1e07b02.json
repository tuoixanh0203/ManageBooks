{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DurationHistogram = void 0;\nclass DurationHistogram {\n  constructor(options) {\n    const initSize = (options === null || options === void 0 ? void 0 : options.initSize) || 74;\n    const buckets = options === null || options === void 0 ? void 0 : options.buckets;\n    const arrayInitSize = Math.max((buckets === null || buckets === void 0 ? void 0 : buckets.length) || 0, initSize);\n    this.buckets = Array(arrayInitSize).fill(0);\n    if (buckets) {\n      buckets.forEach((val, index) => this.buckets[index] = val);\n    }\n  }\n  toArray() {\n    let bufferedZeroes = 0;\n    const outputArray = [];\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(Math.floor(value));\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n  static durationToBucket(durationNs) {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket) ? 0 : unboundedBucket >= DurationHistogram.BUCKET_COUNT ? DurationHistogram.BUCKET_COUNT - 1 : unboundedBucket;\n  }\n  incrementDuration(durationNs) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);\n    return this;\n  }\n  incrementBucket(bucket) {\n    let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n    this.buckets[bucket] += value;\n  }\n  combine(otherHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n}\nexports.DurationHistogram = DurationHistogram;\nDurationHistogram.BUCKET_COUNT = 384;\nDurationHistogram.EXPONENT_LOG = Math.log(1.1);","map":{"version":3,"mappings":"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","names":["DurationHistogram","constructor","options","initSize","buckets","arrayInitSize","Math","max","length","Array","fill","forEach","val","index","toArray","bufferedZeroes","outputArray","value","push","floor","durationToBucket","durationNs","log","unboundedBucket","ceil","EXPONENT_LOG","Number","isNaN","BUCKET_COUNT","incrementDuration","incrementBucket","bucket","Error","oldLength","combine","otherHistogram","i","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\durationHistogram.ts"],"sourcesContent":["export interface DurationHistogramOptions {\n  initSize?: number;\n  buckets?: number[];\n}\nexport class DurationHistogram {\n  // Note that it's legal for the values in \"buckets\" to be non-integers; they\n  // will be floored by toArray (which is called by the protobuf encoder).\n  // (We take advantage of this for field latencies specifically, because\n  // the ability to return a non-1 weight from fieldLevelInstrumentation\n  // means we want to build up our histograms as floating-point rather than\n  // rounding after every operation.)\n  private readonly buckets: number[];\n  static readonly BUCKET_COUNT = 384;\n  static readonly EXPONENT_LOG = Math.log(1.1);\n\n  toArray(): number[] {\n    let bufferedZeroes = 0;\n    const outputArray: number[] = [];\n\n    for (const value of this.buckets) {\n      if (value === 0) {\n        bufferedZeroes++;\n      } else {\n        if (bufferedZeroes === 1) {\n          outputArray.push(0);\n        } else if (bufferedZeroes !== 0) {\n          outputArray.push(-bufferedZeroes);\n        }\n        outputArray.push(Math.floor(value));\n        bufferedZeroes = 0;\n      }\n    }\n    return outputArray;\n  }\n\n  static durationToBucket(durationNs: number): number {\n    const log = Math.log(durationNs / 1000.0);\n    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);\n\n    // Compare <= 0 to catch -0 and -infinity\n    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)\n      ? 0\n      : unboundedBucket >= DurationHistogram.BUCKET_COUNT\n      ? DurationHistogram.BUCKET_COUNT - 1\n      : unboundedBucket;\n  }\n\n  incrementDuration(durationNs: number, value = 1): DurationHistogram {\n    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);\n    return this;\n  }\n\n  incrementBucket(bucket: number, value = 1) {\n    if (bucket >= DurationHistogram.BUCKET_COUNT) {\n      // Since we don't have fixed size arrays I'd rather throw the error manually\n      throw Error('Bucket is out of bounds of the buckets array');\n    }\n\n    // Extend the array if we haven't gotten it long enough to handle the new bucket\n    if (bucket >= this.buckets.length) {\n      const oldLength = this.buckets.length;\n      this.buckets.length = bucket + 1;\n      this.buckets.fill(0, oldLength);\n    }\n\n    this.buckets[bucket] += value;\n  }\n\n  combine(otherHistogram: DurationHistogram) {\n    for (let i = 0; i < otherHistogram.buckets.length; i++) {\n      this.incrementBucket(i, otherHistogram.buckets[i]);\n    }\n  }\n\n  constructor(options?: DurationHistogramOptions) {\n    const initSize = options?.initSize || 74;\n    const buckets = options?.buckets;\n\n    const arrayInitSize = Math.max(buckets?.length || 0, initSize);\n\n    this.buckets = Array<number>(arrayInitSize).fill(0);\n\n    if (buckets) {\n      buckets.forEach((val, index) => (this.buckets[index] = val));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}