{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pruneSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst mapSchema_js_1 = require(\"./mapSchema.js\");\nconst Interfaces_js_1 = require(\"./Interfaces.js\");\nconst rootTypes_js_1 = require(\"./rootTypes.js\");\nconst get_implementing_types_js_1 = require(\"./get-implementing-types.js\");\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\nfunction pruneSchema(schema) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    skipEmptyCompositeTypePruning,\n    skipEmptyUnionPruning,\n    skipPruning,\n    skipUnimplementedInterfacesPruning,\n    skipUnusedTypesPruning\n  } = options;\n  let prunedTypes = []; // Pruned types during mapping\n  let prunedSchema = schema;\n  do {\n    let visited = visitSchema(prunedSchema);\n    // Custom pruning  was defined, so we need to pre-emptively revisit the schema accounting for this\n    if (skipPruning) {\n      const revisit = [];\n      for (const typeName in prunedSchema.getTypeMap()) {\n        if (typeName.startsWith('__')) {\n          continue;\n        }\n        const type = prunedSchema.getType(typeName);\n        // if we want to skip pruning for this type, add it to the list of types to revisit\n        if (type && skipPruning(type)) {\n          revisit.push(typeName);\n        }\n      }\n      visited = visitQueue(revisit, prunedSchema, visited); // visit again\n    }\n\n    prunedTypes = [];\n    prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {\n      [Interfaces_js_1.MapperKind.TYPE]: type => {\n        if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {\n          if ((0, graphql_1.isUnionType)(type) || (0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type) || (0, graphql_1.isScalarType)(type)) {\n            // skipUnusedTypesPruning: skip pruning unused types\n            if (skipUnusedTypesPruning) {\n              return type;\n            }\n            // skipEmptyUnionPruning: skip pruning empty unions\n            if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {\n              return type;\n            }\n            if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {\n              // skipEmptyCompositeTypePruning: skip pruning object types or interfaces with no fields\n              if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {\n                return type;\n              }\n            }\n            // skipUnimplementedInterfacesPruning: skip pruning interfaces that are not implemented by any other types\n            if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {\n              return type;\n            }\n          }\n          prunedTypes.push(type.name);\n          visited.delete(type.name);\n          return null;\n        }\n        return type;\n      }\n    });\n  } while (prunedTypes.length); // Might have empty types and need to prune again\n  return prunedSchema;\n}\nexports.pruneSchema = pruneSchema;\nfunction visitSchema(schema) {\n  const queue = []; // queue of nodes to visit\n  // Grab the root types and start there\n  for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {\n    queue.push(type.name);\n  }\n  return visitQueue(queue, schema);\n}\nfunction visitQueue(queue, schema) {\n  let visited = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n  // Interfaces encountered that are field return types need to be revisited to add their implementations\n  const revisit = new Map();\n  // Navigate all types starting with pre-queued types (root types)\n  while (queue.length) {\n    const typeName = queue.pop();\n    // Skip types we already visited unless it is an interface type that needs revisiting\n    if (visited.has(typeName) && revisit[typeName] !== true) {\n      continue;\n    }\n    const type = schema.getType(typeName);\n    if (type) {\n      // Get types for union\n      if ((0, graphql_1.isUnionType)(type)) {\n        queue.push(...type.getTypes().map(type => type.name));\n      }\n      // If it is an interface and it is a returned type, grab all implementations so we can use proper __typename in fragments\n      if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {\n        queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));\n        // No need to revisit this interface again\n        revisit[typeName] = false;\n      }\n      // Visit interfaces this type is implementing if they haven't been visited yet\n      if ('getInterfaces' in type) {\n        // Only pushes to queue to visit but not return types\n        queue.push(...type.getInterfaces().map(iface => iface.name));\n      }\n      // If the type has files visit those field types\n      if ('getFields' in type) {\n        const fields = type.getFields();\n        const entries = Object.entries(fields);\n        if (!entries.length) {\n          continue;\n        }\n        for (const [, field] of entries) {\n          if ((0, graphql_1.isObjectType)(type)) {\n            // Visit arg types\n            queue.push(...field.args.map(arg => (0, graphql_1.getNamedType)(arg.type).name));\n          }\n          const namedType = (0, graphql_1.getNamedType)(field.type);\n          queue.push(namedType.name);\n          // Interfaces returned on fields need to be revisited to add their implementations\n          if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {\n            revisit[namedType.name] = true;\n          }\n        }\n      }\n      visited.add(typeName); // Mark as visited (and therefore it is used and should be kept)\n    }\n  }\n\n  return visited;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","pruneSchema","graphql_1","require","mapSchema_js_1","Interfaces_js_1","rootTypes_js_1","get_implementing_types_js_1","schema","options","skipEmptyCompositeTypePruning","skipEmptyUnionPruning","skipPruning","skipUnimplementedInterfacesPruning","skipUnusedTypesPruning","prunedTypes","prunedSchema","visited","visitSchema","revisit","typeName","getTypeMap","startsWith","type","getType","push","visitQueue","mapSchema","MapperKind","TYPE","has","name","isSpecifiedScalarType","isUnionType","isInputObjectType","isInterfaceType","isObjectType","isScalarType","keys","getTypes","length","getFields","delete","queue","getRootTypes","Set","Map","pop","map","getImplementingTypes","getInterfaces","iface","fields","entries","field","args","arg","getNamedType","namedType","add"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/prune.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pruneSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst mapSchema_js_1 = require(\"./mapSchema.js\");\nconst Interfaces_js_1 = require(\"./Interfaces.js\");\nconst rootTypes_js_1 = require(\"./rootTypes.js\");\nconst get_implementing_types_js_1 = require(\"./get-implementing-types.js\");\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\nfunction pruneSchema(schema, options = {}) {\n    const { skipEmptyCompositeTypePruning, skipEmptyUnionPruning, skipPruning, skipUnimplementedInterfacesPruning, skipUnusedTypesPruning, } = options;\n    let prunedTypes = []; // Pruned types during mapping\n    let prunedSchema = schema;\n    do {\n        let visited = visitSchema(prunedSchema);\n        // Custom pruning  was defined, so we need to pre-emptively revisit the schema accounting for this\n        if (skipPruning) {\n            const revisit = [];\n            for (const typeName in prunedSchema.getTypeMap()) {\n                if (typeName.startsWith('__')) {\n                    continue;\n                }\n                const type = prunedSchema.getType(typeName);\n                // if we want to skip pruning for this type, add it to the list of types to revisit\n                if (type && skipPruning(type)) {\n                    revisit.push(typeName);\n                }\n            }\n            visited = visitQueue(revisit, prunedSchema, visited); // visit again\n        }\n        prunedTypes = [];\n        prunedSchema = (0, mapSchema_js_1.mapSchema)(prunedSchema, {\n            [Interfaces_js_1.MapperKind.TYPE]: type => {\n                if (!visited.has(type.name) && !(0, graphql_1.isSpecifiedScalarType)(type)) {\n                    if ((0, graphql_1.isUnionType)(type) ||\n                        (0, graphql_1.isInputObjectType)(type) ||\n                        (0, graphql_1.isInterfaceType)(type) ||\n                        (0, graphql_1.isObjectType)(type) ||\n                        (0, graphql_1.isScalarType)(type)) {\n                        // skipUnusedTypesPruning: skip pruning unused types\n                        if (skipUnusedTypesPruning) {\n                            return type;\n                        }\n                        // skipEmptyUnionPruning: skip pruning empty unions\n                        if ((0, graphql_1.isUnionType)(type) && skipEmptyUnionPruning && !Object.keys(type.getTypes()).length) {\n                            return type;\n                        }\n                        if ((0, graphql_1.isInputObjectType)(type) || (0, graphql_1.isInterfaceType)(type) || (0, graphql_1.isObjectType)(type)) {\n                            // skipEmptyCompositeTypePruning: skip pruning object types or interfaces with no fields\n                            if (skipEmptyCompositeTypePruning && !Object.keys(type.getFields()).length) {\n                                return type;\n                            }\n                        }\n                        // skipUnimplementedInterfacesPruning: skip pruning interfaces that are not implemented by any other types\n                        if ((0, graphql_1.isInterfaceType)(type) && skipUnimplementedInterfacesPruning) {\n                            return type;\n                        }\n                    }\n                    prunedTypes.push(type.name);\n                    visited.delete(type.name);\n                    return null;\n                }\n                return type;\n            },\n        });\n    } while (prunedTypes.length); // Might have empty types and need to prune again\n    return prunedSchema;\n}\nexports.pruneSchema = pruneSchema;\nfunction visitSchema(schema) {\n    const queue = []; // queue of nodes to visit\n    // Grab the root types and start there\n    for (const type of (0, rootTypes_js_1.getRootTypes)(schema)) {\n        queue.push(type.name);\n    }\n    return visitQueue(queue, schema);\n}\nfunction visitQueue(queue, schema, visited = new Set()) {\n    // Interfaces encountered that are field return types need to be revisited to add their implementations\n    const revisit = new Map();\n    // Navigate all types starting with pre-queued types (root types)\n    while (queue.length) {\n        const typeName = queue.pop();\n        // Skip types we already visited unless it is an interface type that needs revisiting\n        if (visited.has(typeName) && revisit[typeName] !== true) {\n            continue;\n        }\n        const type = schema.getType(typeName);\n        if (type) {\n            // Get types for union\n            if ((0, graphql_1.isUnionType)(type)) {\n                queue.push(...type.getTypes().map(type => type.name));\n            }\n            // If it is an interface and it is a returned type, grab all implementations so we can use proper __typename in fragments\n            if ((0, graphql_1.isInterfaceType)(type) && revisit[typeName] === true) {\n                queue.push(...(0, get_implementing_types_js_1.getImplementingTypes)(type.name, schema));\n                // No need to revisit this interface again\n                revisit[typeName] = false;\n            }\n            // Visit interfaces this type is implementing if they haven't been visited yet\n            if ('getInterfaces' in type) {\n                // Only pushes to queue to visit but not return types\n                queue.push(...type.getInterfaces().map(iface => iface.name));\n            }\n            // If the type has files visit those field types\n            if ('getFields' in type) {\n                const fields = type.getFields();\n                const entries = Object.entries(fields);\n                if (!entries.length) {\n                    continue;\n                }\n                for (const [, field] of entries) {\n                    if ((0, graphql_1.isObjectType)(type)) {\n                        // Visit arg types\n                        queue.push(...field.args.map(arg => (0, graphql_1.getNamedType)(arg.type).name));\n                    }\n                    const namedType = (0, graphql_1.getNamedType)(field.type);\n                    queue.push(namedType.name);\n                    // Interfaces returned on fields need to be revisited to add their implementations\n                    if ((0, graphql_1.isInterfaceType)(namedType) && !(namedType.name in revisit)) {\n                        revisit[namedType.name] = true;\n                    }\n                }\n            }\n            visited.add(typeName); // Mark as visited (and therefore it is used and should be kept)\n        }\n    }\n    return visited;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}