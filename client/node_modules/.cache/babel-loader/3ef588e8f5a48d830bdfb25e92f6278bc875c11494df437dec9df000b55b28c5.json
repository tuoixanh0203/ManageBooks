{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;\nconst durationHistogram_1 = require(\"./durationHistogram\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nclass SizeEstimator {\n  constructor() {\n    this.bytes = 0;\n  }\n}\nexports.SizeEstimator = SizeEstimator;\nclass OurReport {\n  constructor(header) {\n    this.header = header;\n    this.tracesPerQuery = Object.create(null);\n    this.endTime = null;\n    this.operationCount = 0;\n    this.sizeEstimator = new SizeEstimator();\n  }\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(_ref) {\n    let {\n      statsReportKey,\n      trace,\n      asTrace,\n      includeTracesContributingToStats,\n      referencedFieldsByType\n    } = _ref;\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType\n    });\n    if (asTrace) {\n      const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n  getTracesAndStats(_ref2) {\n    let {\n      statsReportKey,\n      referencedFieldsByType\n    } = _ref2;\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n    for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n    return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);\n  }\n}\nexports.OurReport = OurReport;\nclass OurTracesAndStats {\n  constructor(referencedFieldsByType) {\n    this.referencedFieldsByType = referencedFieldsByType;\n    this.trace = [];\n    this.statsWithContext = new StatsByContext();\n    this.internalTracesContributingToStats = [];\n  }\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\nclass StatsByContext {\n  constructor() {\n    this.map = Object.create(null);\n  }\n  toArray() {\n    return Object.values(this.map);\n  }\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(trace, sizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);\n  }\n  getContextualizedStats(trace, sizeEstimator) {\n    const statsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\nclass OurContextualizedStats {\n  constructor(context) {\n    this.context = context;\n    this.queryLatencyStats = new OurQueryLatencyStats();\n    this.perTypeStat = Object.create(null);\n  }\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(trace, sizeEstimator) {\n    var _a;\n    const {\n      fieldExecutionWeight\n    } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n    if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {\n      switch (trace.cachePolicy.scope) {\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n      }\n    }\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n    let hasError = false;\n    const traceNodeStats = (node, path) => {\n      var _a, _b, _c, _d, _e;\n      if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {\n        hasError = true;\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach(subPath => {\n          currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);\n        });\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n      if (fieldExecutionWeight) {\n        const fieldName = node.originalFieldName || node.responseName;\n        if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n          const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);\n          fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);\n        }\n      }\n      return false;\n    };\n    (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n  getTypeStat(parentType, sizeEstimator) {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\nexports.OurContextualizedStats = OurContextualizedStats;\nclass OurQueryLatencyStats {\n  constructor() {\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n    this.requestCount = 0;\n    this.requestsWithoutFieldInstrumentation = 0;\n    this.cacheHits = 0;\n    this.persistedQueryHits = 0;\n    this.persistedQueryMisses = 0;\n    this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();\n    this.rootErrorStats = new OurPathErrorStats();\n    this.requestsWithErrorsCount = 0;\n    this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.registeredOperationCount = 0;\n    this.forbiddenOperationCount = 0;\n  }\n}\nclass OurPathErrorStats {\n  constructor() {\n    this.children = Object.create(null);\n    this.errorsCount = 0;\n    this.requestsWithErrorsCount = 0;\n  }\n  getChild(subPath, sizeEstimator) {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\nclass OurTypeStat {\n  constructor() {\n    this.perFieldStat = Object.create(null);\n  }\n  getFieldStat(fieldName, returnType, sizeEstimator) {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\nclass OurFieldStat {\n  constructor(returnType) {\n    this.returnType = returnType;\n    this.errorsCount = 0;\n    this.observedExecutionCount = 0;\n    this.estimatedExecutionCount = 0;\n    this.requestsWithErrorsCount = 0;\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n  }\n  ensureCountsAreIntegers() {\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\nfunction estimatedBytesForString(s) {\n  return 2 + Buffer.byteLength(s);\n}","map":{"version":3,"mappings":"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","names":["SizeEstimator","constructor","exports","OurReport","header","Object","create","ensureCountsAreIntegers","tracesAndStats","values","tracesPerQuery","addTrace","statsReportKey","trace","asTrace","includeTracesContributingToStats","referencedFieldsByType","getTracesAndStats","encodedTrace","apollo_reporting_protobuf_1","encode","finish","push","sizeEstimator","bytes","length","statsWithContext","internalTracesContributingToStats","existing","estimatedBytesForString","typeName","referencedFieldsForType","entries","isInterface","fieldName","fieldNames","OurTracesAndStats","StatsByContext","toArray","map","contextualizedStats","getContextualizedStats","statsContext","clientName","clientVersion","statsContextKey","JSON","stringify","OurContextualizedStats","context","OurQueryLatencyStats","typeStat","perTypeStat","fieldExecutionWeight","queryLatencyStats","requestsWithoutFieldInstrumentation","requestCount","fullQueryCacheHit","cacheLatencyCount","incrementDuration","durationNs","cacheHits","latencyCount","cachePolicy","maxAgeNs","scope","CachePolicy","Scope","PRIVATE","privateCacheTtlCount","PUBLIC","publicCacheTtlCount","persistedQueryHit","persistedQueryHits","persistedQueryRegister","persistedQueryMisses","forbiddenOperation","forbiddenOperationCount","registeredOperation","registeredOperationCount","hasError","traceNodeStats","node","path","error","currPathErrorStats","rootErrorStats","forEach","subPath","getChild","requestsWithErrorsCount","errorsCount","originalFieldName","responseName","parentType","type","endTime","startTime","getTypeStat","fieldStat","getFieldStat","observedExecutionCount","estimatedExecutionCount","OurTypeStat","durationHistogram_1","OurPathErrorStats","children","child","returnType","perFieldStat","OurFieldStat","Math","floor","s","Buffer","byteLength"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\stats.ts"],"sourcesContent":["import { DurationHistogram } from './durationHistogram';\nimport {\n  IFieldStat,\n  IPathErrorStats,\n  IQueryLatencyStats,\n  IStatsContext,\n  Trace,\n  ITypeStat,\n  IContextualizedStats,\n  ReportHeader,\n  google,\n  ITracesAndStats,\n  IReport,\n} from 'apollo-reporting-protobuf';\nimport { iterateOverTrace, ResponseNamePath } from './iterateOverTrace';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    includeTracesContributingToStats,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    includeTracesContributingToStats: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        // For specific use inside Apollo's infrastructure to help validate that\n        // the code in this file matches similar code in Apollo's servers,\n        // include the traces that contribute to the stats. Doing this outside\n        // of Apollo's infrastructure only serves to make reports larger with no\n        // other advantage.\n        const encodedTrace = Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount: number = 0;\n  requestsWithoutFieldInstrumentation: number = 0;\n  cacheHits: number = 0;\n  persistedQueryHits: number = 0;\n  persistedQueryMisses: number = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount: number = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount: number = 0;\n  forbiddenOperationCount: number = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount: number = 0;\n  observedExecutionCount: number = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}