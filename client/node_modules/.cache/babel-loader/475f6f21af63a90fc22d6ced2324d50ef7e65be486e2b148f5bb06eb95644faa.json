{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addMocksToSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst schema_1 = require(\"@graphql-tools/schema\");\nconst types_js_1 = require(\"./types.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst MockStore_js_1 = require(\"./MockStore.js\");\n// todo: add option to preserve resolver\n/**\n * Given a `schema` and a `MockStore`, returns an executable schema that\n * will use the provided `MockStore` to execute queries.\n *\n * ```ts\n * const schema = buildSchema(`\n *  type User {\n *    id: ID!\n *    name: String!\n *  }\n *  type Query {\n *    me: User!\n *  }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({ schema, store });\n * ```\n *\n *\n * If a `resolvers` parameter is passed, the query execution will use\n * the provided `resolvers` if, one exists, instead of the default mock\n * resolver.\n *\n *\n * ```ts\n * const schema = buildSchema(`\n *   type User {\n *     id: ID!\n *     name: String!\n *   }\n *   type Query {\n *     me: User!\n *   }\n *   type Mutation {\n *     setMyName(newName: String!): User!\n *   }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({\n *   schema,\n *   store,\n *   resolvers: {\n *     Mutation: {\n *       setMyName: (_, { newName }) => {\n *          const ref = store.get('Query', 'ROOT', 'viewer');\n *          store.set(ref, 'name', newName);\n *          return ref;\n *       }\n *     }\n *   }\n *  });\n * ```\n *\n *\n * `Query` and `Mutation` type will use `key` `'ROOT'`.\n */\nfunction addMocksToSchema(_ref) {\n  let {\n    schema,\n    store: maybeStore,\n    mocks,\n    typePolicies,\n    resolvers: resolversOrFnResolvers,\n    preserveResolvers = false\n  } = _ref;\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n  if (!(0, graphql_1.isSchema)(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n  if (mocks && !(0, utils_js_1.isObject)(mocks)) {\n    throw new Error('mocks must be of type Object');\n  }\n  const store = maybeStore || (0, MockStore_js_1.createMockStore)({\n    schema,\n    mocks,\n    typePolicies\n  });\n  const resolvers = typeof resolversOrFnResolvers === 'function' ? resolversOrFnResolvers(store) : resolversOrFnResolvers;\n  const mockResolver = (source, args, contex, info) => {\n    const defaultResolvedValue = (0, graphql_1.defaultFieldResolver)(source, args, contex, info);\n    // priority to default resolved value\n    if (defaultResolvedValue !== undefined) return defaultResolvedValue;\n    if ((0, types_js_1.isRef)(source)) {\n      return store.get({\n        typeName: source.$ref.typeName,\n        key: source.$ref.key,\n        fieldName: info.fieldName,\n        fieldArgs: args\n      });\n    }\n    // we have to handle the root mutation, root query and root subscription types\n    // differently, because no resolver is called at the root\n    if ((0, utils_js_1.isRootType)(info.parentType, info.schema)) {\n      return store.get({\n        typeName: info.parentType.name,\n        key: 'ROOT',\n        fieldName: info.fieldName,\n        fieldArgs: args\n      });\n    }\n    if (defaultResolvedValue === undefined) {\n      // any is used here because generateFieldValue is a private method at time of writing\n      return store.generateFieldValue(info.parentType.name, info.fieldName);\n    }\n    return undefined;\n  };\n  const typeResolver = data => {\n    if ((0, types_js_1.isRef)(data)) {\n      return data.$ref.typeName;\n    }\n  };\n  const mockSubscriber = () => ({\n    [Symbol.asyncIterator]() {\n      return {\n        async next() {\n          return {\n            done: true,\n            value: {}\n          };\n        }\n      };\n    }\n  });\n  const schemaWithMocks = (0, utils_1.mapSchema)(schema, {\n    [utils_1.MapperKind.OBJECT_FIELD]: fieldConfig => {\n      const newFieldConfig = {\n        ...fieldConfig\n      };\n      const oldResolver = fieldConfig.resolve;\n      if (!preserveResolvers || !oldResolver) {\n        newFieldConfig.resolve = mockResolver;\n      } else {\n        newFieldConfig.resolve = async (rootObject, args, context, info) => {\n          const [mockedValue, resolvedValue] = await Promise.all([mockResolver(rootObject, args, context, info), oldResolver(rootObject, args, context, info)]);\n          // In case we couldn't mock\n          if (mockedValue instanceof Error) {\n            // only if value was not resolved, populate the error.\n            if (undefined === resolvedValue) {\n              throw mockedValue;\n            }\n            return resolvedValue;\n          }\n          if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          }\n          if ((0, utils_js_1.isObject)(mockedValue) && (0, utils_js_1.isObject)(resolvedValue)) {\n            // Object.assign() won't do here, as we need to all properties, including\n            // the non-enumerable ones and defined using Object.defineProperty\n            const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n            return (0, utils_js_1.copyOwnProps)(emptyObject, resolvedValue, mockedValue);\n          }\n          return undefined !== resolvedValue ? resolvedValue : mockedValue;\n        };\n      }\n      const fieldSubscriber = fieldConfig.subscribe;\n      if (!preserveResolvers || !fieldSubscriber) {\n        newFieldConfig.subscribe = mockSubscriber;\n      } else {\n        newFieldConfig.subscribe = async (rootObject, args, context, info) => {\n          const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([mockSubscriber(rootObject, args, context, info), fieldSubscriber(rootObject, args, context, info)]);\n          return oldAsyncIterable || mockAsyncIterable;\n        };\n      }\n      return newFieldConfig;\n    },\n    [utils_1.MapperKind.ABSTRACT_TYPE]: type => {\n      if (preserveResolvers && type.resolveType != null && type.resolveType.length) {\n        return;\n      }\n      if ((0, graphql_1.isUnionType)(type)) {\n        return new graphql_1.GraphQLUnionType({\n          ...type.toConfig(),\n          resolveType: typeResolver\n        });\n      } else {\n        return new graphql_1.GraphQLInterfaceType({\n          ...type.toConfig(),\n          resolveType: typeResolver\n        });\n      }\n    }\n  });\n  return resolvers ? (0, schema_1.addResolversToSchema)({\n    schema: schemaWithMocks,\n    resolvers: resolvers\n  }) : schemaWithMocks;\n}\nexports.addMocksToSchema = addMocksToSchema;","map":{"version":3,"names":["Object","defineProperty","exports","value","addMocksToSchema","graphql_1","require","utils_1","schema_1","types_js_1","utils_js_1","MockStore_js_1","schema","store","maybeStore","mocks","typePolicies","resolvers","resolversOrFnResolvers","preserveResolvers","Error","isSchema","isObject","createMockStore","mockResolver","source","args","contex","info","defaultResolvedValue","defaultFieldResolver","undefined","isRef","get","typeName","$ref","key","fieldName","fieldArgs","isRootType","parentType","name","generateFieldValue","typeResolver","data","mockSubscriber","Symbol","asyncIterator","next","done","schemaWithMocks","mapSchema","MapperKind","OBJECT_FIELD","fieldConfig","newFieldConfig","oldResolver","resolve","rootObject","context","mockedValue","resolvedValue","Promise","all","Date","emptyObject","create","getPrototypeOf","copyOwnProps","fieldSubscriber","subscribe","mockAsyncIterable","oldAsyncIterable","ABSTRACT_TYPE","type","resolveType","length","isUnionType","GraphQLUnionType","toConfig","GraphQLInterfaceType","addResolversToSchema"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/mock/cjs/addMocksToSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addMocksToSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst schema_1 = require(\"@graphql-tools/schema\");\nconst types_js_1 = require(\"./types.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst MockStore_js_1 = require(\"./MockStore.js\");\n// todo: add option to preserve resolver\n/**\n * Given a `schema` and a `MockStore`, returns an executable schema that\n * will use the provided `MockStore` to execute queries.\n *\n * ```ts\n * const schema = buildSchema(`\n *  type User {\n *    id: ID!\n *    name: String!\n *  }\n *  type Query {\n *    me: User!\n *  }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({ schema, store });\n * ```\n *\n *\n * If a `resolvers` parameter is passed, the query execution will use\n * the provided `resolvers` if, one exists, instead of the default mock\n * resolver.\n *\n *\n * ```ts\n * const schema = buildSchema(`\n *   type User {\n *     id: ID!\n *     name: String!\n *   }\n *   type Query {\n *     me: User!\n *   }\n *   type Mutation {\n *     setMyName(newName: String!): User!\n *   }\n * `)\n *\n * const store = createMockStore({ schema });\n * const mockedSchema = addMocksToSchema({\n *   schema,\n *   store,\n *   resolvers: {\n *     Mutation: {\n *       setMyName: (_, { newName }) => {\n *          const ref = store.get('Query', 'ROOT', 'viewer');\n *          store.set(ref, 'name', newName);\n *          return ref;\n *       }\n *     }\n *   }\n *  });\n * ```\n *\n *\n * `Query` and `Mutation` type will use `key` `'ROOT'`.\n */\nfunction addMocksToSchema({ schema, store: maybeStore, mocks, typePolicies, resolvers: resolversOrFnResolvers, preserveResolvers = false, }) {\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!(0, graphql_1.isSchema)(schema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (mocks && !(0, utils_js_1.isObject)(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    const store = maybeStore ||\n        (0, MockStore_js_1.createMockStore)({\n            schema,\n            mocks,\n            typePolicies,\n        });\n    const resolvers = typeof resolversOrFnResolvers === 'function'\n        ? resolversOrFnResolvers(store)\n        : resolversOrFnResolvers;\n    const mockResolver = (source, args, contex, info) => {\n        const defaultResolvedValue = (0, graphql_1.defaultFieldResolver)(source, args, contex, info);\n        // priority to default resolved value\n        if (defaultResolvedValue !== undefined)\n            return defaultResolvedValue;\n        if ((0, types_js_1.isRef)(source)) {\n            return store.get({\n                typeName: source.$ref.typeName,\n                key: source.$ref.key,\n                fieldName: info.fieldName,\n                fieldArgs: args,\n            });\n        }\n        // we have to handle the root mutation, root query and root subscription types\n        // differently, because no resolver is called at the root\n        if ((0, utils_js_1.isRootType)(info.parentType, info.schema)) {\n            return store.get({\n                typeName: info.parentType.name,\n                key: 'ROOT',\n                fieldName: info.fieldName,\n                fieldArgs: args,\n            });\n        }\n        if (defaultResolvedValue === undefined) {\n            // any is used here because generateFieldValue is a private method at time of writing\n            return store.generateFieldValue(info.parentType.name, info.fieldName);\n        }\n        return undefined;\n    };\n    const typeResolver = data => {\n        if ((0, types_js_1.isRef)(data)) {\n            return data.$ref.typeName;\n        }\n    };\n    const mockSubscriber = () => ({\n        [Symbol.asyncIterator]() {\n            return {\n                async next() {\n                    return {\n                        done: true,\n                        value: {},\n                    };\n                },\n            };\n        },\n    });\n    const schemaWithMocks = (0, utils_1.mapSchema)(schema, {\n        [utils_1.MapperKind.OBJECT_FIELD]: fieldConfig => {\n            const newFieldConfig = {\n                ...fieldConfig,\n            };\n            const oldResolver = fieldConfig.resolve;\n            if (!preserveResolvers || !oldResolver) {\n                newFieldConfig.resolve = mockResolver;\n            }\n            else {\n                newFieldConfig.resolve = async (rootObject, args, context, info) => {\n                    const [mockedValue, resolvedValue] = await Promise.all([\n                        mockResolver(rootObject, args, context, info),\n                        oldResolver(rootObject, args, context, info),\n                    ]);\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if ((0, utils_js_1.isObject)(mockedValue) && (0, utils_js_1.isObject)(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return (0, utils_js_1.copyOwnProps)(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                };\n            }\n            const fieldSubscriber = fieldConfig.subscribe;\n            if (!preserveResolvers || !fieldSubscriber) {\n                newFieldConfig.subscribe = mockSubscriber;\n            }\n            else {\n                newFieldConfig.subscribe = async (rootObject, args, context, info) => {\n                    const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([\n                        mockSubscriber(rootObject, args, context, info),\n                        fieldSubscriber(rootObject, args, context, info),\n                    ]);\n                    return oldAsyncIterable || mockAsyncIterable;\n                };\n            }\n            return newFieldConfig;\n        },\n        [utils_1.MapperKind.ABSTRACT_TYPE]: type => {\n            if (preserveResolvers && type.resolveType != null && type.resolveType.length) {\n                return;\n            }\n            if ((0, graphql_1.isUnionType)(type)) {\n                return new graphql_1.GraphQLUnionType({\n                    ...type.toConfig(),\n                    resolveType: typeResolver,\n                });\n            }\n            else {\n                return new graphql_1.GraphQLInterfaceType({\n                    ...type.toConfig(),\n                    resolveType: typeResolver,\n                });\n            }\n        },\n    });\n    return resolvers\n        ? (0, schema_1.addResolversToSchema)({\n            schema: schemaWithMocks,\n            resolvers: resolvers,\n        })\n        : schemaWithMocks;\n}\nexports.addMocksToSchema = addMocksToSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}