{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observableToAsyncIterable = void 0;\nfunction observableToAsyncIterable(observable) {\n  const pullQueue = [];\n  const pushQueue = [];\n  let listening = true;\n  const pushValue = value => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value,\n        done: false\n      });\n    }\n  };\n  const pushError = error => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    }\n  };\n  const pushDone = () => {\n    if (pullQueue.length !== 0) {\n      // It is safe to use the ! operator here as we check the length.\n      pullQueue.shift()({\n        done: true\n      });\n    } else {\n      pushQueue.push({\n        done: true\n      });\n    }\n  };\n  const pullValue = () => new Promise(resolve => {\n    if (pushQueue.length !== 0) {\n      const element = pushQueue.shift();\n      // either {value: {errors: [...]}} or {value: ...}\n      resolve(element);\n    } else {\n      pullQueue.push(resolve);\n    }\n  });\n  const subscription = observable.subscribe({\n    next(value) {\n      pushValue(value);\n    },\n    error(err) {\n      pushError(err);\n    },\n    complete() {\n      pushDone();\n    }\n  });\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n      for (const resolve of pullQueue) {\n        resolve({\n          value: undefined,\n          done: true\n        });\n      }\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n  return {\n    next() {\n      // return is a defined method, so it is safe to call it.\n      return listening ? pullValue() : this.return();\n    },\n    return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\nexports.observableToAsyncIterable = observableToAsyncIterable;","map":{"version":3,"names":["Object","defineProperty","exports","value","observableToAsyncIterable","observable","pullQueue","pushQueue","listening","pushValue","length","shift","done","push","pushError","error","errors","pushDone","pullValue","Promise","resolve","element","subscription","subscribe","next","err","complete","emptyQueue","unsubscribe","undefined","return","throw","reject","Symbol","asyncIterator"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/observableToAsyncIterable.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.observableToAsyncIterable = void 0;\nfunction observableToAsyncIterable(observable) {\n    const pullQueue = [];\n    const pushQueue = [];\n    let listening = true;\n    const pushValue = (value) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value, done: false });\n        }\n        else {\n            pushQueue.push({ value, done: false });\n        }\n    };\n    const pushError = (error) => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] }, done: false });\n        }\n    };\n    const pushDone = () => {\n        if (pullQueue.length !== 0) {\n            // It is safe to use the ! operator here as we check the length.\n            pullQueue.shift()({ done: true });\n        }\n        else {\n            pushQueue.push({ done: true });\n        }\n    };\n    const pullValue = () => new Promise(resolve => {\n        if (pushQueue.length !== 0) {\n            const element = pushQueue.shift();\n            // either {value: {errors: [...]}} or {value: ...}\n            resolve(element);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const subscription = observable.subscribe({\n        next(value) {\n            pushValue(value);\n        },\n        error(err) {\n            pushError(err);\n        },\n        complete() {\n            pushDone();\n        },\n    });\n    const emptyQueue = () => {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            for (const resolve of pullQueue) {\n                resolve({ value: undefined, done: true });\n            }\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return {\n        next() {\n            // return is a defined method, so it is safe to call it.\n            return listening ? pullValue() : this.return();\n        },\n        return() {\n            emptyQueue();\n            return Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            emptyQueue();\n            return Promise.reject(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nexports.observableToAsyncIterable = observableToAsyncIterable;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}