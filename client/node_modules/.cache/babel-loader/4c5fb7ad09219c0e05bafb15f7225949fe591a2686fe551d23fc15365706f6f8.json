{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.iterateOverTrace = void 0;\nfunction iterateOverTrace(trace, f, includePath) {\n  const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\nexports.iterateOverTrace = iterateOverTrace;\nfunction iterateOverQueryPlan(node, rootPath, f) {\n  var _a, _b, _c, _d, _e;\n  if (!node) return false;\n  if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {\n    return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);\n  }\n  if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {\n    return node.parallel.nodes.some(node => iterateOverQueryPlan(node, rootPath, f));\n  }\n  if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {\n    return node.sequence.nodes.some(node => iterateOverQueryPlan(node, rootPath, f));\n  }\n  return false;\n}\nfunction iterateOverTraceNode(node, path, f) {\n  var _a, _b;\n  if (f(node, path)) {\n    return true;\n  }\n  return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some(child => {\n    const childPath = child.responseName ? path.child(child.responseName) : path;\n    return iterateOverTraceNode(child, childPath, f);\n  })) !== null && _b !== void 0 ? _b : false;\n}\nconst notCollectingPathsResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  }\n};\nclass RootCollectingPathsResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath {\n  constructor(responseName, prev) {\n    this.responseName = responseName;\n    this.prev = prev;\n  }\n  toArray() {\n    const out = [];\n    let curr = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}","map":{"version":3,"mappings":"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","names":["iterateOverTrace","trace","f","includePath","rootPath","RootCollectingPathsResponseNamePath","notCollectingPathsResponseNamePath","root","iterateOverTraceNode","queryPlan","iterateOverQueryPlan","exports","node","fetch","serviceName","child","flatten","parallel","nodes","some","sequence","path","childPath","responseName","toArray","Error","ChildCollectingPathsResponseNamePath","constructor","prev","out","curr","push","reverse"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\iterateOverTrace.ts"],"sourcesContent":["import type { Trace } from 'apollo-reporting-protobuf';\n\n/**\n * Iterates over the entire trace, calling `f` on each Trace.Node found. It\n * looks under the \"root\" node as well as any inside the query plan. If any `f`\n * returns true, it stops walking the tree.\n *\n * Each call to `f` will receive an object that implements ResponseNamePath. If\n * `includePath` is true, `f` can call `toArray()` on it to convert the\n * linked-list representation to an array of the response name (field name)\n * nodes that you navigate to get to the node (including a \"service:subgraph\"\n * top-level node if this is a federated trace). Note that we don't add anything\n * to the path for index (list element) nodes. This is because the only use case\n * we have (error path statistics) does not care about list indexes (it's not\n * that interesting to know that sometimes an error was at foo.3.bar and\n * sometimes foo.5.bar, vs just generally foo.bar).\n *\n * If `includePath` is false, we don't bother to build up the linked lists, and\n * calling `toArray()` will throw.\n */\nexport function iterateOverTrace(\n  trace: Trace,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n  includePath: boolean,\n) {\n  const rootPath = includePath\n    ? new RootCollectingPathsResponseNamePath()\n    : notCollectingPathsResponseNamePath;\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverQueryPlan(\n  node: Trace.IQueryPlanNode,\n  rootPath: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  if (!node) return false;\n\n  if (node.fetch?.trace?.root && node.fetch.serviceName) {\n    return iterateOverTraceNode(\n      node.fetch.trace.root,\n      rootPath.child(`service:${node.fetch.serviceName}`),\n      f,\n    );\n  }\n  if (node.flatten?.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n  if (node.parallel?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.parallel.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n  if (node.sequence?.nodes) {\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    return node.sequence.nodes.some((node) =>\n      iterateOverQueryPlan(node, rootPath, f),\n    );\n  }\n\n  return false;\n}\n\n// Helper for iterateOverTrace; returns true to stop the overall walk.\nfunction iterateOverTraceNode(\n  node: Trace.INode,\n  path: ResponseNamePath,\n  f: (node: Trace.INode, path: ResponseNamePath) => boolean,\n): boolean {\n  // Invoke the function; if it returns true, don't descend and tell callers to\n  // stop walking.\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (\n    // We want to stop as soon as some call returns true, which happens to be\n    // exactly what 'some' does.\n    node.child?.some((child) => {\n      const childPath = child.responseName\n        ? path.child(child.responseName)\n        : path;\n      return iterateOverTraceNode(child, childPath, f);\n    }) ?? false\n  );\n}\n\nexport interface ResponseNamePath {\n  toArray(): string[];\n  child(responseName: string): ResponseNamePath;\n}\n\nconst notCollectingPathsResponseNamePath: ResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n  child() {\n    return this;\n  },\n};\n\ntype CollectingPathsResponseNamePath =\n  | RootCollectingPathsResponseNamePath\n  | ChildCollectingPathsResponseNamePath;\nclass RootCollectingPathsResponseNamePath implements ResponseNamePath {\n  toArray() {\n    return [];\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\nclass ChildCollectingPathsResponseNamePath implements ResponseNamePath {\n  constructor(\n    readonly responseName: string,\n    readonly prev: CollectingPathsResponseNamePath,\n  ) {}\n  toArray() {\n    const out = [];\n    let curr: CollectingPathsResponseNamePath = this;\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n    return out.reverse();\n  }\n  child(responseName: string) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}