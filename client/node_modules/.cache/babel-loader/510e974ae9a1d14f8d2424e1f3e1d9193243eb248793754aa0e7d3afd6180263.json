{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildOperationNodeForField = void 0;\nconst graphql_1 = require(\"graphql\");\nconst rootTypes_js_1 = require(\"./rootTypes.js\");\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField(_ref) {\n  let {\n    schema,\n    kind,\n    field,\n    models,\n    ignore = [],\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields = true\n  } = _ref;\n  resetOperationVariables();\n  resetFieldMap();\n  const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);\n  const operationNode = buildOperationAndCollectVariables({\n    schema,\n    fieldName: field,\n    kind,\n    models: models || [],\n    ignore,\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  });\n  // attach variables\n  operationNode.variableDefinitions = [...operationVariables];\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\nexports.buildOperationNodeForField = buildOperationNodeForField;\nfunction buildOperationAndCollectVariables(_ref2) {\n  let {\n    schema,\n    fieldName,\n    kind,\n    models,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref2;\n  const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);\n  const field = type.getFields()[fieldName];\n  const operationName = `${fieldName}_${kind}`;\n  if (field.args) {\n    for (const arg of field.args) {\n      const argName = arg.name;\n      if (!argNames || argNames.includes(argName)) {\n        addOperationVariable(resolveVariable(arg, argName));\n      }\n    }\n  }\n  return {\n    kind: graphql_1.Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: graphql_1.Kind.NAME,\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: [resolveField({\n        type,\n        field,\n        models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: 0,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      })]\n    }\n  };\n}\nfunction resolveSelectionSet(_ref3) {\n  let {\n    parent,\n    type,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref3;\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n  if ((0, graphql_1.isUnionType)(type)) {\n    const types = type.getTypes();\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql_1.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql_1.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n  if ((0, graphql_1.isInterfaceType)(type)) {\n    const types = Object.values(schema.getTypeMap()).filter(t => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql_1.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql_1.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n  if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {\n    const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n    const isModel = models.includes(type.name);\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: graphql_1.Kind.SELECTION_SET,\n        selections: [{\n          kind: graphql_1.Kind.FIELD,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n    const fields = type.getFields();\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(fieldName => {\n        return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {\n          depth: circularReferenceDepth\n        });\n      }).map(fieldName => {\n        const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n        if (selectedSubFields) {\n          return resolveField({\n            type,\n            field: fields[fieldName],\n            models,\n            path: [...path, fieldName],\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields: selectedSubFields,\n            rootTypeNames\n          });\n        }\n        return null;\n      }).filter(f => {\n        var _a, _b;\n        if (f == null) {\n          return false;\n        } else if ('selectionSet' in f) {\n          return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n        }\n        return true;\n      })\n    };\n  }\n}\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if ((0, graphql_1.isListType)(type)) {\n      return {\n        kind: graphql_1.Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n    if ((0, graphql_1.isNonNullType)(type)) {\n      return {\n        kind: graphql_1.Kind.NON_NULL_TYPE,\n        // for v16 compatibility\n        type: resolveVariableType(type.ofType)\n      };\n    }\n    return {\n      kind: graphql_1.Kind.NAMED_TYPE,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n  return {\n    kind: graphql_1.Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: graphql_1.Kind.VARIABLE,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\nfunction getArgumentName(name, path) {\n  return [...path, name].join('_');\n}\nfunction resolveField(_ref4) {\n  let {\n    type,\n    field,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref4;\n  const namedType = (0, graphql_1.getNamedType)(field.type);\n  let args = [];\n  let removeField = false;\n  if (field.args && field.args.length) {\n    args = field.args.map(arg => {\n      const argumentName = getArgumentName(arg.name, path);\n      if (argNames && !argNames.includes(argumentName)) {\n        if ((0, graphql_1.isNonNullType)(arg.type)) {\n          removeField = true;\n        }\n        return null;\n      }\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n      return {\n        kind: graphql_1.Kind.ARGUMENT,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: graphql_1.Kind.VARIABLE,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n  if (removeField) {\n    return null;\n  }\n  const fieldPath = [...path, field.name];\n  const fieldPathStr = fieldPath.join('.');\n  let fieldName = field.name;\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull');\n  }\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n  if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {\n    return {\n      kind: graphql_1.Kind.FIELD,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: field.name\n      },\n      ...(fieldName !== field.name && {\n        alias: {\n          kind: graphql_1.Kind.NAME,\n          value: fieldName\n        }\n      }),\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models,\n        firstCall,\n        path: fieldPath,\n        ancestors: [...ancestors, type],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: depth + 1,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      }) || undefined,\n      arguments: args\n    };\n  }\n  return {\n    kind: graphql_1.Kind.FIELD,\n    name: {\n      kind: graphql_1.Kind.NAME,\n      value: field.name\n    },\n    ...(fieldName !== field.name && {\n      alias: {\n        kind: graphql_1.Kind.NAME,\n        value: fieldName\n      }\n    }),\n    arguments: args\n  };\n}\nfunction hasCircularRef(types) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    depth: 1\n  };\n  const type = types[types.length - 1];\n  if ((0, graphql_1.isScalarType)(type)) {\n    return false;\n  }\n  const size = types.filter(t => t.name === type.name).length;\n  return size > config.depth;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildOperationNodeForField","graphql_1","require","rootTypes_js_1","operationVariables","fieldTypeMap","Map","addOperationVariable","variable","push","resetOperationVariables","resetFieldMap","schema","kind","field","models","ignore","depthLimit","circularReferenceDepth","argNames","selectedFields","rootTypeNames","getRootTypeNames","operationNode","buildOperationAndCollectVariables","fieldName","Infinity","variableDefinitions","type","getDefinedRootType","getFields","operationName","args","arg","argName","name","includes","resolveVariable","Kind","OPERATION_DEFINITION","operation","NAME","selectionSet","SELECTION_SET","selections","resolveField","firstCall","path","ancestors","depth","resolveSelectionSet","parent","isUnionType","types","getTypes","filter","t","hasCircularRef","map","INLINE_FRAGMENT","typeCondition","NAMED_TYPE","fragmentNode","_a","_b","length","isInterfaceType","values","getTypeMap","isObjectType","getInterfaces","has","isIgnored","isModel","FIELD","fields","keys","getNamedType","selectedSubFields","f","resolveVariableType","isListType","LIST_TYPE","ofType","isNonNullType","NON_NULL_TYPE","VARIABLE_DEFINITION","VARIABLE","getArgumentName","join","namedType","removeField","argumentName","ARGUMENT","Boolean","fieldPath","fieldPathStr","get","toString","replace","set","isScalarType","isEnumType","alias","undefined","arguments","config","size"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildOperationNodeForField = void 0;\nconst graphql_1 = require(\"graphql\");\nconst rootTypes_js_1 = require(\"./rootTypes.js\");\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true, }) {\n    resetOperationVariables();\n    resetFieldMap();\n    const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);\n    const operationNode = buildOperationAndCollectVariables({\n        schema,\n        fieldName: field,\n        kind,\n        models: models || [],\n        ignore,\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames,\n        selectedFields,\n        rootTypeNames,\n    });\n    // attach variables\n    operationNode.variableDefinitions = [...operationVariables];\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nexports.buildOperationNodeForField = buildOperationNodeForField;\nfunction buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames, }) {\n    const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);\n    const field = type.getFields()[fieldName];\n    const operationName = `${fieldName}_${kind}`;\n    if (field.args) {\n        for (const arg of field.args) {\n            const argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        }\n    }\n    return {\n        kind: graphql_1.Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: graphql_1.Kind.NAME,\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type,\n                    field,\n                    models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore,\n                    depthLimit,\n                    circularReferenceDepth,\n                    schema,\n                    depth: 0,\n                    argNames,\n                    selectedFields,\n                    rootTypeNames,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if ((0, graphql_1.isUnionType)(type)) {\n        const types = type.getTypes();\n        return {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if ((0, graphql_1.isInterfaceType)(type)) {\n        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));\n        return {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {\n        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n        const isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: graphql_1.Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: graphql_1.Kind.FIELD,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        const fields = type.getFields();\n        return {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: Object.keys(fields)\n                .filter(fieldName => {\n                return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(fieldName => {\n                const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type,\n                        field: fields[fieldName],\n                        models,\n                        path: [...path, fieldName],\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields: selectedSubFields,\n                        rootTypeNames,\n                    });\n                }\n                return null;\n            })\n                .filter((f) => {\n                var _a, _b;\n                if (f == null) {\n                    return false;\n                }\n                else if ('selectionSet' in f) {\n                    return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n                }\n                return true;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if ((0, graphql_1.isListType)(type)) {\n            return {\n                kind: graphql_1.Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if ((0, graphql_1.isNonNullType)(type)) {\n            return {\n                kind: graphql_1.Kind.NON_NULL_TYPE,\n                // for v16 compatibility\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: graphql_1.Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: graphql_1.Kind.VARIABLE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return [...path, name].join('_');\n}\nfunction resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    const namedType = (0, graphql_1.getNamedType)(field.type);\n    let args = [];\n    let removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(arg => {\n            const argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if ((0, graphql_1.isNonNullType)(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: graphql_1.Kind.ARGUMENT,\n                name: {\n                    kind: graphql_1.Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: graphql_1.Kind.VARIABLE,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    const fieldPath = [...path, field.name];\n    const fieldPathStr = fieldPath.join('.');\n    let fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {\n        return {\n            kind: graphql_1.Kind.FIELD,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: field.name,\n            },\n            ...(fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } }),\n            selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models,\n                firstCall,\n                path: fieldPath,\n                ancestors: [...ancestors, type],\n                ignore,\n                depthLimit,\n                circularReferenceDepth,\n                schema,\n                depth: depth + 1,\n                argNames,\n                selectedFields,\n                rootTypeNames,\n            }) || undefined,\n            arguments: args,\n        };\n    }\n    return {\n        kind: graphql_1.Kind.FIELD,\n        name: {\n            kind: graphql_1.Kind.NAME,\n            value: field.name,\n        },\n        ...(fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } }),\n        arguments: args,\n    };\n}\nfunction hasCircularRef(types, config = {\n    depth: 1,\n}) {\n    const type = types[types.length - 1];\n    if ((0, graphql_1.isScalarType)(type)) {\n        return false;\n    }\n    const size = types.filter(t => t.name === type.name).length;\n    return size > config.depth;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}