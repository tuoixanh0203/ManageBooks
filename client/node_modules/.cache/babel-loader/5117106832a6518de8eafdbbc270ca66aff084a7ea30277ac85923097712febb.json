{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeExecutableSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst addResolversToSchema_js_1 = require(\"./addResolversToSchema.js\");\nconst assertResolversPresent_js_1 = require(\"./assertResolversPresent.js\");\nconst merge_1 = require(\"@graphql-tools/merge\");\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema(_ref) {\n  let {\n    typeDefs,\n    resolvers = {},\n    resolverValidationOptions = {},\n    parseOptions = {},\n    inheritResolversFromInterfaces = false,\n    pruningOptions,\n    updateResolversInPlace = false,\n    schemaExtensions\n  } = _ref;\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n  let schema;\n  if ((0, graphql_1.isSchema)(typeDefs)) {\n    schema = typeDefs;\n  } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n    const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {\n      ...parseOptions,\n      commentDescriptions: true\n    });\n    schema = (0, graphql_1.buildSchema)(mergedTypeDefs, parseOptions);\n  } else {\n    const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, parseOptions);\n    schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, parseOptions);\n  }\n  if (pruningOptions) {\n    schema = (0, utils_1.pruneSchema)(schema);\n  }\n  // We allow passing in an array of resolver maps, in which case we merge them\n  schema = (0, addResolversToSchema_js_1.addResolversToSchema)({\n    schema,\n    resolvers: (0, merge_1.mergeResolvers)(resolvers),\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n    updateResolversInPlace\n  });\n  if (Object.keys(resolverValidationOptions).length > 0) {\n    (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);\n  }\n  if (schemaExtensions) {\n    schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));\n    (0, merge_1.applyExtensions)(schema, schemaExtensions);\n  }\n  return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;","map":{"version":3,"names":["Object","defineProperty","exports","value","makeExecutableSchema","graphql_1","require","utils_1","addResolversToSchema_js_1","assertResolversPresent_js_1","merge_1","typeDefs","resolvers","resolverValidationOptions","parseOptions","inheritResolversFromInterfaces","pruningOptions","updateResolversInPlace","schemaExtensions","Error","schema","isSchema","commentDescriptions","mergedTypeDefs","mergeTypeDefs","buildSchema","buildASTSchema","pruneSchema","addResolversToSchema","mergeResolvers","keys","length","assertResolversPresent","mergeExtensions","asArray","applyExtensions"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/schema/cjs/makeExecutableSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeExecutableSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst addResolversToSchema_js_1 = require(\"./addResolversToSchema.js\");\nconst assertResolversPresent_js_1 = require(\"./assertResolversPresent.js\");\nconst merge_1 = require(\"@graphql-tools/merge\");\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nfunction makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions, }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    let schema;\n    if ((0, graphql_1.isSchema)(typeDefs)) {\n        schema = typeDefs;\n    }\n    else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {\n        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, {\n            ...parseOptions,\n            commentDescriptions: true,\n        });\n        schema = (0, graphql_1.buildSchema)(mergedTypeDefs, parseOptions);\n    }\n    else {\n        const mergedTypeDefs = (0, merge_1.mergeTypeDefs)(typeDefs, parseOptions);\n        schema = (0, graphql_1.buildASTSchema)(mergedTypeDefs, parseOptions);\n    }\n    if (pruningOptions) {\n        schema = (0, utils_1.pruneSchema)(schema);\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    schema = (0, addResolversToSchema_js_1.addResolversToSchema)({\n        schema,\n        resolvers: (0, merge_1.mergeResolvers)(resolvers),\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n    });\n    if (Object.keys(resolverValidationOptions).length > 0) {\n        (0, assertResolversPresent_js_1.assertResolversPresent)(schema, resolverValidationOptions);\n    }\n    if (schemaExtensions) {\n        schemaExtensions = (0, merge_1.mergeExtensions)((0, utils_1.asArray)(schemaExtensions));\n        (0, merge_1.applyExtensions)(schema, schemaExtensions);\n    }\n    return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}