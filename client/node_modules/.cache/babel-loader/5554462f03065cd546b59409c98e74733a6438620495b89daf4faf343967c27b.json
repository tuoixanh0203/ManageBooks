{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeFields = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nconst directives_js_1 = require(\"./directives.js\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst arguments_js_1 = require(\"./arguments.js\");\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n  const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n  if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n    const t1 = (0, utils_js_1.extractType)(result.type);\n    const t2 = (0, utils_js_1.extractType)(otherField.type);\n    if (t1.name.value !== t2.name.value) {\n      throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n    }\n  }\n  return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n  const result = [];\n  if (f2 != null) {\n    result.push(...f2);\n  }\n  if (f1 != null) {\n    for (const field of f1) {\n      if (fieldAlreadyExists(result, field, config)) {\n        const existing = result.find(f => f.name.value === field.name.value);\n        if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n          if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n            preventConflicts(type, existing, field, false);\n          } else {\n            preventConflicts(type, existing, field, true);\n          }\n          if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {\n            existing.type = field.type;\n          }\n        }\n        existing.arguments = (0, arguments_js_1.mergeArguments)(field['arguments'] || [], existing.arguments || [], config);\n        existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config);\n        existing.description = field.description || existing.description;\n      } else {\n        result.push(field);\n      }\n    }\n  }\n  if (config && config.sort) {\n    result.sort(utils_1.compareNodes);\n  }\n  if (config && config.exclusions) {\n    const exclusions = config.exclusions;\n    return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n  }\n  return result;\n}\nexports.mergeFields = mergeFields;\nfunction preventConflicts(type, a, b) {\n  let ignoreNullability = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const aType = (0, utils_js_1.printTypeNode)(a.type);\n  const bType = (0, utils_js_1.printTypeNode)(b.type);\n  if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n    throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n  }\n}\nfunction safeChangeForFieldType(oldType, newType) {\n  let ignoreNullability = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // both are named\n  if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {\n    return oldType.toString() === newType.toString();\n  }\n  // new is non-null\n  if ((0, utils_js_1.isNonNullTypeNode)(newType)) {\n    const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;\n    return safeChangeForFieldType(ofType, newType.type);\n  }\n  // old is non-null\n  if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {\n    return safeChangeForFieldType(newType, oldType, ignoreNullability);\n  }\n  // old is list\n  if ((0, utils_js_1.isListTypeNode)(oldType)) {\n    return (0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type) || (0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType['type']);\n  }\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeFields","utils_js_1","require","directives_js_1","utils_1","arguments_js_1","fieldAlreadyExists","fieldsArr","otherField","config","result","find","field","name","ignoreFieldConflicts","t1","extractType","type","t2","Error","f1","f2","push","existing","f","throwOnConflict","preventConflicts","isNonNullTypeNode","arguments","mergeArguments","directives","mergeDirectives","description","sort","compareNodes","exclusions","filter","includes","a","b","ignoreNullability","aType","printTypeNode","bType","safeChangeForFieldType","oldType","newType","isWrappingTypeNode","toString","ofType","isListTypeNode"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/fields.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeFields = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nconst directives_js_1 = require(\"./directives.js\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst arguments_js_1 = require(\"./arguments.js\");\nfunction fieldAlreadyExists(fieldsArr, otherField, config) {\n    const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n    if (result && !(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n        const t1 = (0, utils_js_1.extractType)(result.type);\n        const t2 = (0, utils_js_1.extractType)(otherField.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n    }\n    return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n    const result = [];\n    if (f2 != null) {\n        result.push(...f2);\n    }\n    if (f1 != null) {\n        for (const field of f1) {\n            if (fieldAlreadyExists(result, field, config)) {\n                const existing = result.find((f) => f.name.value === field.name.value);\n                if (!(config === null || config === void 0 ? void 0 : config.ignoreFieldConflicts)) {\n                    if (config === null || config === void 0 ? void 0 : config.throwOnConflict) {\n                        preventConflicts(type, existing, field, false);\n                    }\n                    else {\n                        preventConflicts(type, existing, field, true);\n                    }\n                    if ((0, utils_js_1.isNonNullTypeNode)(field.type) && !(0, utils_js_1.isNonNullTypeNode)(existing.type)) {\n                        existing.type = field.type;\n                    }\n                }\n                existing.arguments = (0, arguments_js_1.mergeArguments)(field['arguments'] || [], existing.arguments || [], config);\n                existing.directives = (0, directives_js_1.mergeDirectives)(field.directives, existing.directives, config);\n                existing.description = field.description || existing.description;\n            }\n            else {\n                result.push(field);\n            }\n        }\n    }\n    if (config && config.sort) {\n        result.sort(utils_1.compareNodes);\n    }\n    if (config && config.exclusions) {\n        const exclusions = config.exclusions;\n        return result.filter(field => !exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nexports.mergeFields = mergeFields;\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = (0, utils_js_1.printTypeNode)(a.type);\n    const bType = (0, utils_js_1.printTypeNode)(b.type);\n    if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {\n        throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n    }\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!(0, utils_js_1.isWrappingTypeNode)(oldType) && !(0, utils_js_1.isWrappingTypeNode)(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if ((0, utils_js_1.isNonNullTypeNode)(newType)) {\n        const ofType = (0, utils_js_1.isNonNullTypeNode)(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if ((0, utils_js_1.isNonNullTypeNode)(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if ((0, utils_js_1.isListTypeNode)(oldType)) {\n        return (((0, utils_js_1.isListTypeNode)(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            ((0, utils_js_1.isNonNullTypeNode)(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}