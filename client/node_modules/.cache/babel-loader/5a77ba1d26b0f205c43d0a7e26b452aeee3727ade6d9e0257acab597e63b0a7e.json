{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CacheScope = void 0;\nvar CacheScope;\n(function (CacheScope) {\n  CacheScope[\"Public\"] = \"PUBLIC\";\n  CacheScope[\"Private\"] = \"PRIVATE\";\n})(CacheScope = exports.CacheScope || (exports.CacheScope = {}));","map":{"version":3,"mappings":";;;;;;AAmRA,IAAYA,UAGX;AAHD,WAAYA,UAAU;EACpBA,+BAAiB;EACjBA,iCAAmB;AACrB,CAAC,EAHWA,UAAU,GAAVC,kBAAU,KAAVA,kBAAU","names":["CacheScope","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-types\\src\\index.ts"],"sourcesContent":["import type { Request, Response } from 'apollo-server-env';\nimport type {\n  GraphQLSchema,\n  ValidationContext,\n  ASTVisitor,\n  GraphQLFormattedError,\n  OperationDefinitionNode,\n  DocumentNode,\n  GraphQLError,\n  GraphQLResolveInfo,\n  GraphQLCompositeType,\n} from 'graphql';\n\n// This seems like it could live in this package too.\nimport type { KeyValueCache } from '@apollo/utils.keyvaluecache';\nimport type { Trace } from 'apollo-reporting-protobuf';\nimport type { Logger } from '@apollo/utils.logger';\n\nexport type { Logger } from '@apollo/utils.logger';\nexport type BaseContext = Record<string, any>;\n\nexport type ValueOrPromise<T> = T | Promise<T>;\nexport type WithRequired<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\n/**\n * It is not recommended to use this `AnyFunction` type further.\n *\n * This is a legacy type which aims to do what its name suggests (be the type\n * for _any_ function) but it should be replaced with something from the\n * TypeScript standard lib.  It doesn't truly cover \"any\" function right now,\n * and in particular doesn't consider `this`.  For now, it has been brought\n * here from the Apollo Server `Dispatcher`, where it was first utilized.\n */\nexport type AnyFunction = (...args: any[]) => any;\n\n/**\n * A map of `AnyFunction`s which are the interface for our plugin API's\n * request listeners. (e.g. `GraphQLRequestListener`s).\n */\nexport type AnyFunctionMap = { [key: string]: AnyFunction | undefined };\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\n// By default, TypeScript uses structural typing (as opposed to nominal typing)\n// Put another way, if it looks like the type and walks like that type, then\n// TypeScript lets it be a type.\n//\n// That's often okay, but it leaves a lot to be desired since a `string` of one\n// type can just be passed in as `string` for that type and TypeScript won't\n// complain.  Flow offers opaque types which solve this, but TypeScript doesn't\n// offer this (yet?).  This Faux-paque type can be used to gain nominal-esque\n// typing, which is incredibly beneficial during re-factors!\ntype Fauxpaque<K, T> = K & { __fauxpaque: T };\n\nexport type SchemaHash = Fauxpaque<string, 'SchemaHash'>;\n\n// Configuration for how Apollo Server talks to the Apollo registry, as passed\n// to the ApolloServer constructor. Each field can also be provided as an\n// environment variable.\nexport interface ApolloConfigInput {\n  // Your Apollo API key. Environment variable: APOLLO_KEY.\n  key?: string;\n  // The graph ref for your graph, eg `my-graph@my-variant` or `my-graph` to use\n  // your graph's default variant. Environment variable: APOLLO_GRAPH_REF. For\n  // backwards compatibility, may alternatively specify the ref as graphId and\n  // graphVariant separately.\n  graphRef?: string;\n  // The graph ID of your graph, eg `my-graph`. Environment variable:\n  // APOLLO_GRAPH_ID.\n  graphId?: string;\n  // Your graph's variant name, eg `my-variant`. Environment variable:\n  // APOLLO_GRAPH_VARIANT.\n  graphVariant?: string;\n}\n\n// Configuration for how Apollo Server talks to the Apollo registry, with\n// some defaults filled in from the ApolloConfigInput passed to the constructor.\nexport interface ApolloConfig {\n  key?: string;\n  keyHash?: string;\n  graphRef?: string;\n}\n\nexport interface GraphQLServiceContext {\n  logger: Logger;\n  schema: GraphQLSchema;\n  /**\n   * @deprecated: a not particularly stable or useful hash of the schema.\n   */\n  schemaHash: SchemaHash;\n  apollo: ApolloConfig;\n  persistedQueries?: {\n    cache: KeyValueCache;\n  };\n  serverlessFramework: boolean;\n}\n\nexport interface GraphQLSchemaContext {\n  apiSchema: GraphQLSchema;\n  coreSupergraphSdl?: string;\n}\n\nexport interface GraphQLRequest {\n  query?: string;\n  operationName?: string;\n  variables?: VariableValues;\n  extensions?: Record<string, any>;\n  http?: Pick<Request, 'url' | 'method' | 'headers'>;\n}\n\nexport type VariableValues = { [name: string]: any };\n\nexport interface GraphQLResponse {\n  data?: Record<string, any> | null;\n  errors?: ReadonlyArray<GraphQLFormattedError>;\n  extensions?: Record<string, any>;\n  http?: Pick<Response, 'headers'> & Partial<Pick<Mutable<Response>, 'status'>>;\n}\n\nexport interface GraphQLRequestMetrics {\n  // It would be more accurate to call this fieldLevelInstrumentation (it is\n  // true if the hook of that name returns truthy) but for backwards\n  // compatibility we keep this name (this field is read by `@apollo/gateway` to\n  // decide whether or not to send the apollo-federation-include-trace header).\n  captureTraces?: boolean;\n  persistedQueryHit?: boolean;\n  persistedQueryRegister?: boolean;\n  responseCacheHit?: boolean;\n  forbiddenOperation?: boolean;\n  registeredOperation?: boolean;\n  startHrTime?: [number, number];\n  queryPlanTrace?: Trace.QueryPlanNode;\n}\n\nexport interface GraphQLRequestContext<TContext = Record<string, any>> {\n  readonly request: GraphQLRequest;\n  readonly response?: GraphQLResponse;\n\n  logger: Logger;\n\n  readonly schema: GraphQLSchema;\n  /**\n   * @deprecated: a not particularly stable or useful hash of the schema.\n   */\n  readonly schemaHash: SchemaHash;\n\n  readonly context: TContext;\n  readonly cache: KeyValueCache;\n\n  readonly queryHash?: string;\n\n  readonly document?: DocumentNode;\n  readonly source?: string;\n\n  // `operationName` is set based on the operation AST, so it is defined even if\n  // no `request.operationName` was passed in.  It will be set to `null` for an\n  // anonymous operation, or if `requestName.operationName` was passed in but\n  // doesn't resolve to an operation in the document.\n  readonly operationName?: string | null;\n  readonly operation?: OperationDefinitionNode;\n\n  /**\n   * Unformatted errors which have occurred during the request. Note that these\n   * are present earlier in the request pipeline and differ from **formatted**\n   * errors which are the result of running the user-configurable `formatError`\n   * transformation function over specific errors.\n   */\n  readonly errors?: ReadonlyArray<GraphQLError>;\n\n  readonly metrics: GraphQLRequestMetrics;\n\n  debug?: boolean;\n\n  readonly overallCachePolicy: CachePolicy;\n\n  /**\n   * True if this request is part of a potentially multi-operation batch. Note\n   * that if this is true, the headers and status code `response.http` will be\n   * be merged together; if two operations set the same header one will\n   * arbitrarily win. (In Apollo Server v4, `response.http` will be shared with\n   * the other operations in the batch.) This boolean is always set by Apollo\n   * Server v3.11.0+/v4.1.0+, but because this type is also part of the\n   * interface between older versions of `@apollo/gateway` and Apollo Server, we\n   * leave it optional here to avoid typechecking issues if the version of\n   * `apollo-server-types` transitively included by `@apollo/gateway` does not\n   * match the version of Apollo Server actually used.\n   */\n  readonly requestIsBatched?: boolean;\n}\n\nexport type ValidationRule = (context: ValidationContext) => ASTVisitor;\n\nexport type GraphQLExecutor<TContext = Record<string, any>> = (\n  requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n) => Promise<GraphQLExecutionResult>;\n\nexport type GraphQLExecutionResult = {\n  data?: Record<string, any> | null;\n  errors?: ReadonlyArray<GraphQLError>;\n  extensions?: Record<string, any>;\n};\n\n/**\n * This is an object form of the parameters received by typical\n * `graphql-js` resolvers.  The function type is `GraphQLFieldResolver`\n * and normally uses positional parameters.  In order to facilitate better\n * ergonomics in the Apollo Server plugin API, these have been converted to\n * named properties on the object using their names from the upstream\n * `GraphQLFieldResolver` type signature.  Ergonomic wins, in this case,\n * include not needing to have three unused variables in scope just because\n * there was a need to access the `info` property in a wrapped plugin.\n */\nexport type GraphQLFieldResolverParams<\n  TSource,\n  TContext,\n  TArgs = { [argName: string]: any },\n> = {\n  source: TSource;\n  args: TArgs;\n  context: TContext;\n  info: GraphQLResolveInfo;\n};\n\nexport type GraphQLRequestContextDidResolveSource<TContext> = WithRequired<\n  GraphQLRequestContext<TContext>,\n  'metrics' | 'source' | 'queryHash'\n>;\nexport type GraphQLRequestContextParsingDidStart<TContext> =\n  GraphQLRequestContextDidResolveSource<TContext>;\nexport type GraphQLRequestContextValidationDidStart<TContext> =\n  GraphQLRequestContextParsingDidStart<TContext> &\n    WithRequired<GraphQLRequestContext<TContext>, 'document'>;\nexport type GraphQLRequestContextDidResolveOperation<TContext> =\n  GraphQLRequestContextValidationDidStart<TContext> &\n    WithRequired<\n      GraphQLRequestContext<TContext>,\n      'operation' | 'operationName'\n    >;\nexport type GraphQLRequestContextDidEncounterErrors<TContext> = WithRequired<\n  GraphQLRequestContext<TContext>,\n  'metrics' | 'errors'\n>;\nexport type GraphQLRequestContextResponseForOperation<TContext> = WithRequired<\n  GraphQLRequestContext<TContext>,\n  'metrics' | 'source' | 'document' | 'operation' | 'operationName'\n>;\nexport type GraphQLRequestContextExecutionDidStart<TContext> =\n  GraphQLRequestContextParsingDidStart<TContext> &\n    WithRequired<\n      GraphQLRequestContext<TContext>,\n      'document' | 'operation' | 'operationName'\n    >;\nexport type GraphQLRequestContextWillSendResponse<TContext> =\n  GraphQLRequestContextDidResolveSource<TContext> &\n    WithRequired<GraphQLRequestContext<TContext>, 'metrics' | 'response'>;\n\n/**\n * CacheHint represents a contribution to an overall cache policy. It can\n * specify a maxAge and/or a scope.\n */\nexport interface CacheHint {\n  maxAge?: number;\n  scope?: CacheScope;\n}\n\n/**\n * CacheAnnotation represents the contents of a `@cacheControl` directive.\n * (`inheritMaxAge` is part of this interface and not CacheHint, because\n * `inheritMaxAge` isn't a contributing piece of a cache policy: it just means\n * to not apply default values in some contexts.)\n */\nexport interface CacheAnnotation extends CacheHint {\n  inheritMaxAge?: true;\n}\n\nexport enum CacheScope {\n  Public = 'PUBLIC',\n  Private = 'PRIVATE',\n}\n\n/**\n * CachePolicy is a mutable CacheHint with helpful methods for updating its\n * fields.\n */\nexport interface CachePolicy extends CacheHint {\n  /**\n   * Mutate this CachePolicy by replacing each field defined in `hint`. This can\n   * make the policy more restrictive or less restrictive.\n   */\n  replace(hint: CacheHint): void;\n\n  /**\n   * Mutate this CachePolicy by restricting each field defined in `hint`. This\n   * can only make the policy more restrictive: a previously defined `maxAge`\n   * can only be reduced, and a previously Private scope cannot be made Public.\n   */\n  restrict(hint: CacheHint): void;\n\n  /**\n   * If this policy has a positive `maxAge`, then return a copy of itself as a\n   * `CacheHint` with both fields defined. Otherwise return null.\n   */\n  policyIfCacheable(): Required<CacheHint> | null;\n}\n\n/**\n * When using Apollo Server with the cache control plugin (on by default), an\n * object of this kind is available to resolvers on `info.cacheControl`.\n */\nexport interface ResolveInfoCacheControl {\n  cacheHint: CachePolicy;\n  // Shorthand for `cacheHint.replace(hint)`; also for compatibility with\n  // the Apollo Server 2.x API.\n  setCacheHint(hint: CacheHint): void;\n\n  cacheHintFromType(t: GraphQLCompositeType): CacheHint | undefined;\n}\n\ndeclare module 'graphql/type/definition' {\n  interface GraphQLResolveInfo {\n    cacheControl: ResolveInfoCacheControl;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}