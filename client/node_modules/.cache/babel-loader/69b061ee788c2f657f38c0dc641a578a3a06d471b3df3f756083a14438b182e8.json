{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSome = exports.isSome = exports.compareNodes = exports.nodeToString = exports.compareStrings = exports.isValidPath = exports.isDocumentString = exports.asArray = void 0;\nconst graphql_1 = require(\"graphql\");\nconst asArray = fns => Array.isArray(fns) ? fns : fns ? [fns] : [];\nexports.asArray = asArray;\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\nfunction isDocumentString(str) {\n  if (typeof str !== 'string') {\n    return false;\n  }\n  // XXX: is-valid-path or is-glob treat SDL as a valid path\n  // (`scalar Date` for example)\n  // this why checking the extension is fast enough\n  // and prevent from parsing the string in order to find out\n  // if the string is a SDL\n  if (invalidDocRegex.test(str)) {\n    return false;\n  }\n  try {\n    (0, graphql_1.parse)(str);\n    return true;\n  } catch (e) {}\n  return false;\n}\nexports.isDocumentString = isDocumentString;\nconst invalidPathRegex = /[‘“!%^<=>`]/;\nfunction isValidPath(str) {\n  return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexports.isValidPath = isValidPath;\nfunction compareStrings(a, b) {\n  if (String(a) < String(b)) {\n    return -1;\n  }\n  if (String(a) > String(b)) {\n    return 1;\n  }\n  return 0;\n}\nexports.compareStrings = compareStrings;\nfunction nodeToString(a) {\n  var _a, _b;\n  let name;\n  if ('alias' in a) {\n    name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n  }\n  if (name == null && 'name' in a) {\n    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n  }\n  if (name == null) {\n    name = a.kind;\n  }\n  return name;\n}\nexports.nodeToString = nodeToString;\nfunction compareNodes(a, b, customFn) {\n  const aStr = nodeToString(a);\n  const bStr = nodeToString(b);\n  if (typeof customFn === 'function') {\n    return customFn(aStr, bStr);\n  }\n  return compareStrings(aStr, bStr);\n}\nexports.compareNodes = compareNodes;\nfunction isSome(input) {\n  return input != null;\n}\nexports.isSome = isSome;\nfunction assertSome(input) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Value should be something';\n  if (input == null) {\n    throw new Error(message);\n  }\n}\nexports.assertSome = assertSome;","map":{"version":3,"names":["Object","defineProperty","exports","value","assertSome","isSome","compareNodes","nodeToString","compareStrings","isValidPath","isDocumentString","asArray","graphql_1","require","fns","Array","isArray","invalidDocRegex","str","test","parse","e","invalidPathRegex","a","b","String","_a","_b","name","alias","kind","customFn","aStr","bStr","input","message","Error"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/helpers.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertSome = exports.isSome = exports.compareNodes = exports.nodeToString = exports.compareStrings = exports.isValidPath = exports.isDocumentString = exports.asArray = void 0;\nconst graphql_1 = require(\"graphql\");\nconst asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nexports.asArray = asArray;\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\nfunction isDocumentString(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (invalidDocRegex.test(str)) {\n        return false;\n    }\n    try {\n        (0, graphql_1.parse)(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nexports.isDocumentString = isDocumentString;\nconst invalidPathRegex = /[‘“!%^<=>`]/;\nfunction isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexports.isValidPath = isValidPath;\nfunction compareStrings(a, b) {\n    if (String(a) < String(b)) {\n        return -1;\n    }\n    if (String(a) > String(b)) {\n        return 1;\n    }\n    return 0;\n}\nexports.compareStrings = compareStrings;\nfunction nodeToString(a) {\n    var _a, _b;\n    let name;\n    if ('alias' in a) {\n        name = (_a = a.alias) === null || _a === void 0 ? void 0 : _a.value;\n    }\n    if (name == null && 'name' in a) {\n        name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;\n    }\n    if (name == null) {\n        name = a.kind;\n    }\n    return name;\n}\nexports.nodeToString = nodeToString;\nfunction compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\nexports.compareNodes = compareNodes;\nfunction isSome(input) {\n    return input != null;\n}\nexports.isSome = isSome;\nfunction assertSome(input, message = 'Value should be something') {\n    if (input == null) {\n        throw new Error(message);\n    }\n}\nexports.assertSome = assertSome;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}