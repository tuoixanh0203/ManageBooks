{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isImplicitlyInstallablePlugin = exports.ApolloServerBase = void 0;\nconst mock_1 = require(\"@graphql-tools/mock\");\nconst schema_1 = require(\"@graphql-tools/schema\");\nconst loglevel_1 = __importDefault(require(\"loglevel\"));\nconst graphql_1 = require(\"graphql\");\nconst resolvable_1 = __importDefault(require(\"@josephg/resolvable\"));\nconst utils_keyvaluecache_1 = require(\"@apollo/utils.keyvaluecache\");\nconst schemaHash_1 = require(\"./utils/schemaHash\");\nconst requestPipeline_1 = require(\"./requestPipeline\");\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst apollo_tools_1 = require(\"@apollographql/apollo-tools\");\nconst runHttpQuery_1 = require(\"./runHttpQuery\");\nconst isNodeLike_1 = __importDefault(require(\"./utils/isNodeLike\"));\nconst determineApolloConfig_1 = require(\"./determineApolloConfig\");\nconst plugin_1 = require(\"./plugin\");\nconst internalPlugin_1 = require(\"./internalPlugin\");\nconst cachePolicy_1 = require(\"./cachePolicy\");\nconst schemaManager_1 = require(\"./utils/schemaManager\");\nconst uuid = __importStar(require(\"uuid\"));\nconst UnboundedCache_1 = require(\"./utils/UnboundedCache\");\nconst NoIntrospection = context => ({\n  Field(node) {\n    if (node.name.value === '__schema' || node.name.value === '__type') {\n      context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', [node]));\n    }\n  }\n});\nclass UnreachableCaseError extends Error {\n  constructor(val) {\n    super(`Unreachable case: ${val}`);\n  }\n}\nconst recommendedCsrfPreventionRequestHeaders = ['x-apollo-operation-name', 'apollo-require-preflight'];\nclass ApolloServerBase {\n  constructor(config) {\n    var _a, _b;\n    this.graphqlPath = '/graphql';\n    this.requestOptions = Object.create(null);\n    this.plugins = [];\n    this.toDispose = new Set();\n    this.toDisposeLast = new Set();\n    this.drainServers = null;\n    this.landingPage = null;\n    if (!config) throw new Error('ApolloServer requires options.');\n    this.config = {\n      ...config,\n      nodeEnv: (_a = config.nodeEnv) !== null && _a !== void 0 ? _a : process.env.NODE_ENV\n    };\n    const {\n      context,\n      resolvers,\n      schema,\n      modules,\n      typeDefs,\n      parseOptions = {},\n      introspection,\n      plugins,\n      gateway,\n      apollo,\n      stopOnTerminationSignals,\n      mocks,\n      mockEntireSchema,\n      documentStore,\n      csrfPrevention,\n      ...requestOptions\n    } = this.config;\n    if (config.logger) {\n      this.logger = config.logger;\n    } else {\n      const loglevelLogger = loglevel_1.default.getLogger('apollo-server');\n      if (this.config.debug === true) {\n        loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);\n      } else {\n        loglevelLogger.setLevel(loglevel_1.default.levels.INFO);\n      }\n      this.logger = loglevelLogger;\n    }\n    this.apolloConfig = (0, determineApolloConfig_1.determineApolloConfig)(apollo);\n    if (gateway && (modules || schema || typeDefs || resolvers)) {\n      throw new Error('Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`');\n    }\n    this.parseOptions = parseOptions;\n    this.context = context;\n    this.csrfPreventionRequestHeaders = csrfPrevention === true ? recommendedCsrfPreventionRequestHeaders : csrfPrevention === false ? null : csrfPrevention === undefined ? null : (_b = csrfPrevention.requestHeaders) !== null && _b !== void 0 ? _b : recommendedCsrfPreventionRequestHeaders;\n    const isDev = this.config.nodeEnv !== 'production';\n    this.stopOnTerminationSignals = typeof stopOnTerminationSignals === 'boolean' ? stopOnTerminationSignals : isNodeLike_1.default && this.config.nodeEnv !== 'test' && !this.serverlessFramework();\n    if (typeof introspection === 'boolean' && !introspection || introspection === undefined && !isDev) {\n      const noIntro = [NoIntrospection];\n      requestOptions.validationRules = requestOptions.validationRules ? requestOptions.validationRules.concat(noIntro) : noIntro;\n    }\n    if (requestOptions.cache === 'bounded') {\n      requestOptions.cache = new utils_keyvaluecache_1.InMemoryLRUCache();\n    }\n    if (!requestOptions.cache) {\n      requestOptions.cache = new UnboundedCache_1.UnboundedCache();\n      if (!isDev && (requestOptions.persistedQueries === undefined || requestOptions.persistedQueries && !requestOptions.persistedQueries.cache)) {\n        this.logger.warn('Persisted queries are enabled and are using an unbounded cache. Your server' + ' is vulnerable to denial of service attacks via memory exhaustion. ' + 'Set `cache: \"bounded\"` or `persistedQueries: false` in your ApolloServer ' + 'constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.');\n      }\n    }\n    if (requestOptions.persistedQueries !== false) {\n      const {\n        cache: apqCache = requestOptions.cache,\n        ...apqOtherOptions\n      } = requestOptions.persistedQueries || Object.create(null);\n      requestOptions.persistedQueries = {\n        cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),\n        ...apqOtherOptions\n      };\n    } else {\n      delete requestOptions.persistedQueries;\n    }\n    this.requestOptions = requestOptions;\n    this.ensurePluginInstantiation(plugins, isDev);\n    if (gateway) {\n      this.state = {\n        phase: 'initialized',\n        schemaManager: new schemaManager_1.SchemaManager({\n          gateway,\n          apolloConfig: this.apolloConfig,\n          schemaDerivedDataProvider: schema => this.generateSchemaDerivedData(schema),\n          logger: this.logger\n        })\n      };\n    } else {\n      this.state = {\n        phase: 'initialized',\n        schemaManager: new schemaManager_1.SchemaManager({\n          apiSchema: this.maybeAddMocksToConstructedSchema(this.constructSchema()),\n          schemaDerivedDataProvider: schema => this.generateSchemaDerivedData(schema),\n          logger: this.logger\n        })\n      };\n    }\n    if (this.serverlessFramework()) {\n      this._start().catch(e => this.logStartupError(e));\n    }\n  }\n  async start() {\n    if (this.serverlessFramework()) {\n      throw new Error('When using an ApolloServer subclass from a serverless framework ' + \"package, you don't need to call start(); just call createHandler().\");\n    }\n    return await this._start();\n  }\n  async _start() {\n    var _a;\n    if (this.state.phase !== 'initialized') {\n      throw new Error(`called start() with surprising state ${this.state.phase}`);\n    }\n    const schemaManager = this.state.schemaManager;\n    const barrier = (0, resolvable_1.default)();\n    this.state = {\n      phase: 'starting',\n      barrier,\n      schemaManager\n    };\n    try {\n      const executor = await schemaManager.start();\n      this.toDispose.add(async () => {\n        await schemaManager.stop();\n      });\n      if (executor) {\n        this.requestOptions.executor = executor;\n      }\n      const schemaDerivedData = schemaManager.getSchemaDerivedData();\n      const service = {\n        logger: this.logger,\n        schema: schemaDerivedData.schema,\n        schemaHash: schemaDerivedData.schemaHash,\n        apollo: this.apolloConfig,\n        serverlessFramework: this.serverlessFramework()\n      };\n      if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {\n        service.persistedQueries = {\n          cache: this.requestOptions.persistedQueries.cache\n        };\n      }\n      const taggedServerListeners = (await Promise.all(this.plugins.map(async plugin => ({\n        serverListener: plugin.serverWillStart && (await plugin.serverWillStart(service)),\n        installedImplicitly: isImplicitlyInstallablePlugin(plugin) && plugin.__internal_installed_implicitly__\n      })))).filter(maybeTaggedServerListener => typeof maybeTaggedServerListener.serverListener === 'object');\n      taggedServerListeners.forEach(_ref => {\n        let {\n          serverListener: {\n            schemaDidLoadOrUpdate\n          }\n        } = _ref;\n        if (schemaDidLoadOrUpdate) {\n          try {\n            schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);\n          } catch (e) {\n            if (e instanceof schemaManager_1.GatewayIsTooOldError) {\n              throw new Error([`One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`, `but your gateway version is too old to support this hook.`, `Please update your version of @apollo/gateway to at least 0.35.0.`].join(' '));\n            }\n            throw e;\n          }\n        }\n      });\n      const serverWillStops = taggedServerListeners.flatMap(l => l.serverListener.serverWillStop ? [l.serverListener.serverWillStop] : []);\n      if (serverWillStops.length) {\n        this.toDispose.add(async () => {\n          await Promise.all(serverWillStops.map(serverWillStop => serverWillStop()));\n        });\n      }\n      const drainServerCallbacks = taggedServerListeners.flatMap(l => l.serverListener.drainServer ? [l.serverListener.drainServer] : []);\n      if (drainServerCallbacks.length) {\n        this.drainServers = async () => {\n          await Promise.all(drainServerCallbacks.map(drainServer => drainServer()));\n        };\n      }\n      let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter(l => l.serverListener.renderLandingPage);\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        taggedServerListenersWithRenderLandingPage = taggedServerListenersWithRenderLandingPage.filter(l => !l.installedImplicitly);\n      }\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        throw Error('Only one plugin can implement renderLandingPage.');\n      } else if (taggedServerListenersWithRenderLandingPage.length) {\n        this.landingPage = await taggedServerListenersWithRenderLandingPage[0].serverListener.renderLandingPage();\n      } else {\n        this.landingPage = null;\n      }\n      this.state = {\n        phase: 'started',\n        schemaManager\n      };\n      this.maybeRegisterTerminationSignalHandlers(['SIGINT', 'SIGTERM']);\n    } catch (error) {\n      this.state = {\n        phase: 'failed to start',\n        error: error\n      };\n      throw error;\n    } finally {\n      barrier.resolve();\n    }\n  }\n  maybeRegisterTerminationSignalHandlers(signals) {\n    if (!this.stopOnTerminationSignals) {\n      return;\n    }\n    let receivedSignal = false;\n    const signalHandler = async signal => {\n      if (receivedSignal) {\n        return;\n      }\n      receivedSignal = true;\n      try {\n        await this.stop();\n      } catch (e) {\n        this.logger.error(`stop() threw during ${signal} shutdown`);\n        this.logger.error(e);\n        process.exit(1);\n      }\n      process.kill(process.pid, signal);\n    };\n    signals.forEach(signal => {\n      process.on(signal, signalHandler);\n      this.toDisposeLast.add(async () => {\n        process.removeListener(signal, signalHandler);\n      });\n    });\n  }\n  async _ensureStarted() {\n    while (true) {\n      switch (this.state.phase) {\n        case 'initialized':\n          throw new Error('You need to call `server.start()` before using your Apollo Server.');\n        case 'starting':\n          await this.state.barrier;\n          break;\n        case 'failed to start':\n          this.logStartupError(this.state.error);\n          throw new Error('This data graph is missing a valid configuration. More details may be available in the server logs.');\n        case 'started':\n        case 'draining':\n          return this.state.schemaManager.getSchemaDerivedData();\n        case 'stopping':\n          throw new Error('Cannot execute GraphQL operations while the server is stopping.');\n        case 'stopped':\n          throw new Error('Cannot execute GraphQL operations after the server has stopped.');\n        default:\n          throw new UnreachableCaseError(this.state);\n      }\n    }\n  }\n  async ensureStarted() {\n    await this._ensureStarted();\n  }\n  assertStarted(methodName) {\n    if (this.state.phase !== 'started' && this.state.phase !== 'draining') {\n      throw new Error('You must `await server.start()` before calling `server.' + methodName + '()`');\n    }\n  }\n  logStartupError(err) {\n    this.logger.error('An error occurred during Apollo Server startup. All GraphQL requests ' + 'will now fail. The startup error was: ' + ((err === null || err === void 0 ? void 0 : err.message) || err));\n  }\n  constructSchema() {\n    const {\n      schema,\n      modules,\n      typeDefs,\n      resolvers,\n      parseOptions\n    } = this.config;\n    if (schema) {\n      return schema;\n    }\n    if (modules) {\n      const {\n        schema,\n        errors\n      } = (0, apollo_tools_1.buildServiceDefinition)(modules);\n      if (errors && errors.length > 0) {\n        throw new Error(errors.map(error => error.message).join('\\n\\n'));\n      }\n      return schema;\n    }\n    if (!typeDefs) {\n      throw Error('Apollo Server requires either an existing schema, modules or typeDefs');\n    }\n    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n    return (0, schema_1.makeExecutableSchema)({\n      typeDefs: augmentedTypeDefs,\n      resolvers,\n      parseOptions\n    });\n  }\n  maybeAddMocksToConstructedSchema(schema) {\n    const {\n      mocks,\n      mockEntireSchema\n    } = this.config;\n    if (mocks === false) {\n      return schema;\n    }\n    if (!mocks && typeof mockEntireSchema === 'undefined') {\n      return schema;\n    }\n    return (0, mock_1.addMocksToSchema)({\n      schema,\n      mocks: mocks === true || typeof mocks === 'undefined' ? {} : mocks,\n      preserveResolvers: typeof mockEntireSchema === 'undefined' ? false : !mockEntireSchema\n    });\n  }\n  generateSchemaDerivedData(schema) {\n    const schemaHash = (0, schemaHash_1.generateSchemaHash)(schema);\n    return {\n      schema,\n      schemaHash,\n      documentStore: this.config.documentStore === undefined ? new utils_keyvaluecache_1.InMemoryLRUCache() : this.config.documentStore === null ? null : new utils_keyvaluecache_1.PrefixingKeyValueCache(this.config.documentStore, `${uuid.v4()}:`)\n    };\n  }\n  async stop() {\n    var _a;\n    switch (this.state.phase) {\n      case 'initialized':\n      case 'starting':\n      case 'failed to start':\n        throw Error('apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded');\n      case 'stopped':\n        if (this.state.stopError) {\n          throw this.state.stopError;\n        }\n        return;\n      case 'stopping':\n      case 'draining':\n        {\n          await this.state.barrier;\n          const state = this.state;\n          if (state.phase !== 'stopped') {\n            throw Error(`Surprising post-stopping state ${state.phase}`);\n          }\n          if (state.stopError) {\n            throw state.stopError;\n          }\n          return;\n        }\n      case 'started':\n        break;\n      default:\n        throw new UnreachableCaseError(this.state);\n    }\n    const barrier = (0, resolvable_1.default)();\n    this.state = {\n      phase: 'draining',\n      schemaManager: this.state.schemaManager,\n      barrier\n    };\n    try {\n      await ((_a = this.drainServers) === null || _a === void 0 ? void 0 : _a.call(this));\n      this.state = {\n        phase: 'stopping',\n        barrier\n      };\n      await Promise.all([...this.toDispose].map(dispose => dispose()));\n      await Promise.all([...this.toDisposeLast].map(dispose => dispose()));\n    } catch (stopError) {\n      this.state = {\n        phase: 'stopped',\n        stopError: stopError\n      };\n      barrier.resolve();\n      throw stopError;\n    }\n    this.state = {\n      phase: 'stopped',\n      stopError: null\n    };\n  }\n  serverlessFramework() {\n    return false;\n  }\n  ensurePluginInstantiation() {\n    let userPlugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let isDev = arguments.length > 1 ? arguments[1] : undefined;\n    this.plugins = userPlugins.map(plugin => {\n      if (typeof plugin === 'function') {\n        return plugin();\n      }\n      return plugin;\n    });\n    const alreadyHavePluginWithInternalId = id => this.plugins.some(p => (0, internalPlugin_1.pluginIsInternal)(p) && p.__internal_plugin_id__() === id);\n    {\n      if (!alreadyHavePluginWithInternalId('CacheControl')) {\n        this.plugins.push((0, plugin_1.ApolloServerPluginCacheControl)());\n      }\n    }\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('UsageReporting');\n      if (!alreadyHavePlugin && this.apolloConfig.key) {\n        if (this.apolloConfig.graphRef) {\n          this.plugins.unshift((0, plugin_1.ApolloServerPluginUsageReporting)());\n        } else {\n          this.logger.warn('You have specified an Apollo key but have not specified a graph ref; usage ' + 'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' + 'environment variable to `your-graph-id@your-graph-variant`. To disable this ' + 'warning, install `ApolloServerPluginUsageReportingDisabled`.');\n        }\n      }\n    }\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('SchemaReporting');\n      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';\n      if (!alreadyHavePlugin && enabledViaEnvVar) {\n        if (this.apolloConfig.key) {\n          const options = {};\n          this.plugins.push((0, plugin_1.ApolloServerPluginSchemaReporting)(options));\n        } else {\n          throw new Error(\"You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING \" + 'environment variable to true, but you also need to provide your ' + 'Apollo API key, via the APOLLO_KEY environment ' + 'variable or via `new ApolloServer({apollo: {key})');\n        }\n      }\n    }\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');\n      if (!alreadyHavePlugin) {\n        this.plugins.push((0, plugin_1.ApolloServerPluginInlineTrace)({\n          __onlyIfSchemaIsFederated: true\n        }));\n      }\n    }\n    const alreadyHavePlugin = alreadyHavePluginWithInternalId('LandingPageDisabled');\n    if (!alreadyHavePlugin) {\n      const plugin = isDev ? (0, plugin_1.ApolloServerPluginLandingPageLocalDefault)() : (0, plugin_1.ApolloServerPluginLandingPageProductionDefault)();\n      if (!isImplicitlyInstallablePlugin(plugin)) {\n        throw Error('default landing page plugin should be implicitly installable?');\n      }\n      plugin.__internal_installed_implicitly__ = true;\n      this.plugins.push(plugin);\n    }\n  }\n  async graphQLServerOptions(integrationContextArgument) {\n    const {\n      schema,\n      schemaHash,\n      documentStore\n    } = await this._ensureStarted();\n    let context = this.context ? this.context : {};\n    try {\n      context = typeof this.context === 'function' ? await this.context(integrationContextArgument || {}) : context;\n    } catch (error) {\n      context = () => {\n        throw error;\n      };\n    }\n    return {\n      schema,\n      schemaHash,\n      logger: this.logger,\n      plugins: this.plugins,\n      documentStore,\n      context,\n      parseOptions: this.parseOptions,\n      ...this.requestOptions\n    };\n  }\n  async executeOperation(request, integrationContextArgument) {\n    if (this.state.phase === 'initialized') {\n      await this._start();\n    }\n    const options = await this.graphQLServerOptions(integrationContextArgument);\n    if (typeof options.context === 'function') {\n      options.context = options.context();\n    } else if (typeof options.context === 'object') {\n      options.context = (0, runHttpQuery_1.cloneObject)(options.context);\n    }\n    const requestCtx = {\n      logger: this.logger,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request: {\n        ...request,\n        query: request.query && typeof request.query !== 'string' ? (0, graphql_1.print)(request.query) : request.query\n      },\n      context: options.context || Object.create(null),\n      cache: options.cache,\n      metrics: {},\n      response: {\n        http: {\n          headers: new apollo_server_env_1.Headers()\n        }\n      },\n      debug: options.debug,\n      overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),\n      requestIsBatched: false\n    };\n    return (0, requestPipeline_1.processGraphQLRequest)(options, requestCtx);\n  }\n  getLandingPage() {\n    this.assertStarted('getLandingPage');\n    return this.landingPage;\n  }\n}\nexports.ApolloServerBase = ApolloServerBase;\nfunction isImplicitlyInstallablePlugin(p) {\n  return '__internal_installed_implicitly__' in p;\n}\nexports.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;","map":{"version":3,"mappings":"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","names":["NoIntrospection","context","Field","node","name","value","reportError","graphql_1","UnreachableCaseError","Error","constructor","val","recommendedCsrfPreventionRequestHeaders","ApolloServerBase","config","Object","create","Set","nodeEnv","process","env","NODE_ENV","resolvers","schema","modules","typeDefs","parseOptions","introspection","plugins","gateway","apollo","stopOnTerminationSignals","mocks","mockEntireSchema","documentStore","csrfPrevention","requestOptions","logger","loglevelLogger","loglevel_1","getLogger","debug","setLevel","levels","DEBUG","INFO","apolloConfig","csrfPreventionRequestHeaders","undefined","requestHeaders","isDev","isNodeLike_1","serverlessFramework","noIntro","validationRules","concat","cache","utils_keyvaluecache_1","UnboundedCache_1","persistedQueries","warn","apqCache","apqOtherOptions","requestPipeline_1","ensurePluginInstantiation","state","phase","schemaManager","schemaManager_1","schemaDerivedDataProvider","generateSchemaDerivedData","apiSchema","maybeAddMocksToConstructedSchema","constructSchema","_start","catch","e","logStartupError","start","barrier","executor","toDispose","add","stop","schemaDerivedData","getSchemaDerivedData","service","schemaHash","taggedServerListeners","Promise","all","map","plugin","serverListener","serverWillStart","installedImplicitly","isImplicitlyInstallablePlugin","__internal_installed_implicitly__","filter","maybeTaggedServerListener","forEach","schemaDidLoadOrUpdate","onSchemaLoadOrUpdate","join","serverWillStops","flatMap","l","serverWillStop","length","drainServerCallbacks","drainServer","drainServers","taggedServerListenersWithRenderLandingPage","renderLandingPage","landingPage","maybeRegisterTerminationSignalHandlers","error","resolve","signals","receivedSignal","signalHandler","signal","exit","kill","pid","on","toDisposeLast","removeListener","_ensureStarted","ensureStarted","assertStarted","methodName","err","message","errors","augmentedTypeDefs","Array","isArray","preserveResolvers","uuid","v4","stopError","dispose","userPlugins","alreadyHavePluginWithInternalId","id","some","p","__internal_plugin_id__","push","alreadyHavePlugin","key","graphRef","unshift","enabledViaEnvVar","APOLLO_SCHEMA_REPORTING","options","__onlyIfSchemaIsFederated","graphQLServerOptions","integrationContextArgument","executeOperation","request","requestCtx","query","metrics","response","http","headers","apollo_server_env_1","overallCachePolicy","requestIsBatched","getLandingPage","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\ApolloServer.ts"],"sourcesContent":["import { addMocksToSchema } from '@graphql-tools/mock';\nimport { makeExecutableSchema } from '@graphql-tools/schema';\nimport loglevel from 'loglevel';\nimport {\n  GraphQLSchema,\n  GraphQLError,\n  ValidationContext,\n  FieldDefinitionNode,\n  DocumentNode,\n  ParseOptions,\n  print,\n} from 'graphql';\nimport resolvable, { Resolvable } from '@josephg/resolvable';\nimport {\n  InMemoryLRUCache,\n  PrefixingKeyValueCache,\n} from '@apollo/utils.keyvaluecache';\nimport type {\n  ApolloServerPlugin,\n  GraphQLServiceContext,\n  GraphQLServerListener,\n  LandingPage,\n} from 'apollo-server-plugin-base';\n\nimport type { GraphQLServerOptions } from './graphqlOptions';\n\nimport type {\n  Config,\n  Context,\n  ContextFunction,\n  DocumentStore,\n  PluginDefinition,\n} from './types';\n\nimport { generateSchemaHash } from './utils/schemaHash';\nimport {\n  processGraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLRequest,\n  APQ_CACHE_PREFIX,\n} from './requestPipeline';\n\nimport { Headers } from 'apollo-server-env';\nimport { buildServiceDefinition } from '@apollographql/apollo-tools';\nimport type { SchemaHash, ApolloConfig } from 'apollo-server-types';\nimport type { Logger } from '@apollo/utils.logger';\nimport { cloneObject } from './runHttpQuery';\nimport isNodeLike from './utils/isNodeLike';\nimport { determineApolloConfig } from './determineApolloConfig';\nimport {\n  ApolloServerPluginSchemaReporting,\n  ApolloServerPluginSchemaReportingOptions,\n  ApolloServerPluginInlineTrace,\n  ApolloServerPluginUsageReporting,\n  ApolloServerPluginCacheControl,\n  ApolloServerPluginLandingPageLocalDefault,\n  ApolloServerPluginLandingPageProductionDefault,\n} from './plugin';\nimport { InternalPluginId, pluginIsInternal } from './internalPlugin';\nimport { newCachePolicy } from './cachePolicy';\nimport { GatewayIsTooOldError, SchemaManager } from './utils/schemaManager';\nimport * as uuid from 'uuid';\nimport { UnboundedCache } from './utils/UnboundedCache';\n\nconst NoIntrospection = (context: ValidationContext) => ({\n  Field(node: FieldDefinitionNode) {\n    if (node.name.value === '__schema' || node.name.value === '__type') {\n      context.reportError(\n        new GraphQLError(\n          'GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production',\n          [node],\n        ),\n      );\n    }\n  },\n});\n\nexport type SchemaDerivedData = {\n  schema: GraphQLSchema;\n  // Not a very useful schema hash (not the same one schema and usage reporting\n  // use!) but kept around for backwards compatibility.\n  schemaHash: SchemaHash;\n  // A store that, when enabled (default), will store the parsed and validated\n  // versions of operations in-memory, allowing subsequent parses/validates\n  // on the same operation to be executed immediately.\n  documentStore: DocumentStore | null;\n};\n\ntype ServerState =\n  | {\n      phase: 'initialized';\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'starting';\n      barrier: Resolvable<void>;\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'failed to start';\n      error: Error;\n    }\n  | {\n      phase: 'started';\n      schemaManager: SchemaManager;\n    }\n  | {\n      phase: 'draining';\n      schemaManager: SchemaManager;\n      barrier: Resolvable<void>;\n    }\n  | {\n      phase: 'stopping';\n      barrier: Resolvable<void>;\n    }\n  | {\n      phase: 'stopped';\n      stopError: Error | null;\n    };\n\n// Throw this in places that should be unreachable (because all other cases have\n// been handled, reducing the type of the argument to `never`). TypeScript will\n// complain if in fact there is a valid type for the argument.\nclass UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`);\n  }\n}\n\n// Our recommended set of CSRF prevention headers. Operations that do not\n// provide a content-type such as `application/json` (in practice, this\n// means GET operations) must include at least one of these headers.\n// Apollo Client Web's default behavior is to always sends a\n// `content-type` even for `GET`, and Apollo iOS and Apollo Kotlin always\n// send `x-apollo-operation-name`. So if you set\n// `csrfPreventionRequestHeaders: true` then any `GET` operation from these\n// three client projects and any `POST` operation at all should work\n// successfully; if you need `GET`s from another kind of client to work,\n// just add `apollo-require-preflight: true` to their requests.\nconst recommendedCsrfPreventionRequestHeaders = [\n  'x-apollo-operation-name',\n  'apollo-require-preflight',\n];\n\nexport class ApolloServerBase<\n  // The type of the argument to the `context` function for this integration.\n  ContextFunctionParams = any,\n> {\n  private logger: Logger;\n  public graphqlPath: string = '/graphql';\n  public requestOptions: Partial<GraphQLServerOptions<any>> =\n    Object.create(null);\n\n  private context?: Context | ContextFunction<ContextFunctionParams>;\n  private apolloConfig: ApolloConfig;\n  protected plugins: ApolloServerPlugin[] = [];\n  protected csrfPreventionRequestHeaders: string[] | null;\n\n  private parseOptions: ParseOptions;\n  private config: Config<ContextFunctionParams>;\n  private state: ServerState;\n  private toDispose = new Set<() => Promise<void>>();\n  private toDisposeLast = new Set<() => Promise<void>>();\n  private drainServers: (() => Promise<void>) | null = null;\n  private stopOnTerminationSignals: boolean;\n  private landingPage: LandingPage | null = null;\n\n  // The constructor should be universal across all environments. All environment specific behavior should be set by adding or overriding methods\n  constructor(config: Config<ContextFunctionParams>) {\n    if (!config) throw new Error('ApolloServer requires options.');\n    this.config = {\n      ...config,\n      nodeEnv: config.nodeEnv ?? process.env.NODE_ENV,\n    };\n    const {\n      context,\n      resolvers,\n      schema,\n      modules,\n      typeDefs,\n      parseOptions = {},\n      introspection,\n      plugins,\n      gateway,\n      apollo,\n      stopOnTerminationSignals,\n      // These next options aren't used in this function but they don't belong in\n      // requestOptions.\n      mocks,\n      mockEntireSchema,\n      documentStore,\n      csrfPrevention,\n      ...requestOptions\n    } = this.config;\n\n    // Setup logging facilities\n    if (config.logger) {\n      this.logger = config.logger;\n    } else {\n      // If the user didn't provide their own logger, we'll initialize one.\n      const loglevelLogger = loglevel.getLogger('apollo-server');\n\n      // We don't do much logging in Apollo Server right now.  There's a notion\n      // of a `debug` flag, which changes stack traces in some error messages,\n      // and adds a bit of debug logging to some plugins. `info` is primarily\n      // used for startup logging in plugins. We'll default to `info` so you\n      // get to see that startup logging.\n      if (this.config.debug === true) {\n        loglevelLogger.setLevel(loglevel.levels.DEBUG);\n      } else {\n        loglevelLogger.setLevel(loglevel.levels.INFO);\n      }\n\n      this.logger = loglevelLogger;\n    }\n\n    this.apolloConfig = determineApolloConfig(apollo);\n\n    if (gateway && (modules || schema || typeDefs || resolvers)) {\n      throw new Error(\n        'Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`',\n      );\n    }\n\n    this.parseOptions = parseOptions;\n    this.context = context;\n\n    this.csrfPreventionRequestHeaders =\n      csrfPrevention === true\n        ? recommendedCsrfPreventionRequestHeaders\n        : csrfPrevention === false\n        ? null\n        : csrfPrevention === undefined\n        ? null // In AS4, change this to be equivalent to 'true'.\n        : csrfPrevention.requestHeaders ??\n          recommendedCsrfPreventionRequestHeaders;\n\n    const isDev = this.config.nodeEnv !== 'production';\n\n    // We handle signals if it was explicitly requested, or if we're in Node,\n    // not in a test, not in a serverless framework, and it wasn't explicitly\n    // turned off. (We only actually register the signal handlers once we've\n    // successfully started up, because there's nothing to stop otherwise.)\n    this.stopOnTerminationSignals =\n      typeof stopOnTerminationSignals === 'boolean'\n        ? stopOnTerminationSignals\n        : isNodeLike &&\n          this.config.nodeEnv !== 'test' &&\n          !this.serverlessFramework();\n\n    // if this is local dev, introspection should turned on\n    // in production, we can manually turn introspection on by passing {\n    // introspection: true } to the constructor of ApolloServer\n    if (\n      (typeof introspection === 'boolean' && !introspection) ||\n      (introspection === undefined && !isDev)\n    ) {\n      const noIntro = [NoIntrospection];\n      requestOptions.validationRules = requestOptions.validationRules\n        ? requestOptions.validationRules.concat(noIntro)\n        : noIntro;\n    }\n\n    if (requestOptions.cache === 'bounded') {\n      requestOptions.cache = new InMemoryLRUCache();\n    }\n\n    if (!requestOptions.cache) {\n      requestOptions.cache = new UnboundedCache();\n\n      if (\n        !isDev &&\n        (requestOptions.persistedQueries === undefined ||\n          (requestOptions.persistedQueries &&\n            !requestOptions.persistedQueries.cache))\n      ) {\n        this.logger.warn(\n          'Persisted queries are enabled and are using an unbounded cache. Your server' +\n            ' is vulnerable to denial of service attacks via memory exhaustion. ' +\n            'Set `cache: \"bounded\"` or `persistedQueries: false` in your ApolloServer ' +\n            'constructor, or see https://go.apollo.dev/s/cache-backends for other alternatives.',\n        );\n      }\n    }\n\n    if (requestOptions.persistedQueries !== false) {\n      const { cache: apqCache = requestOptions.cache!, ...apqOtherOptions } =\n        requestOptions.persistedQueries || Object.create(null);\n\n      requestOptions.persistedQueries = {\n        cache: new PrefixingKeyValueCache(apqCache, APQ_CACHE_PREFIX),\n        ...apqOtherOptions,\n      };\n    } else {\n      // the user does not want to use persisted queries, so we remove the field\n      delete requestOptions.persistedQueries;\n    }\n\n    this.requestOptions = requestOptions as GraphQLServerOptions;\n\n    // Plugins will be instantiated if they aren't already, and this.plugins\n    // is populated accordingly.\n    this.ensurePluginInstantiation(plugins, isDev);\n\n    if (gateway) {\n      // ApolloServer has been initialized but we have not yet tried to load the\n      // schema from the gateway. That will wait until the user calls\n      // `server.start()` or `server.listen()`, or (in serverless frameworks)\n      // until the `this._start()` call at the end of this constructor.\n      this.state = {\n        phase: 'initialized',\n        schemaManager: new SchemaManager({\n          gateway,\n          apolloConfig: this.apolloConfig,\n          schemaDerivedDataProvider: (schema) =>\n            this.generateSchemaDerivedData(schema),\n          logger: this.logger,\n        }),\n      };\n    } else {\n      // We construct the schema synchronously so that we can fail fast if the\n      // schema can't be constructed. (This used to be more important because we\n      // used to have a 'schema' field that was publicly accessible immediately\n      // after construction, though that field never actually worked with\n      // gateways.)\n      this.state = {\n        phase: 'initialized',\n        schemaManager: new SchemaManager({\n          apiSchema: this.maybeAddMocksToConstructedSchema(\n            this.constructSchema(),\n          ),\n          schemaDerivedDataProvider: (schema) =>\n            this.generateSchemaDerivedData(schema),\n          logger: this.logger,\n        }),\n      };\n    }\n\n    // The main entry point (createHandler) to serverless frameworks generally\n    // needs to be called synchronously from the top level of your entry point,\n    // unlike (eg) applyMiddleware, so we can't expect you to `await\n    // server.start()` before calling it. So we kick off the start\n    // asynchronously from the constructor, and failures are logged and cause\n    // later requests to fail (in `_ensureStarted`, called by\n    // `graphQLServerOptions` and from the serverless framework handlers).\n    // There's no way to make \"the whole server fail\" separately from making\n    // individual requests fail, but that's not entirely unreasonable for a\n    // \"serverless\" model.\n    if (this.serverlessFramework()) {\n      this._start().catch((e) => this.logStartupError(e));\n    }\n  }\n\n  // Awaiting a call to `start` ensures that a schema has been loaded and that\n  // all plugin `serverWillStart` hooks have been called. If either of these\n  // processes throw, `start` will (async) throw as well.\n  //\n  // If you're using the batteries-included `apollo-server` package, you don't\n  // need to call `start` yourself (in fact, it will throw if you do so); its\n  // `listen` method takes care of that for you (this is why the actual logic is\n  // in the `_start` helper).\n  //\n  // If instead you're using an integration package for a non-serverless\n  // framework (like Express), you must await a call to `start` immediately\n  // after creating your `ApolloServer`, before attaching it to your web\n  // framework and starting to accept requests. `start` should only be called\n  // once; if it throws and you'd like to retry, just create another\n  // `ApolloServer`. (Calling `start` was optional in Apollo Server 2, but in\n  // Apollo Server 3 the methods like `server.applyMiddleware` use\n  // `assertStarted` to throw if `start` hasn't successfully completed.)\n  //\n  // Serverless integrations like Lambda (which override `serverlessFramework()`\n  // to return true) do not support calling `start()`, because their lifecycle\n  // doesn't allow you to wait before assigning a handler or allowing the\n  // handler to be called. So they call `_start()` at the end of the\n  // constructor, and don't really differentiate between startup failures and\n  // request failures. This is hopefully appropriate for a \"serverless\"\n  // framework. Serverless startup failures result in returning a redacted error\n  // to the end user and logging the more detailed error.\n  public async start(): Promise<void> {\n    if (this.serverlessFramework()) {\n      throw new Error(\n        'When using an ApolloServer subclass from a serverless framework ' +\n          \"package, you don't need to call start(); just call createHandler().\",\n      );\n    }\n\n    return await this._start();\n  }\n\n  // This is protected so that it can be called from `apollo-server`. It is\n  // otherwise an internal implementation detail.\n  protected async _start(): Promise<void> {\n    if (this.state.phase !== 'initialized') {\n      throw new Error(\n        `called start() with surprising state ${this.state.phase}`,\n      );\n    }\n    const schemaManager = this.state.schemaManager;\n    const barrier = resolvable();\n    this.state = {\n      phase: 'starting',\n      barrier,\n      schemaManager,\n    };\n    try {\n      const executor = await schemaManager.start();\n      this.toDispose.add(async () => {\n        await schemaManager.stop();\n      });\n      if (executor) {\n        // If we loaded an executor from a gateway, use it to execute\n        // operations.\n        this.requestOptions.executor = executor;\n      }\n\n      const schemaDerivedData = schemaManager.getSchemaDerivedData();\n      const service: GraphQLServiceContext = {\n        logger: this.logger,\n        schema: schemaDerivedData.schema,\n        schemaHash: schemaDerivedData.schemaHash,\n        apollo: this.apolloConfig,\n        serverlessFramework: this.serverlessFramework(),\n      };\n\n      // The `persistedQueries` attribute on the GraphQLServiceContext was\n      // originally used by the operation registry, which shared the cache with\n      // it.  This is no longer the case.  However, while we are continuing to\n      // expand the support of the interface for `persistedQueries`, e.g. with\n      // additions like https://github.com/apollographql/apollo-server/pull/3623,\n      // we don't want to continually expand the API surface of what we expose\n      // to the plugin API.   In this particular case, it certainly doesn't need\n      // to get the `ttl` default value which are intended for APQ only.\n      if (this.requestOptions.persistedQueries?.cache) {\n        service.persistedQueries = {\n          cache: this.requestOptions.persistedQueries.cache,\n        };\n      }\n\n      const taggedServerListeners = (\n        await Promise.all(\n          this.plugins.map(async (plugin) => ({\n            serverListener:\n              plugin.serverWillStart && (await plugin.serverWillStart(service)),\n            installedImplicitly:\n              isImplicitlyInstallablePlugin(plugin) &&\n              plugin.__internal_installed_implicitly__,\n          })),\n        )\n      ).filter(\n        (\n          maybeTaggedServerListener,\n        ): maybeTaggedServerListener is {\n          serverListener: GraphQLServerListener;\n          installedImplicitly: boolean;\n        } => typeof maybeTaggedServerListener.serverListener === 'object',\n      );\n\n      taggedServerListeners.forEach(\n        ({ serverListener: { schemaDidLoadOrUpdate } }) => {\n          if (schemaDidLoadOrUpdate) {\n            try {\n              schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);\n            } catch (e) {\n              if (e instanceof GatewayIsTooOldError) {\n                throw new Error(\n                  [\n                    `One of your plugins uses the 'schemaDidLoadOrUpdate' hook,`,\n                    `but your gateway version is too old to support this hook.`,\n                    `Please update your version of @apollo/gateway to at least 0.35.0.`,\n                  ].join(' '),\n                );\n              }\n              throw e;\n            }\n          }\n        },\n      );\n\n      const serverWillStops = taggedServerListeners.flatMap((l) =>\n        l.serverListener.serverWillStop\n          ? [l.serverListener.serverWillStop]\n          : [],\n      );\n      if (serverWillStops.length) {\n        this.toDispose.add(async () => {\n          await Promise.all(\n            serverWillStops.map((serverWillStop) => serverWillStop()),\n          );\n        });\n      }\n\n      const drainServerCallbacks = taggedServerListeners.flatMap((l) =>\n        l.serverListener.drainServer ? [l.serverListener.drainServer] : [],\n      );\n      if (drainServerCallbacks.length) {\n        this.drainServers = async () => {\n          await Promise.all(\n            drainServerCallbacks.map((drainServer) => drainServer()),\n          );\n        };\n      }\n\n      // Find the renderLandingPage callback, if one is provided. If the user\n      // installed ApolloServerPluginLandingPageDisabled then there may be none\n      // found. On the other hand, if the user installed a landingPage plugin,\n      // then both the implicit installation of\n      // ApolloServerPluginLandingPage*Default and the other plugin will be\n      // found; we skip the implicit plugin.\n      let taggedServerListenersWithRenderLandingPage =\n        taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        taggedServerListenersWithRenderLandingPage =\n          taggedServerListenersWithRenderLandingPage.filter(\n            (l) => !l.installedImplicitly,\n          );\n      }\n      if (taggedServerListenersWithRenderLandingPage.length > 1) {\n        throw Error('Only one plugin can implement renderLandingPage.');\n      } else if (taggedServerListenersWithRenderLandingPage.length) {\n        this.landingPage = await taggedServerListenersWithRenderLandingPage[0]\n          .serverListener.renderLandingPage!();\n      } else {\n        this.landingPage = null;\n      }\n\n      this.state = {\n        phase: 'started',\n        schemaManager,\n      };\n      this.maybeRegisterTerminationSignalHandlers(['SIGINT', 'SIGTERM']);\n    } catch (error) {\n      this.state = { phase: 'failed to start', error: error as Error };\n      throw error;\n    } finally {\n      barrier.resolve();\n    }\n  }\n\n  private maybeRegisterTerminationSignalHandlers(signals: NodeJS.Signals[]) {\n    if (!this.stopOnTerminationSignals) {\n      return;\n    }\n\n    let receivedSignal = false;\n    const signalHandler: NodeJS.SignalsListener = async (signal) => {\n      if (receivedSignal) {\n        // If we receive another SIGINT or SIGTERM while we're waiting\n        // for the server to stop, just ignore it.\n        return;\n      }\n      receivedSignal = true;\n      try {\n        await this.stop();\n      } catch (e) {\n        this.logger.error(`stop() threw during ${signal} shutdown`);\n        this.logger.error(e);\n        // Can't rely on the signal handlers being removed.\n        process.exit(1);\n      }\n      // Note: this.stop will call the toDisposeLast handlers below, so at\n      // this point this handler will have been removed and we can re-kill\n      // ourself to die with the appropriate signal exit status. this.stop\n      // takes care to call toDisposeLast last, so the signal handler isn't\n      // removed until after the rest of shutdown happens.\n      process.kill(process.pid, signal);\n    };\n\n    signals.forEach((signal) => {\n      process.on(signal, signalHandler);\n      this.toDisposeLast.add(async () => {\n        process.removeListener(signal, signalHandler);\n      });\n    });\n  }\n\n  // This method is called at the beginning of each GraphQL request by\n  // `graphQLServerOptions`. Most of its logic is only helpful for serverless\n  // frameworks: unless you're in a serverless framework, you should have called\n  // `await server.start()` before the server got to the point of running\n  // GraphQL requests (`assertStarted` calls in the framework integrations\n  // verify that) and so the only cases for non-serverless frameworks that this\n  // should hit are 'started', 'stopping', and 'stopped'. For serverless\n  // frameworks, this lets the server wait until fully started before serving\n  // operations.\n  //\n  // It's also called via `ensureStarted` by serverless frameworks so that they\n  // can call `renderLandingPage` (or do other things like call a method on a base\n  // class that expects it to be started).\n  private async _ensureStarted(): Promise<SchemaDerivedData> {\n    while (true) {\n      switch (this.state.phase) {\n        case 'initialized':\n          // This error probably won't happen: serverless frameworks\n          // automatically call `_start` at the end of the constructor, and\n          // other frameworks call `assertStarted` before setting things up\n          // enough to make calling this function possible.\n          throw new Error(\n            'You need to call `server.start()` before using your Apollo Server.',\n          );\n        case 'starting':\n          await this.state.barrier;\n          // continue the while loop\n          break;\n        case 'failed to start':\n          // First we log the error that prevented startup (which means it will\n          // get logged once for every GraphQL operation).\n          this.logStartupError(this.state.error);\n          // Now make the operation itself fail.\n          // We intentionally do not re-throw actual startup error as it may contain\n          // implementation details and this error will propagate to the client.\n          throw new Error(\n            'This data graph is missing a valid configuration. More details may be available in the server logs.',\n          );\n        case 'started':\n        case 'draining': // We continue to run operations while draining.\n          return this.state.schemaManager.getSchemaDerivedData();\n        case 'stopping':\n          throw new Error(\n            'Cannot execute GraphQL operations while the server is stopping.',\n          );\n        case 'stopped':\n          throw new Error(\n            'Cannot execute GraphQL operations after the server has stopped.',\n          );\n        default:\n          throw new UnreachableCaseError(this.state);\n      }\n    }\n  }\n\n  // For serverless frameworks only. Just like `_ensureStarted` but hides its\n  // return value.\n  protected async ensureStarted() {\n    await this._ensureStarted();\n  }\n\n  protected assertStarted(methodName: string) {\n    if (this.state.phase !== 'started' && this.state.phase !== 'draining') {\n      throw new Error(\n        'You must `await server.start()` before calling `server.' +\n          methodName +\n          '()`',\n      );\n    }\n    // XXX do we need to do anything special for stopping/stopped?\n  }\n\n  // Given an error that occurred during Apollo Server startup, log it with a\n  // helpful message. This should only happen with serverless frameworks; with\n  // other frameworks, you must `await server.start()` which will throw the\n  // startup error directly instead of logging (or `await server.listen()` for\n  // the batteries-included `apollo-server`).\n  private logStartupError(err: Error) {\n    this.logger.error(\n      'An error occurred during Apollo Server startup. All GraphQL requests ' +\n        'will now fail. The startup error was: ' +\n        (err?.message || err),\n    );\n  }\n\n  private constructSchema(): GraphQLSchema {\n    const { schema, modules, typeDefs, resolvers, parseOptions } = this.config;\n    if (schema) {\n      return schema;\n    }\n\n    if (modules) {\n      const { schema, errors } = buildServiceDefinition(modules);\n      if (errors && errors.length > 0) {\n        throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n      }\n      return schema!;\n    }\n\n    if (!typeDefs) {\n      throw Error(\n        'Apollo Server requires either an existing schema, modules or typeDefs',\n      );\n    }\n\n    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];\n\n    // For convenience, we allow you to pass a few options that we pass through\n    // to a particular version of `@graphql-tools/schema`'s\n    // `makeExecutableSchema`. If you want to use more of this function's\n    // features or have more control over the version of the packages used, just\n    // call it yourself like `new ApolloServer({schema:\n    // makeExecutableSchema(...)})`.\n    return makeExecutableSchema({\n      typeDefs: augmentedTypeDefs,\n      resolvers,\n      parseOptions,\n    });\n  }\n\n  private maybeAddMocksToConstructedSchema(\n    schema: GraphQLSchema,\n  ): GraphQLSchema {\n    const { mocks, mockEntireSchema } = this.config;\n    if (mocks === false) {\n      return schema;\n    }\n    if (!mocks && typeof mockEntireSchema === 'undefined') {\n      return schema;\n    }\n    return addMocksToSchema({\n      schema,\n      mocks: mocks === true || typeof mocks === 'undefined' ? {} : mocks,\n      preserveResolvers:\n        typeof mockEntireSchema === 'undefined' ? false : !mockEntireSchema,\n    });\n  }\n\n  private generateSchemaDerivedData(schema: GraphQLSchema): SchemaDerivedData {\n    const schemaHash = generateSchemaHash(schema!);\n\n    return {\n      schema,\n      schemaHash,\n      // The DocumentStore is schema-derived because we put documents in it\n      // after checking that they pass GraphQL validation against the schema and\n      // use this to skip validation as well as parsing. So we can't reuse the\n      // same DocumentStore for different schemas because that might make us\n      // treat invalid operations as valid. If we're using the default\n      // DocumentStore, then we just create it from scratch each time we get a\n      // new schema. If we're using a user-provided DocumentStore, then we use a\n      // random prefix each time we get a new schema.\n      documentStore:\n        this.config.documentStore === undefined\n          ? new InMemoryLRUCache()\n          : this.config.documentStore === null\n          ? null\n          : new PrefixingKeyValueCache(\n              this.config.documentStore,\n              `${uuid.v4()}:`,\n            ),\n    };\n  }\n\n  public async stop() {\n    switch (this.state.phase) {\n      case 'initialized':\n      case 'starting':\n      case 'failed to start':\n        throw Error(\n          'apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded',\n        );\n\n      // Calling stop more than once should have the same result as the first time.\n      case 'stopped':\n        if (this.state.stopError) {\n          throw this.state.stopError;\n        }\n        return;\n\n      // Two parallel calls to stop; just wait for the other one to finish and\n      // do whatever it did.\n      case 'stopping':\n      case 'draining': {\n        await this.state.barrier;\n        // The cast here is because TS doesn't understand that this.state can\n        // change during the await\n        // (https://github.com/microsoft/TypeScript/issues/9998).\n        const state = this.state as ServerState;\n        if (state.phase !== 'stopped') {\n          throw Error(`Surprising post-stopping state ${state.phase}`);\n        }\n        if (state.stopError) {\n          throw state.stopError;\n        }\n        return;\n      }\n\n      case 'started':\n        // This is handled by the rest of the function.\n        break;\n\n      default:\n        throw new UnreachableCaseError(this.state);\n    }\n\n    const barrier = resolvable();\n\n    // Commit to stopping and start draining servers.\n    this.state = {\n      phase: 'draining',\n      schemaManager: this.state.schemaManager,\n      barrier,\n    };\n\n    try {\n      await this.drainServers?.();\n\n      // Servers are drained. Prevent further operations from starting and call\n      // stop handlers.\n      this.state = { phase: 'stopping', barrier };\n\n      // We run shutdown handlers in two phases because we don't want to turn\n      // off our signal listeners (ie, allow signals to kill the process) until\n      // we've done the important parts of shutdown like running serverWillStop\n      // handlers. (We can make this more generic later if it's helpful.)\n      await Promise.all([...this.toDispose].map((dispose) => dispose()));\n      await Promise.all([...this.toDisposeLast].map((dispose) => dispose()));\n    } catch (stopError) {\n      this.state = { phase: 'stopped', stopError: stopError as Error };\n      barrier.resolve();\n      throw stopError;\n    }\n    this.state = { phase: 'stopped', stopError: null };\n  }\n\n  protected serverlessFramework(): boolean {\n    return false;\n  }\n\n  private ensurePluginInstantiation(\n    userPlugins: PluginDefinition[] = [],\n    isDev: boolean,\n  ): void {\n    this.plugins = userPlugins.map((plugin) => {\n      if (typeof plugin === 'function') {\n        return plugin();\n      }\n      return plugin;\n    });\n\n    const alreadyHavePluginWithInternalId = (id: InternalPluginId) =>\n      this.plugins.some(\n        (p) => pluginIsInternal(p) && p.__internal_plugin_id__() === id,\n      );\n\n    // Special case: cache control is on unless you explicitly disable it.\n    {\n      if (!alreadyHavePluginWithInternalId('CacheControl')) {\n        this.plugins.push(ApolloServerPluginCacheControl());\n      }\n    }\n\n    // Special case: usage reporting is on by default (and first!) if you\n    // configure an API key.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('UsageReporting');\n      if (!alreadyHavePlugin && this.apolloConfig.key) {\n        if (this.apolloConfig.graphRef) {\n          // Keep this plugin first so it wraps everything. (Unfortunately despite\n          // the fact that the person who wrote this line also was the original\n          // author of the comment above in #1105, they don't quite understand why this was important.)\n          this.plugins.unshift(ApolloServerPluginUsageReporting());\n        } else {\n          this.logger.warn(\n            'You have specified an Apollo key but have not specified a graph ref; usage ' +\n              'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +\n              'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +\n              'warning, install `ApolloServerPluginUsageReportingDisabled`.',\n          );\n        }\n      }\n    }\n\n    // Special case: schema reporting can be turned on via environment variable.\n    {\n      const alreadyHavePlugin =\n        alreadyHavePluginWithInternalId('SchemaReporting');\n      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';\n      if (!alreadyHavePlugin && enabledViaEnvVar) {\n        if (this.apolloConfig.key) {\n          const options: ApolloServerPluginSchemaReportingOptions = {};\n          this.plugins.push(ApolloServerPluginSchemaReporting(options));\n        } else {\n          throw new Error(\n            \"You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING \" +\n              'environment variable to true, but you also need to provide your ' +\n              'Apollo API key, via the APOLLO_KEY environment ' +\n              'variable or via `new ApolloServer({apollo: {key})',\n          );\n        }\n      }\n    }\n\n    // Special case: inline tracing is on by default for federated schemas.\n    {\n      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');\n      if (!alreadyHavePlugin) {\n        // If we haven't explicitly disabled inline tracing via\n        // ApolloServerPluginInlineTraceDisabled or explicitly installed our own\n        // ApolloServerPluginInlineTrace, we set up inline tracing in \"only if\n        // federated\" mode.  (This is slightly different than the\n        // pre-ApolloServerPluginInlineTrace where we would also avoid doing\n        // this if an API key was configured and log a warning.)\n        this.plugins.push(\n          ApolloServerPluginInlineTrace({ __onlyIfSchemaIsFederated: true }),\n        );\n      }\n    }\n\n    // Special case: If we're not in production, show our default landing page.\n    //\n    // This works a bit differently from the other implicitly installed plugins,\n    // which rely entirely on the __internal_plugin_id__ to decide whether the\n    // plugin takes effect. That's because we want third-party plugins to be\n    // able to provide a landing page that overrides the default landing page,\n    // without them having to know about __internal_plugin_id__. So unless we\n    // actively disable the default landing page with\n    // ApolloServerPluginLandingPageDisabled, we install the default landing\n    // page, but with a special flag that _start() uses to ignore it if some\n    // other plugin defines a renderLandingPage callback. (We can't just look\n    // now to see if the plugin defines renderLandingPage because we haven't run\n    // serverWillStart yet.)\n    const alreadyHavePlugin = alreadyHavePluginWithInternalId(\n      'LandingPageDisabled',\n    );\n    if (!alreadyHavePlugin) {\n      const plugin = isDev\n        ? ApolloServerPluginLandingPageLocalDefault()\n        : ApolloServerPluginLandingPageProductionDefault();\n      if (!isImplicitlyInstallablePlugin(plugin)) {\n        throw Error(\n          'default landing page plugin should be implicitly installable?',\n        );\n      }\n      plugin.__internal_installed_implicitly__ = true;\n      this.plugins.push(plugin);\n    }\n  }\n\n  // This function is used by the integrations to generate the graphQLOptions\n  // from an object containing the request and other integration specific\n  // options\n  protected async graphQLServerOptions(\n    // We ought to be able to declare this as taking ContextFunctionParams, but\n    // that gets us into weird business around inheritance, since a subclass (eg\n    // Lambda subclassing Express) may have a different ContextFunctionParams.\n    // So it's the job of the subclass's function that calls this function to\n    // make sure that its argument properly matches the particular subclass's\n    // context params type.\n    integrationContextArgument?: any,\n  ): Promise<GraphQLServerOptions> {\n    const { schema, schemaHash, documentStore } = await this._ensureStarted();\n\n    let context: Context = this.context ? this.context : {};\n\n    try {\n      context =\n        typeof this.context === 'function'\n          ? await this.context(integrationContextArgument || {})\n          : context;\n    } catch (error) {\n      // Defer context error resolution to inside of runQuery\n      context = () => {\n        throw error;\n      };\n    }\n\n    return {\n      schema,\n      schemaHash,\n      logger: this.logger,\n      plugins: this.plugins,\n      documentStore,\n      context,\n      parseOptions: this.parseOptions,\n      ...this.requestOptions,\n    };\n  }\n\n  /**\n   * This method is primarily meant for testing: it allows you to execute a\n   * GraphQL operation via the request pipeline without going through the HTTP layer.\n   * Note that this means that any handling you do\n   * in your server at the HTTP level will not affect this call!\n   *\n   * For convenience, you can provide `request.query` either as a string or a\n   * DocumentNode, in case you choose to use the gql tag in your tests. This is\n   * just a convenience, not an optimization (we convert provided ASTs back into\n   * string).\n   *\n   * If you pass a second argument to this method and your ApolloServer's\n   * `context` is a function, that argument will be passed directly to your\n   * `context` function. It is your responsibility to make it as close as needed\n   * by your `context` function to the integration-specific argument that your\n   * integration passes to `context` (eg, for `apollo-server-express`, the\n   * `{req: express.Request, res: express.Response }` object) and to keep it\n   * updated as you upgrade Apollo Server.\n   */\n  public async executeOperation(\n    request: Omit<GraphQLRequest, 'query'> & {\n      query?: string | DocumentNode;\n    },\n    integrationContextArgument?: ContextFunctionParams,\n  ) {\n    // Since this function is mostly for testing, you don't need to explicitly\n    // start your server before calling it. (That also means you can use it with\n    // `apollo-server` which doesn't support `start()`.)\n    if (this.state.phase === 'initialized') {\n      await this._start();\n    }\n\n    const options = await this.graphQLServerOptions(integrationContextArgument);\n\n    if (typeof options.context === 'function') {\n      options.context = (options.context as () => never)();\n    } else if (typeof options.context === 'object') {\n      // TODO: We currently shallow clone the context for every request,\n      // but that's unlikely to be what people want.\n      // We allow passing in a function for `context` to ApolloServer,\n      // but this only runs once for a batched request (because this is resolved\n      // in ApolloServer#graphQLServerOptions, before runHttpQuery is invoked).\n      // NOTE: THIS IS DUPLICATED IN runHttpQuery.ts' buildRequestContext.\n      options.context = cloneObject(options.context);\n    }\n\n    const requestCtx: GraphQLRequestContext = {\n      logger: this.logger,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request: {\n        ...request,\n        query:\n          request.query && typeof request.query !== 'string'\n            ? print(request.query)\n            : request.query,\n      },\n      context: options.context || Object.create(null),\n      cache: options.cache!,\n      metrics: {},\n      response: {\n        http: {\n          headers: new Headers(),\n        },\n      },\n      debug: options.debug,\n      overallCachePolicy: newCachePolicy(),\n      requestIsBatched: false,\n    };\n\n    return processGraphQLRequest(options, requestCtx);\n  }\n\n  // This method is called by integrations after start() (because we want\n  // renderLandingPage callbacks to be able to take advantage of the context\n  // passed to serverWillStart); it returns the LandingPage from the (single)\n  // plugin `renderLandingPage` callback if it exists and returns what it\n  // returns to the integration. The integration should serve the HTML page when\n  // requested with `accept: text/html`. If no landing page is defined by any\n  // plugin, returns null. (Specifically null and not undefined; some serverless\n  // integrations rely on this to tell the difference between \"haven't called\n  // renderLandingPage yet\" and \"there is no landing page\").\n  protected getLandingPage(): LandingPage | null {\n    this.assertStarted('getLandingPage');\n\n    return this.landingPage;\n  }\n}\n\nexport type ImplicitlyInstallablePlugin = ApolloServerPlugin & {\n  __internal_installed_implicitly__: boolean;\n};\n\nexport function isImplicitlyInstallablePlugin(\n  p: ApolloServerPlugin,\n): p is ImplicitlyInstallablePlugin {\n  return '__internal_installed_implicitly__' in p;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}