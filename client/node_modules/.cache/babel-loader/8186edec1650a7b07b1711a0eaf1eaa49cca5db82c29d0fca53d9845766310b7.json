{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloServerPluginCacheControlDisabled = exports.ApolloServerPluginCacheControl = void 0;\nconst graphql_1 = require(\"graphql\");\nconst cachePolicy_1 = require(\"../../cachePolicy\");\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nfunction ApolloServerPluginCacheControl() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);\n  const typeAnnotationCache = new lru_cache_1.default();\n  const fieldAnnotationCache = new lru_cache_1.default();\n  function memoizedCacheAnnotationFromType(t) {\n    const existing = typeAnnotationCache.get(t);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromType(t);\n    typeAnnotationCache.set(t, annotation);\n    return annotation;\n  }\n  function memoizedCacheAnnotationFromField(field) {\n    const existing = fieldAnnotationCache.get(field);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromField(field);\n    fieldAnnotationCache.set(field, annotation);\n    return annotation;\n  }\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    },\n    async serverWillStart(_ref) {\n      let {\n        schema\n      } = _ref;\n      typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType).length;\n      fieldAnnotationCache.max = Object.values(schema.getTypeMap()).filter(graphql_1.isObjectType).flatMap(t => Object.values(t.getFields())).length + Object.values(schema.getTypeMap()).filter(graphql_1.isInterfaceType).flatMap(t => Object.values(t.getFields())).length;\n      return undefined;\n    },\n    async requestDidStart(requestContext) {\n      var _a, _b;\n      const defaultMaxAge = (_a = options.defaultMaxAge) !== null && _a !== void 0 ? _a : 0;\n      const calculateHttpHeaders = (_b = options.calculateHttpHeaders) !== null && _b !== void 0 ? _b : true;\n      const {\n        __testing__cacheHints\n      } = options;\n      return {\n        async executionDidStart() {\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            const fakeFieldPolicy = (0, cachePolicy_1.newCachePolicy)();\n            return {\n              willResolveField(_ref2) {\n                let {\n                  info\n                } = _ref2;\n                info.cacheControl = {\n                  setCacheHint: dynamicHint => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType\n                };\n              }\n            };\n          }\n          return {\n            willResolveField(_ref3) {\n              let {\n                info\n              } = _ref3;\n              const fieldPolicy = (0, cachePolicy_1.newCachePolicy)();\n              let inheritMaxAge = false;\n              const targetType = (0, graphql_1.getNamedType)(info.returnType);\n              if ((0, graphql_1.isCompositeType)(targetType)) {\n                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n              const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);\n              if (fieldAnnotation.inheritMaxAge && fieldPolicy.maxAge === undefined) {\n                inheritMaxAge = true;\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({\n                    scope: fieldAnnotation.scope\n                  });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n              info.cacheControl = {\n                setCacheHint: dynamicHint => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType\n              };\n              return () => {\n                if (fieldPolicy.maxAge === undefined && ((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge || !info.path.prev)) {\n                  fieldPolicy.restrict({\n                    maxAge: defaultMaxAge\n                  });\n                }\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = (0, graphql_1.responsePathAsArray)(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\"shouldn't happen: addHint should only be called once per path\");\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            }\n          };\n        },\n        async willSendResponse(requestContext) {\n          const {\n            response,\n            overallCachePolicy,\n            requestIsBatched\n          } = requestContext;\n          const policyIfCacheable = overallCachePolicy.policyIfCacheable();\n          if (calculateHttpHeaders && policyIfCacheable && !response.errors && response.http && !requestIsBatched) {\n            response.http.headers.set('Cache-Control', `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);\n          }\n        }\n      };\n    }\n  };\n}\nexports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;\nfunction cacheAnnotationFromDirectives(directives) {\n  var _a, _b, _c;\n  if (!directives) return undefined;\n  const cacheControlDirective = directives.find(directive => directive.name.value === 'cacheControl');\n  if (!cacheControlDirective) return undefined;\n  if (!cacheControlDirective.arguments) return undefined;\n  const maxAgeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'maxAge');\n  const scopeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'scope');\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(argument => argument.name.value === 'inheritMaxAge');\n  const scope = ((_a = scopeArgument === null || scopeArgument === void 0 ? void 0 : scopeArgument.value) === null || _a === void 0 ? void 0 : _a.kind) === 'EnumValue' ? scopeArgument.value.value : undefined;\n  if (((_b = inheritMaxAgeArgument === null || inheritMaxAgeArgument === void 0 ? void 0 : inheritMaxAgeArgument.value) === null || _b === void 0 ? void 0 : _b.kind) === 'BooleanValue' && inheritMaxAgeArgument.value.value) {\n    return {\n      inheritMaxAge: true,\n      scope\n    };\n  }\n  return {\n    maxAge: ((_c = maxAgeArgument === null || maxAgeArgument === void 0 ? void 0 : maxAgeArgument.value) === null || _c === void 0 ? void 0 : _c.kind) === 'IntValue' ? parseInt(maxAgeArgument.value.value) : undefined,\n    scope\n  };\n}\nfunction cacheAnnotationFromType(t) {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\nfunction cacheAnnotationFromField(field) {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\nfunction isRestricted(hint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\nfunction ApolloServerPluginCacheControlDisabled() {\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    }\n  };\n}\nexports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;","map":{"version":3,"mappings":"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","names":["ApolloServerPluginCacheControl","options","Object","create","typeAnnotationCache","lru_cache_1","fieldAnnotationCache","memoizedCacheAnnotationFromType","t","existing","get","annotation","cacheAnnotationFromType","set","memoizedCacheAnnotationFromField","field","cacheAnnotationFromField","__internal_plugin_id__","serverWillStart","schema","max","values","getTypeMap","filter","graphql_1","length","flatMap","getFields","undefined","requestDidStart","requestContext","defaultMaxAge","calculateHttpHeaders","__testing__cacheHints","executionDidStart","isRestricted","overallCachePolicy","fakeFieldPolicy","willResolveField","info","cacheControl","setCacheHint","dynamicHint","replace","cacheHint","cacheHintFromType","fieldPolicy","inheritMaxAge","targetType","returnType","typeAnnotation","fieldAnnotation","parentType","fieldName","maxAge","scope","path","prev","restrict","join","has","Error","willSendResponse","response","requestIsBatched","policyIfCacheable","errors","http","headers","toLowerCase","exports","cacheAnnotationFromDirectives","directives","cacheControlDirective","find","directive","name","value","arguments","maxAgeArgument","argument","scopeArgument","inheritMaxAgeArgument","kind","parseInt","astNode","hint","extensionASTNodes","node","ApolloServerPluginCacheControlDisabled"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\cacheControl\\index.ts"],"sourcesContent":["import type { CacheAnnotation, CacheHint } from 'apollo-server-types';\nimport type { CacheScope } from 'apollo-server-types';\nimport {\n  DirectiveNode,\n  getNamedType,\n  GraphQLCompositeType,\n  GraphQLField,\n  isCompositeType,\n  isInterfaceType,\n  isObjectType,\n  responsePathAsArray,\n} from 'graphql';\nimport { newCachePolicy } from '../../cachePolicy';\nimport type { InternalApolloServerPlugin } from '../../internalPlugin';\nimport LRUCache from 'lru-cache';\n\nexport interface ApolloServerPluginCacheControlOptions {\n  /**\n   * All root fields and fields returning objects or interfaces have this value\n   * for `maxAge` unless they set a cache hint with a non-undefined `maxAge`\n   * using `@cacheControl` or `setCacheHint`. The default is 0, which means \"not\n   * cacheable\". (That is: if you don't set `defaultMaxAge`, then every root\n   * field in your operation and every field with sub-fields must have a cache\n   * hint or the overall operation will not be cacheable.)\n   */\n  defaultMaxAge?: number;\n  /**\n   * Determines whether to set the `Cache-Control` HTTP header on cacheable\n   * responses with no errors. The default is true.\n   */\n  calculateHttpHeaders?: boolean;\n  // For testing only.\n  __testing__cacheHints?: Map<string, CacheHint>;\n}\n\nexport function ApolloServerPluginCacheControl(\n  options: ApolloServerPluginCacheControlOptions = Object.create(null),\n): InternalApolloServerPlugin {\n  const typeAnnotationCache = new LRUCache<\n    GraphQLCompositeType,\n    CacheAnnotation\n  >();\n  const fieldAnnotationCache = new LRUCache<\n    GraphQLField<unknown, unknown>,\n    CacheAnnotation\n  >();\n\n  function memoizedCacheAnnotationFromType(\n    t: GraphQLCompositeType,\n  ): CacheAnnotation {\n    const existing = typeAnnotationCache.get(t);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromType(t);\n    typeAnnotationCache.set(t, annotation);\n    return annotation;\n  }\n\n  function memoizedCacheAnnotationFromField(\n    field: GraphQLField<unknown, unknown>,\n  ): CacheAnnotation {\n    const existing = fieldAnnotationCache.get(field);\n    if (existing) {\n      return existing;\n    }\n    const annotation = cacheAnnotationFromField(field);\n    fieldAnnotationCache.set(field, annotation);\n    return annotation;\n  }\n\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    },\n\n    async serverWillStart({ schema }) {\n      // Set the size of the caches to be equal to the number of composite types\n      // and fields in the schema respectively. This generally means that the\n      // cache will always have room for all the cache hints in the active\n      // schema but we won't have a memory leak as schemas are replaced in a\n      // gateway. (Once we're comfortable breaking compatibility with\n      // versions of Gateway older than 0.35.0, we should also run this code\n      // from a schemaDidLoadOrUpdate instead of serverWillStart. Using\n      // schemaDidLoadOrUpdate throws when combined with old gateways.)\n      typeAnnotationCache.max = Object.values(schema.getTypeMap()).filter(\n        isCompositeType,\n      ).length;\n      fieldAnnotationCache.max =\n        Object.values(schema.getTypeMap())\n          .filter(isObjectType)\n          .flatMap((t) => Object.values(t.getFields())).length +\n        Object.values(schema.getTypeMap())\n          .filter(isInterfaceType)\n          .flatMap((t) => Object.values(t.getFields())).length;\n      return undefined;\n    },\n\n    async requestDidStart(requestContext) {\n      const defaultMaxAge: number = options.defaultMaxAge ?? 0;\n      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;\n      const { __testing__cacheHints } = options;\n\n      return {\n        async executionDidStart() {\n          // Did something set the overall cache policy before we've even\n          // started? If so, consider that as an override and don't touch it.\n          // Just put set up fake `info.cacheControl` objects and otherwise\n          // don't track cache policy.\n          //\n          // (This doesn't happen in practice using the core plugins: the main\n          // use case for restricting overallCachePolicy outside of this plugin\n          // is apollo-server-plugin-response-cache, but when it sets the policy\n          // we never get to execution at all.)\n          if (isRestricted(requestContext.overallCachePolicy)) {\n            // This is \"fake\" in the sense that it never actually affects\n            // requestContext.overallCachePolicy.\n            const fakeFieldPolicy = newCachePolicy();\n            return {\n              willResolveField({ info }) {\n                info.cacheControl = {\n                  setCacheHint: (dynamicHint: CacheHint) => {\n                    fakeFieldPolicy.replace(dynamicHint);\n                  },\n                  cacheHint: fakeFieldPolicy,\n                  cacheHintFromType: memoizedCacheAnnotationFromType,\n                };\n              },\n            };\n          }\n\n          return {\n            willResolveField({ info }) {\n              const fieldPolicy = newCachePolicy();\n\n              let inheritMaxAge = false;\n\n              // If this field's resolver returns an object/interface/union\n              // (maybe wrapped in list/non-null), look for hints on that return\n              // type.\n              const targetType = getNamedType(info.returnType);\n              if (isCompositeType(targetType)) {\n                const typeAnnotation =\n                  memoizedCacheAnnotationFromType(targetType);\n                fieldPolicy.replace(typeAnnotation);\n                inheritMaxAge = !!typeAnnotation.inheritMaxAge;\n              }\n\n              // Look for hints on the field itself (on its parent type), taking\n              // precedence over previously calculated hints.\n              const fieldAnnotation = memoizedCacheAnnotationFromField(\n                info.parentType.getFields()[info.fieldName],\n              );\n\n              // Note that specifying `@cacheControl(inheritMaxAge: true)` on a\n              // field whose return type defines a `maxAge` gives precedence to\n              // the type's `maxAge`. (Perhaps this should be some sort of\n              // error.)\n              if (\n                fieldAnnotation.inheritMaxAge &&\n                fieldPolicy.maxAge === undefined\n              ) {\n                inheritMaxAge = true;\n                // Handle `@cacheControl(inheritMaxAge: true, scope: PRIVATE)`.\n                // (We ignore any specified `maxAge`; perhaps it should be some\n                // sort of error.)\n                if (fieldAnnotation.scope) {\n                  fieldPolicy.replace({ scope: fieldAnnotation.scope });\n                }\n              } else {\n                fieldPolicy.replace(fieldAnnotation);\n              }\n\n              info.cacheControl = {\n                setCacheHint: (dynamicHint: CacheHint) => {\n                  fieldPolicy.replace(dynamicHint);\n                },\n                cacheHint: fieldPolicy,\n                cacheHintFromType: memoizedCacheAnnotationFromType,\n              };\n\n              // When the resolver is done, call restrict once. By calling\n              // restrict after the resolver instead of before, we don't need to\n              // \"undo\" the effect on overallCachePolicy of a static hint that\n              // gets refined by a dynamic hint.\n              return () => {\n                // If this field returns a composite type or is a root field and\n                // we haven't seen an explicit maxAge hint, set the maxAge to 0\n                // (uncached) or the default if specified in the constructor.\n                // (Non-object fields by default are assumed to inherit their\n                // cacheability from their parents. But on the other hand, while\n                // root non-object fields can get explicit hints from their\n                // definition on the Query/Mutation object, if that doesn't\n                // exist then there's no parent field that would assign the\n                // default maxAge, so we do it here.)\n                //\n                // You can disable this on a non-root field by writing\n                // `@cacheControl(inheritMaxAge: true)` on it. If you do this,\n                // then its children will be treated like root paths, since\n                // there is no parent maxAge to inherit.\n                //\n                // We do this in the end hook so that dynamic cache control\n                // prevents it from happening (eg,\n                // `info.cacheControl.cacheHint.restrict({maxAge: 60})` should\n                // work rather than doing nothing because we've already set the\n                // max age to the default of 0). This also lets resolvers assume\n                // any hint in `info.cacheControl.cacheHint` was explicitly set.\n                if (\n                  fieldPolicy.maxAge === undefined &&\n                  ((isCompositeType(targetType) && !inheritMaxAge) ||\n                    !info.path.prev)\n                ) {\n                  fieldPolicy.restrict({ maxAge: defaultMaxAge });\n                }\n\n                if (__testing__cacheHints && isRestricted(fieldPolicy)) {\n                  const path = responsePathAsArray(info.path).join('.');\n                  if (__testing__cacheHints.has(path)) {\n                    throw Error(\n                      \"shouldn't happen: addHint should only be called once per path\",\n                    );\n                  }\n                  __testing__cacheHints.set(path, {\n                    maxAge: fieldPolicy.maxAge,\n                    scope: fieldPolicy.scope,\n                  });\n                }\n                requestContext.overallCachePolicy.restrict(fieldPolicy);\n              };\n            },\n          };\n        },\n\n        async willSendResponse(requestContext) {\n          const { response, overallCachePolicy, requestIsBatched } =\n            requestContext;\n\n          const policyIfCacheable = overallCachePolicy.policyIfCacheable();\n\n          // If the feature is enabled, there is a non-trivial cache policy,\n          // there are no errors, we actually can write headers, and the request\n          // is not batched (because we have no way of merging the header across\n          // operations in AS3), write the header.\n          if (\n            calculateHttpHeaders &&\n            policyIfCacheable &&\n            !response.errors &&\n            response.http &&\n            !requestIsBatched\n          ) {\n            response.http.headers.set(\n              'Cache-Control',\n              `max-age=${\n                policyIfCacheable.maxAge\n              }, ${policyIfCacheable.scope.toLowerCase()}`,\n            );\n          }\n        },\n      };\n    },\n  };\n}\n\nfunction cacheAnnotationFromDirectives(\n  directives: ReadonlyArray<DirectiveNode> | undefined,\n): CacheAnnotation | undefined {\n  if (!directives) return undefined;\n\n  const cacheControlDirective = directives.find(\n    (directive) => directive.name.value === 'cacheControl',\n  );\n  if (!cacheControlDirective) return undefined;\n\n  if (!cacheControlDirective.arguments) return undefined;\n\n  const maxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'maxAge',\n  );\n  const scopeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'scope',\n  );\n  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(\n    (argument) => argument.name.value === 'inheritMaxAge',\n  );\n\n  const scope =\n    scopeArgument?.value?.kind === 'EnumValue'\n      ? (scopeArgument.value.value as CacheScope)\n      : undefined;\n\n  if (\n    inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&\n    inheritMaxAgeArgument.value.value\n  ) {\n    // We ignore maxAge if it is also specified.\n    return { inheritMaxAge: true, scope };\n  }\n\n  return {\n    maxAge:\n      maxAgeArgument?.value?.kind === 'IntValue'\n        ? parseInt(maxAgeArgument.value.value)\n        : undefined,\n    scope,\n  };\n}\n\nfunction cacheAnnotationFromType(t: GraphQLCompositeType): CacheAnnotation {\n  if (t.astNode) {\n    const hint = cacheAnnotationFromDirectives(t.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  if (t.extensionASTNodes) {\n    for (const node of t.extensionASTNodes) {\n      const hint = cacheAnnotationFromDirectives(node.directives);\n      if (hint) {\n        return hint;\n      }\n    }\n  }\n  return {};\n}\n\nfunction cacheAnnotationFromField(\n  field: GraphQLField<unknown, unknown>,\n): CacheAnnotation {\n  if (field.astNode) {\n    const hint = cacheAnnotationFromDirectives(field.astNode.directives);\n    if (hint) {\n      return hint;\n    }\n  }\n  return {};\n}\n\nfunction isRestricted(hint: CacheHint) {\n  return hint.maxAge !== undefined || hint.scope !== undefined;\n}\n\n// This plugin does nothing, but it ensures that ApolloServer won't try\n// to add a default ApolloServerPluginCacheControl.\nexport function ApolloServerPluginCacheControlDisabled(): InternalApolloServerPlugin {\n  return {\n    __internal_plugin_id__() {\n      return 'CacheControl';\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}