{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloServerPluginUsageReportingDisabled = exports.makeHTTPRequestHeaders = exports.ApolloServerPluginUsageReporting = void 0;\nconst os_1 = __importDefault(require(\"os\"));\nconst util_1 = require(\"util\");\nconst zlib_1 = require(\"zlib\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst node_abort_controller_1 = require(\"node-abort-controller\");\nconst apollo_server_types_1 = require(\"apollo-server-types\");\nconst operationDerivedDataCache_1 = require(\"./operationDerivedDataCache\");\nconst utils_usagereporting_1 = require(\"@apollo/utils.usagereporting\");\nconst traceTreeBuilder_1 = require(\"../traceTreeBuilder\");\nconst traceDetails_1 = require(\"./traceDetails\");\nconst graphql_1 = require(\"graphql\");\nconst schemaReporting_1 = require(\"../schemaReporting\");\nconst stats_1 = require(\"./stats\");\nconst defaultSendOperationsAsTrace_1 = require(\"./defaultSendOperationsAsTrace\");\nconst utils_usagereporting_2 = require(\"@apollo/utils.usagereporting\");\nconst gzipPromise = (0, util_1.promisify)(zlib_1.gzip);\nconst reportHeaderDefaults = {\n  hostname: os_1.default.hostname(),\n  agentVersion: `apollo-server-core@${require('../../../package.json').version}`,\n  runtimeVersion: `node ${process.version}`,\n  uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`\n};\nfunction ApolloServerPluginUsageReporting() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === 'number' ? async () => Math.random() < fieldLevelInstrumentationOption ? 1 / fieldLevelInstrumentationOption : 0 : fieldLevelInstrumentationOption ? fieldLevelInstrumentationOption : async () => true;\n  let requestDidStartHandler;\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n    async requestDidStart(requestContext) {\n      if (!requestDidStartHandler) {\n        throw Error('The usage reporting plugin has been asked to handle a request before the ' + 'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' + 'for more details.');\n      }\n      return requestDidStartHandler(requestContext);\n    },\n    async serverWillStart(_ref) {\n      let {\n        logger: serverLogger,\n        apollo,\n        serverlessFramework\n      } = _ref;\n      var _a, _b, _c, _d;\n      const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : serverLogger;\n      const {\n        key,\n        graphRef\n      } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" + 'but you also need to provide your Apollo API key and graph ref, via ' + 'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' + 'variables or via `new ApolloServer({apollo: {key, graphRef})`.');\n      }\n      logger.info('Apollo usage reporting starting! See your graph at ' + `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);\n      const sendReportsImmediately = (_b = options.sendReportsImmediately) !== null && _b !== void 0 ? _b : serverlessFramework;\n      let operationDerivedDataCache = null;\n      const reportByExecutableSchemaId = new Map();\n      const getReportWhichMustBeUsedImmediately = executableSchemaId => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new stats_1.OurReport(new apollo_reporting_protobuf_1.ReportHeader({\n          ...reportHeaderDefaults,\n          executableSchemaId,\n          graphRef\n        }));\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = executableSchemaId => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n      const overriddenExecutableSchemaId = options.overrideReportedSchema ? (0, schemaReporting_1.computeCoreSchemaHash)(options.overrideReportedSchema) : undefined;\n      let lastSeenExecutableSchemaToId;\n      let reportTimer;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);\n      }\n      let graphMightSupportTraces = true;\n      const sendOperationAsTrace = (_c = options.experimental_sendOperationAsTrace) !== null && _c !== void 0 ? _c : (0, defaultSendOperationsAsTrace_1.defaultSendOperationsAsTrace)();\n      const includeTracesContributingToStats = (_d = options.internal_includeTracesContributingToStats) !== null && _d !== void 0 ? _d : false;\n      let stopped = false;\n      function executableSchemaIdForSchema(schema) {\n        if ((lastSeenExecutableSchemaToId === null || lastSeenExecutableSchemaToId === void 0 ? void 0 : lastSeenExecutableSchemaToId.executableSchema) === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = (0, schemaReporting_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id\n        };\n        return id;\n      }\n      async function sendAllReportsAndReportErrors() {\n        await Promise.all([...reportByExecutableSchemaId.keys()].map(executableSchemaId => sendReportAndReportErrors(executableSchemaId)));\n      }\n      async function sendReportAndReportErrors(executableSchemaId) {\n        return sendReport(executableSchemaId).catch(err => {\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n      const sendReport = async executableSchemaId => {\n        var _a, _b;\n        let report = getAndDeleteReport(executableSchemaId);\n        if (!report || Object.keys(report.tracesPerQuery).length === 0 && report.operationCount === 0) {\n          return;\n        }\n        report.endTime = (0, traceTreeBuilder_1.dateToProtoTimestamp)(new Date());\n        report.ensureCountsAreIntegers();\n        const protobufError = apollo_reporting_protobuf_1.Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message = apollo_reporting_protobuf_1.Report.encode(report).finish();\n        report = null;\n        if (options.debugPrintReports) {\n          const decodedReport = apollo_reporting_protobuf_1.Report.decode(message);\n          logger.warn(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);\n        }\n        const compressed = await gzipPromise(message);\n        message = null;\n        const fetcher = (_a = options.fetcher) !== null && _a !== void 0 ? _a : apollo_server_env_1.fetch;\n        const response = await (0, async_retry_1.default)(async () => {\n          var _a;\n          const controller = new node_abort_controller_1.AbortController();\n          const abortTimeout = setTimeout(() => {\n            controller.abort();\n          }, (_a = options.requestTimeoutMs) !== null && _a !== void 0 ? _a : 30000);\n          let curResponse;\n          try {\n            const requestInit = {\n              method: 'POST',\n              headers: {\n                'user-agent': 'ApolloServerPluginUsageReporting',\n                'x-api-key': key,\n                'content-encoding': 'gzip',\n                accept: 'application/json'\n              },\n              body: compressed,\n              agent: options.requestAgent\n            };\n            requestInit.signal = controller.signal;\n            curResponse = await fetcher((options.endpointUrl || 'https://usage-reporting.api.apollographql.com') + '/api/ingress/traces', requestInit);\n          } finally {\n            clearTimeout(abortTimeout);\n          }\n          if (curResponse.status >= 500 && curResponse.status < 600) {\n            throw new Error(`HTTP status ${curResponse.status}, ${(await curResponse.text()) || '(no body)'}`);\n          } else {\n            return curResponse;\n          }\n        }, {\n          retries: (options.maxAttempts || 5) - 1,\n          minTimeout: options.minimumRetryDelayMs || 100,\n          factor: 2\n        }).catch(err => {\n          throw new Error(`Error sending report to Apollo servers: ${err.message}`);\n        });\n        if (response.status < 200 || response.status >= 300) {\n          throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${(await response.text()) || '(no body)'}`);\n        }\n        if (graphMightSupportTraces && response.status === 200 && ((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.match(/^\\s*application\\/json\\s*(?:;|$)/i))) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\"This graph's organization does not have access to traces; sending all \" + 'subsequent operations as traces.');\n            graphMightSupportTraces = false;\n          }\n        }\n        if (options.debugPrintReports) {\n          logger.warn(`Apollo usage report: status ${response.status}`);\n        }\n      };\n      requestDidStartHandler = _ref2 => {\n        let {\n          logger: requestLogger,\n          metrics,\n          schema,\n          request: {\n            http,\n            variables\n          }\n        } = _ref2;\n        var _a;\n        const logger = (_a = requestLogger !== null && requestLogger !== void 0 ? requestLogger : options.logger) !== null && _a !== void 0 ? _a : serverLogger;\n        const treeBuilder = new traceTreeBuilder_1.TraceTreeBuilder({\n          rewriteError: options.rewriteError,\n          logger\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting = null;\n        if (http) {\n          treeBuilder.trace.http = new apollo_reporting_protobuf_1.Trace.HTTP({\n            method: apollo_reporting_protobuf_1.Trace.HTTP.Method[http.method] || apollo_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN,\n            host: null,\n            path: null\n          });\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);\n          }\n        }\n        async function maybeCallIncludeRequestHook(requestContext) {\n          if (includeOperationInUsageReporting !== null) return;\n          if (typeof options.includeRequest !== 'function') {\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting = await options.includeRequest(requestContext);\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\"The 'includeRequest' async predicate function must return a boolean value.\");\n            includeOperationInUsageReporting = true;\n          }\n        }\n        let didResolveSource = false;\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n            if (variables) {\n              treeBuilder.trace.details = (0, traceDetails_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);\n            }\n            const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);\n            if (clientInfo) {\n              const {\n                clientName,\n                clientVersion\n              } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async validationErrors => {\n              graphqlValidationFailure = validationErrors ? validationErrors.length !== 0 : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            graphqlUnknownOperationName = requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n            if (includeOperationInUsageReporting && !graphqlUnknownOperationName) {\n              if (metrics.captureTraces === undefined) {\n                const rawWeight = await fieldLevelInstrumentation(requestContext);\n                treeBuilder.trace.fieldExecutionWeight = typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n                metrics.captureTraces = !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            if (!metrics.captureTraces) return;\n            return {\n              willResolveField(_ref3) {\n                let {\n                  info\n                } = _ref3;\n                return treeBuilder.willResolveField(info);\n              }\n            };\n          },\n          async willSendResponse(requestContext) {\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n            const resolvedOperation = !!requestContext.operation;\n            await maybeCallIncludeRequestHook(requestContext);\n            treeBuilder.stopTiming();\n            const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);\n            if (includeOperationInUsageReporting === false) {\n              if (resolvedOperation) getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;\n              return;\n            }\n            treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n            treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n            treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;\n            const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();\n            if (policyIfCacheable) {\n              treeBuilder.trace.cachePolicy = new apollo_reporting_protobuf_1.Trace.CachePolicy({\n                scope: policyIfCacheable.scope === apollo_server_types_1.CacheScope.Private ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE : policyIfCacheable.scope === apollo_server_types_1.CacheScope.Public ? apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC : apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,\n                maxAgeNs: policyIfCacheable.maxAge * 1e9\n              });\n            }\n            if (metrics.queryPlanTrace) {\n              treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n            }\n            addTrace().catch(logger.error);\n            async function addTrace() {\n              if (stopped) {\n                return;\n              }\n              await new Promise(res => setImmediate(res));\n              const executableSchemaId = overriddenExecutableSchemaId !== null && overriddenExecutableSchemaId !== void 0 ? overriddenExecutableSchemaId : executableSchemaIdForSchema(schema);\n              const {\n                trace\n              } = treeBuilder;\n              let statsReportKey = undefined;\n              let referencedFieldsByType;\n              if (!requestContext.document) {\n                statsReportKey = `## GraphQLParseFailure\\n`;\n              } else if (graphqlValidationFailure) {\n                statsReportKey = `## GraphQLValidationFailure\\n`;\n              } else if (graphqlUnknownOperationName) {\n                statsReportKey = `## GraphQLUnknownOperationName\\n`;\n              }\n              const isExecutable = statsReportKey === undefined;\n              if (statsReportKey) {\n                if (options.sendUnexecutableOperationDocuments) {\n                  trace.unexecutedOperationBody = requestContext.source;\n                  trace.unexecutedOperationName = requestContext.request.operationName || '';\n                }\n                referencedFieldsByType = Object.create(null);\n              } else {\n                const operationDerivedData = getOperationDerivedData();\n                statsReportKey = `# ${requestContext.operationName || '-'}\\n${operationDerivedData.signature}`;\n                referencedFieldsByType = operationDerivedData.referencedFieldsByType;\n              }\n              const protobufError = apollo_reporting_protobuf_1.Trace.verify(trace);\n              if (protobufError) {\n                throw new Error(`Error encoding trace: ${protobufError}`);\n              }\n              if (resolvedOperation) {\n                getReportWhichMustBeUsedImmediately(executableSchemaId).operationCount++;\n              }\n              getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n                statsReportKey,\n                trace,\n                asTrace: graphMightSupportTraces && (!isExecutable || !!metrics.captureTraces) && sendOperationAsTrace(trace, statsReportKey),\n                includeTracesContributingToStats,\n                referencedFieldsByType\n              });\n              if (sendReportsImmediately || getReportWhichMustBeUsedImmediately(executableSchemaId).sizeEstimator.bytes >= (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {\n                await sendReportAndReportErrors(executableSchemaId);\n              }\n            }\n            function getOperationDerivedData() {\n              var _a;\n              if (!requestContext.document) {\n                throw new Error('No document?');\n              }\n              const cacheKey = (0, operationDerivedDataCache_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || '');\n              if (!operationDerivedDataCache || operationDerivedDataCache.forSchema !== schema) {\n                operationDerivedDataCache = {\n                  forSchema: schema,\n                  cache: (0, operationDerivedDataCache_1.createOperationDerivedDataCache)({\n                    logger\n                  })\n                };\n              }\n              const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);\n              if (cachedOperationDerivedData) {\n                return cachedOperationDerivedData;\n              }\n              const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || '');\n              const generatedOperationDerivedData = {\n                signature: generatedSignature,\n                referencedFieldsByType: (0, utils_usagereporting_2.calculateReferencedFieldsByType)({\n                  document: requestContext.document,\n                  schema,\n                  resolvedOperationName: (_a = requestContext.operationName) !== null && _a !== void 0 ? _a : null\n                })\n              };\n              operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);\n              return generatedOperationDerivedData;\n            }\n          }\n        };\n      };\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        }\n      };\n    }\n  };\n}\nexports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;\nfunction makeHTTPRequestHeaders(http, headers, sendHeaders) {\n  if (!sendHeaders || 'none' in sendHeaders && sendHeaders.none || 'all' in sendHeaders && !sendHeaders.all) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    const lowerCaseKey = key.toLowerCase();\n    if ('exceptNames' in sendHeaders && sendHeaders.exceptNames.some(exceptHeader => {\n      return exceptHeader.toLowerCase() === lowerCaseKey;\n    }) || 'onlyNames' in sendHeaders && !sendHeaders.onlyNames.some(header => {\n      return header.toLowerCase() === lowerCaseKey;\n    })) {\n      continue;\n    }\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http.requestHeaders[key] = new apollo_reporting_protobuf_1.Trace.HTTP.Values({\n          value: [value]\n        });\n    }\n  }\n}\nexports.makeHTTPRequestHeaders = makeHTTPRequestHeaders;\nfunction defaultGenerateClientInfo(_ref4) {\n  let {\n    request\n  } = _ref4;\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n  if (((_b = (_a = request.http) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b.get(clientNameHeaderKey)) || ((_d = (_c = request.http) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.get(clientVersionHeaderKey))) {\n    return {\n      clientName: (_f = (_e = request.http) === null || _e === void 0 ? void 0 : _e.headers) === null || _f === void 0 ? void 0 : _f.get(clientNameHeaderKey),\n      clientVersion: (_h = (_g = request.http) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.get(clientVersionHeaderKey)\n    };\n  } else if ((_j = request.extensions) === null || _j === void 0 ? void 0 : _j.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\nfunction ApolloServerPluginUsageReportingDisabled() {\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    }\n  };\n}\nexports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;","map":{"version":3,"mappings":"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","names":["gzipPromise","zlib_1","reportHeaderDefaults","hostname","os_1","agentVersion","require","version","runtimeVersion","process","uname","platform","type","release","arch","ApolloServerPluginUsageReporting","options","Object","create","fieldLevelInstrumentationOption","fieldLevelInstrumentation","Math","random","requestDidStartHandler","__internal_plugin_id__","requestDidStart","requestContext","Error","serverWillStart","logger","serverLogger","apollo","serverlessFramework","key","graphRef","info","encodeURI","sendReportsImmediately","operationDerivedDataCache","reportByExecutableSchemaId","Map","getReportWhichMustBeUsedImmediately","executableSchemaId","existing","get","report","stats_1","apollo_reporting_protobuf_1","set","getAndDeleteReport","delete","overriddenExecutableSchemaId","overrideReportedSchema","undefined","lastSeenExecutableSchemaToId","reportTimer","setInterval","sendAllReportsAndReportErrors","reportIntervalMs","graphMightSupportTraces","sendOperationAsTrace","experimental_sendOperationAsTrace","includeTracesContributingToStats","internal_includeTracesContributingToStats","stopped","executableSchemaIdForSchema","schema","executableSchema","id","Promise","all","keys","map","sendReportAndReportErrors","sendReport","catch","err","reportErrorFunction","error","message","tracesPerQuery","length","operationCount","endTime","Date","ensureCountsAreIntegers","protobufError","verify","encode","finish","debugPrintReports","decodedReport","decode","warn","JSON","stringify","toJSON","compressed","fetcher","apollo_server_env_1","response","controller","node_abort_controller_1","abortTimeout","setTimeout","abort","requestTimeoutMs","curResponse","requestInit","method","headers","accept","body","agent","requestAgent","signal","endpointUrl","clearTimeout","status","text","retries","maxAttempts","minTimeout","minimumRetryDelayMs","factor","match","parsedBody","parse","e","tracesIgnored","debug","requestLogger","metrics","request","http","variables","treeBuilder","traceTreeBuilder_1","rewriteError","startTiming","startHrTime","graphqlValidationFailure","graphqlUnknownOperationName","includeOperationInUsageReporting","trace","HTTP","Method","UNKNOWN","host","path","sendHeaders","makeHTTPRequestHeaders","maybeCallIncludeRequestHook","includeRequest","didResolveSource","persistedQueryHit","persistedQueryRegister","details","sendVariableValues","source","clientInfo","generateClientInfo","defaultGenerateClientInfo","clientName","clientVersion","validationDidStart","validationErrors","didResolveOperation","operation","captureTraces","rawWeight","fieldExecutionWeight","executionDidStart","willResolveField","willSendResponse","errors","didEncounterErrors","resolvedOperation","stopTiming","fullQueryCacheHit","responseCacheHit","forbiddenOperation","registeredOperation","policyIfCacheable","overallCachePolicy","cachePolicy","CachePolicy","scope","apollo_server_types_1","Private","Scope","PRIVATE","Public","PUBLIC","maxAgeNs","maxAge","queryPlanTrace","queryPlan","addTrace","res","setImmediate","statsReportKey","referencedFieldsByType","document","isExecutable","sendUnexecutableOperationDocuments","unexecutedOperationBody","unexecutedOperationName","operationName","operationDerivedData","getOperationDerivedData","signature","asTrace","sizeEstimator","bytes","maxUncompressedReportSize","cacheKey","queryHash","forSchema","cache","cachedOperationDerivedData","generatedSignature","calculateSignature","utils_usagereporting_1","generatedOperationDerivedData","resolvedOperationName","serverWillStop","clearInterval","exports","none","value","lowerCaseKey","toLowerCase","exceptNames","some","exceptHeader","onlyNames","header","requestHeaders","Values","clientNameHeaderKey","clientVersionHeaderKey","extensions","ApolloServerPluginUsageReportingDisabled"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\plugin.ts"],"sourcesContent":["import os from 'os';\nimport { promisify } from 'util';\nimport { gzip } from 'zlib';\nimport retry from 'async-retry';\nimport { Report, ReportHeader, Trace } from 'apollo-reporting-protobuf';\nimport { Response, fetch, Headers, RequestInit } from 'apollo-server-env';\nimport { AbortController } from 'node-abort-controller';\nimport type {\n  GraphQLRequestListener,\n  GraphQLServerListener,\n} from 'apollo-server-plugin-base';\nimport {\n  CacheScope,\n  GraphQLRequestContext,\n  GraphQLServiceContext,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextWillSendResponse,\n  BaseContext,\n} from 'apollo-server-types';\nimport {\n  createOperationDerivedDataCache,\n  OperationDerivedData,\n  operationDerivedDataCacheKey,\n} from './operationDerivedDataCache';\nimport { usageReportingSignature } from '@apollo/utils.usagereporting';\nimport type {\n  ApolloServerPluginUsageReportingOptions,\n  SendValuesBaseOptions,\n} from './options';\nimport { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder';\nimport { makeTraceDetails } from './traceDetails';\nimport { GraphQLSchema, printSchema } from 'graphql';\nimport { computeCoreSchemaHash } from '../schemaReporting';\nimport type { InternalApolloServerPlugin } from '../../internalPlugin';\nimport { OurReport } from './stats';\nimport { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace';\nimport {\n  calculateReferencedFieldsByType,\n  ReferencedFieldsByType,\n} from '@apollo/utils.usagereporting';\nimport type LRUCache from 'lru-cache';\n\nconst gzipPromise = promisify(gzip);\n\nconst reportHeaderDefaults = {\n  hostname: os.hostname(),\n  agentVersion: `apollo-server-core@${\n    require('../../../package.json').version\n  }`,\n  runtimeVersion: `node ${process.version}`,\n  // XXX not actually uname, but what node has easily.\n  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,\n};\n\nexport function ApolloServerPluginUsageReporting<TContext extends BaseContext>(\n  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(\n    null,\n  ),\n): InternalApolloServerPlugin {\n  // Note: We'd like to change the default to false in Apollo Server 4, so that\n  // the default usage reporting experience doesn't include *anything* that\n  // could potentially be PII (like error messages) --- just operations and\n  // numbers.\n  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;\n  const fieldLevelInstrumentation =\n    typeof fieldLevelInstrumentationOption === 'number'\n      ? async () =>\n          Math.random() < fieldLevelInstrumentationOption\n            ? 1 / fieldLevelInstrumentationOption\n            : 0\n      : fieldLevelInstrumentationOption\n      ? fieldLevelInstrumentationOption\n      : async () => true;\n\n  let requestDidStartHandler: (\n    requestContext: GraphQLRequestContext<TContext>,\n  ) => GraphQLRequestListener<TContext>;\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n\n    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus\n    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain\n    // a requestDidStart?)\n    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {\n      if (!requestDidStartHandler) {\n        throw Error(\n          'The usage reporting plugin has been asked to handle a request before the ' +\n            'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' +\n            'for more details.',\n        );\n      }\n      return requestDidStartHandler(requestContext);\n    },\n\n    async serverWillStart({\n      logger: serverLogger,\n      apollo,\n      serverlessFramework,\n    }: GraphQLServiceContext): Promise<GraphQLServerListener> {\n      // Use the plugin-specific logger if one is provided; otherwise the general server one.\n      const logger = options.logger ?? serverLogger;\n      const { key, graphRef } = apollo;\n      if (!(key && graphRef)) {\n        throw new Error(\n          \"You've enabled usage reporting via ApolloServerPluginUsageReporting, \" +\n            'but you also need to provide your Apollo API key and graph ref, via ' +\n            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +\n            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',\n        );\n      }\n\n      logger.info(\n        'Apollo usage reporting starting! See your graph at ' +\n          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,\n      );\n\n      // If sendReportsImmediately is not specified, we default to true if we're running\n      // with the ApolloServer designed for Lambda or similar. That's because these\n      // environments aren't designed around letting us run a background task to\n      // send reports later or hook into container destruction to flush buffered reports.\n      const sendReportsImmediately =\n        options.sendReportsImmediately ?? serverlessFramework;\n\n      // Since calculating the signature and referenced fields for usage\n      // reporting is potentially an expensive operation, we'll cache the data\n      // we generate and re-use them for repeated operations for the same\n      // `queryHash`. However, because referenced fields depend on the current\n      // schema, we want to throw it out entirely any time the schema changes.\n      let operationDerivedDataCache: {\n        forSchema: GraphQLSchema;\n        cache: LRUCache<string, OperationDerivedData>;\n      } | null = null;\n\n      // This map maps from executable schema ID (schema hash, basically) to the\n      // report we'll send about it. That's because when we're using a gateway,\n      // the schema can change over time, but each report needs to be about a\n      // single schema. We avoid having this function be a memory leak by\n      // removing values from it when we're in the process of sending reports.\n      // That means we have to be very careful never to pull a Report out of it\n      // and hang on to it for a while before writing to it, because the report\n      // might have gotten sent and discarded in the meantime. So you should\n      // only access the values of this Map via\n      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never\n      // hang on to the value returned by getReportWhichMustBeUsedImmediately.\n      const reportByExecutableSchemaId = new Map<string, OurReport>();\n      const getReportWhichMustBeUsedImmediately = (\n        executableSchemaId: string,\n      ): OurReport => {\n        const existing = reportByExecutableSchemaId.get(executableSchemaId);\n        if (existing) {\n          return existing;\n        }\n        const report = new OurReport(\n          new ReportHeader({\n            ...reportHeaderDefaults,\n            executableSchemaId,\n            graphRef,\n          }),\n        );\n        reportByExecutableSchemaId.set(executableSchemaId, report);\n        return report;\n      };\n      const getAndDeleteReport = (\n        executableSchemaId: string,\n      ): OurReport | null => {\n        const report = reportByExecutableSchemaId.get(executableSchemaId);\n        if (report) {\n          reportByExecutableSchemaId.delete(executableSchemaId);\n          return report;\n        }\n        return null;\n      };\n\n      const overriddenExecutableSchemaId = options.overrideReportedSchema\n        ? computeCoreSchemaHash(options.overrideReportedSchema)\n        : undefined;\n\n      let lastSeenExecutableSchemaToId:\n        | {\n            executableSchema: GraphQLSchema;\n            executableSchemaId: string;\n          }\n        | undefined;\n\n      let reportTimer: NodeJS.Timer | undefined;\n      if (!sendReportsImmediately) {\n        reportTimer = setInterval(\n          () => sendAllReportsAndReportErrors(),\n          options.reportIntervalMs || 10 * 1000,\n        );\n      }\n\n      let graphMightSupportTraces = true;\n      const sendOperationAsTrace =\n        options.experimental_sendOperationAsTrace ??\n        defaultSendOperationsAsTrace();\n      const includeTracesContributingToStats =\n        options.internal_includeTracesContributingToStats ?? false;\n\n      let stopped = false;\n\n      function executableSchemaIdForSchema(schema: GraphQLSchema) {\n        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {\n          return lastSeenExecutableSchemaToId.executableSchemaId;\n        }\n        const id = computeCoreSchemaHash(printSchema(schema));\n\n        // We override this variable every time we get a new schema so we cache\n        // the last seen value. It is a single-entry cache.\n        lastSeenExecutableSchemaToId = {\n          executableSchema: schema,\n          executableSchemaId: id,\n        };\n\n        return id;\n      }\n\n      async function sendAllReportsAndReportErrors(): Promise<void> {\n        await Promise.all(\n          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>\n            sendReportAndReportErrors(executableSchemaId),\n          ),\n        );\n      }\n\n      async function sendReportAndReportErrors(\n        executableSchemaId: string,\n      ): Promise<void> {\n        return sendReport(executableSchemaId).catch((err) => {\n          // This catch block is primarily intended to catch network errors from\n          // the retried request itself, which include network errors and non-2xx\n          // HTTP errors.\n          if (options.reportErrorFunction) {\n            options.reportErrorFunction(err);\n          } else {\n            logger.error(err.message);\n          }\n        });\n      }\n\n      // Needs to be an arrow function to be confident that key is defined.\n      const sendReport = async (executableSchemaId: string): Promise<void> => {\n        let report = getAndDeleteReport(executableSchemaId);\n        if (\n          !report ||\n          (Object.keys(report.tracesPerQuery).length === 0 &&\n            report.operationCount === 0)\n        ) {\n          return;\n        }\n\n        // Set the report's overall end time. This is the timestamp that will be\n        // associated with the summarized statistics.\n        report.endTime = dateToProtoTimestamp(new Date());\n\n        report.ensureCountsAreIntegers();\n\n        const protobufError = Report.verify(report);\n        if (protobufError) {\n          throw new Error(`Error verifying report: ${protobufError}`);\n        }\n        let message: Uint8Array | null = Report.encode(report).finish();\n        // Let the original protobuf object be garbage collected (helpful if the\n        // HTTP request hangs).\n        report = null;\n\n        // Potential follow-up: we can compare message.length to\n        // report.sizeEstimator.bytes and use it to \"learn\" if our estimation is\n        // off and adjust it based on what we learn.\n\n        if (options.debugPrintReports) {\n          // In terms of verbosity, and as the name of this option suggests,\n          // this message is either an \"info\" or a \"debug\" level message.\n          // However, we are using `warn` here for compatibility reasons since\n          // the `debugPrintReports` flag pre-dated the existence of log-levels\n          // and changing this to also require `debug: true` (in addition to\n          // `debugPrintReports`) just to reach the level of verbosity to\n          // produce the output would be a breaking change.  The \"warn\" level is\n          // on by default.  There is a similar theory and comment applied\n          // below.\n          //\n          // We decode the report rather than printing the original `report`\n          // so that it includes all of the pre-encoded traces.\n          const decodedReport = Report.decode(message);\n          logger.warn(\n            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,\n          );\n        }\n\n        const compressed = await gzipPromise(message);\n        // Let the uncompressed message be garbage collected (helpful if the\n        // HTTP request is slow).\n        message = null;\n\n        // Wrap fetcher with async-retry for automatic retrying\n        const fetcher = options.fetcher ?? fetch;\n        const response: Response = await retry(\n          // Retry on network errors and 5xx HTTP\n          // responses.\n          async () => {\n            // Note that once we require Node v16 we can use its global\n            // AbortController instead of the one from `node-abort-controller`.\n            const controller = new AbortController();\n            const abortTimeout = setTimeout(() => {\n              controller.abort();\n            }, options.requestTimeoutMs ?? 30_000);\n            let curResponse;\n            try {\n              const requestInit: RequestInit = {\n                method: 'POST',\n                headers: {\n                  'user-agent': 'ApolloServerPluginUsageReporting',\n                  'x-api-key': key,\n                  'content-encoding': 'gzip',\n                  accept: 'application/json',\n                },\n                body: compressed,\n                agent: options.requestAgent,\n              };\n              // The apollo-server-env Fetch API doesn't have `signal` in\n              // RequestInit, but it does work in node-fetch. We've added it\n              // already to our `Fetcher` interface (`@apollo/utils.fetcher`)\n              // that we're using in AS4 but making changes to\n              // `apollo-server-env` that could cause custom AS3 fetchers to not\n              // compile feels like a bad idea. The worst case scenario of\n              // passing in an ignored `signal` is the timeout doesn't work, in\n              // which case you're not getting the new feature but can change\n              // your fetcher to make it work.\n              (requestInit as any).signal = controller.signal;\n              curResponse = await fetcher(\n                (options.endpointUrl ||\n                  'https://usage-reporting.api.apollographql.com') +\n                  '/api/ingress/traces',\n                requestInit,\n              );\n            } finally {\n              clearTimeout(abortTimeout);\n            }\n\n            if (curResponse.status >= 500 && curResponse.status < 600) {\n              throw new Error(\n                `HTTP status ${curResponse.status}, ${\n                  (await curResponse.text()) || '(no body)'\n                }`,\n              );\n            } else {\n              return curResponse;\n            }\n          },\n          {\n            retries: (options.maxAttempts || 5) - 1,\n            minTimeout: options.minimumRetryDelayMs || 100,\n            factor: 2,\n          },\n        ).catch((err: Error) => {\n          throw new Error(\n            `Error sending report to Apollo servers: ${err.message}`,\n          );\n        });\n\n        if (response.status < 200 || response.status >= 300) {\n          // Note that we don't expect to see a 3xx here because request follows\n          // redirects.\n          throw new Error(\n            `Error sending report to Apollo servers: HTTP status ${\n              response.status\n            }, ${(await response.text()) || '(no body)'}`,\n          );\n        }\n\n        if (\n          graphMightSupportTraces &&\n          response.status === 200 &&\n          response.headers\n            .get('content-type')\n            ?.match(/^\\s*application\\/json\\s*(?:;|$)/i)\n        ) {\n          const body = await response.text();\n          let parsedBody;\n          try {\n            parsedBody = JSON.parse(body);\n          } catch (e) {\n            throw new Error(`Error parsing response from Apollo servers: ${e}`);\n          }\n          if (parsedBody.tracesIgnored === true) {\n            logger.debug(\n              \"This graph's organization does not have access to traces; sending all \" +\n                'subsequent operations as traces.',\n            );\n            graphMightSupportTraces = false;\n            // XXX We could also parse traces that are already in the current\n            // report and convert them to stats if we wanted?\n          }\n        }\n        if (options.debugPrintReports) {\n          // In terms of verbosity, and as the name of this option suggests, this\n          // message is either an \"info\" or a \"debug\" level message.  However,\n          // we are using `warn` here for compatibility reasons since the\n          // `debugPrintReports` flag pre-dated the existence of log-levels and\n          // changing this to also require `debug: true` (in addition to\n          // `debugPrintReports`) just to reach the level of verbosity to produce\n          // the output would be a breaking change.  The \"warn\" level is on by\n          // default.  There is a similar theory and comment applied above.\n          logger.warn(`Apollo usage report: status ${response.status}`);\n        }\n      };\n\n      requestDidStartHandler = ({\n        logger: requestLogger,\n        metrics,\n        schema,\n        request: { http, variables },\n      }): GraphQLRequestListener<TContext> => {\n        // Request specific log output should go into the `logger` from the\n        // request context when it's provided.\n        const logger = requestLogger ?? options.logger ?? serverLogger;\n        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({\n          rewriteError: options.rewriteError,\n          logger,\n        });\n        treeBuilder.startTiming();\n        metrics.startHrTime = treeBuilder.startHrTime;\n        let graphqlValidationFailure = false;\n        let graphqlUnknownOperationName = false;\n        let includeOperationInUsageReporting: boolean | null = null;\n\n        if (http) {\n          treeBuilder.trace.http = new Trace.HTTP({\n            method:\n              Trace.HTTP.Method[\n                http.method as keyof typeof Trace.HTTP.Method\n              ] || Trace.HTTP.Method.UNKNOWN,\n            // Host and path are not used anywhere on the backend, so let's not bother\n            // trying to parse request.url to get them, which is a potential\n            // source of bugs because integrations have different behavior here.\n            // On Node's HTTP module, request.url only includes the path\n            // (see https://nodejs.org/api/http.html#http_message_url)\n            // The same is true on Lambda (where we pass event.path)\n            // But on environments like Cloudflare we do get a complete URL.\n            host: null,\n            path: null,\n          });\n\n          if (options.sendHeaders) {\n            makeHTTPRequestHeaders(\n              treeBuilder.trace.http,\n              http.headers,\n              options.sendHeaders,\n            );\n          }\n        }\n\n        // After this function completes, includeOperationInUsageReporting is\n        // defined.\n        async function maybeCallIncludeRequestHook(\n          requestContext:\n            | GraphQLRequestContextDidResolveOperation<TContext>\n            | GraphQLRequestContextWillSendResponse<TContext>,\n        ): Promise<void> {\n          // If this is the second call in `willSendResponse` after\n          // `didResolveOperation`, we're done.\n          if (includeOperationInUsageReporting !== null) return;\n\n          if (typeof options.includeRequest !== 'function') {\n            // Default case we always report\n            includeOperationInUsageReporting = true;\n            return;\n          }\n          includeOperationInUsageReporting = await options.includeRequest(\n            requestContext,\n          );\n\n          // Help the user understand they've returned an unexpected value,\n          // which might be a subtle mistake.\n          if (typeof includeOperationInUsageReporting !== 'boolean') {\n            logger.warn(\n              \"The 'includeRequest' async predicate function must return a boolean value.\",\n            );\n            includeOperationInUsageReporting = true;\n          }\n        }\n\n        // Our usage reporting groups everything by operation, so we don't\n        // actually report about any issues that prevent us from getting an\n        // operation string (eg, a missing operation, or APQ problems).\n        // This is effectively bypassing the reporting of:\n        //   - PersistedQueryNotFoundError\n        //   - PersistedQueryNotSupportedError\n        //   - Missing `query` error\n        // We may want to report them some other way later!\n        let didResolveSource: boolean = false;\n\n        return {\n          async didResolveSource(requestContext) {\n            didResolveSource = true;\n\n            if (metrics.persistedQueryHit) {\n              treeBuilder.trace.persistedQueryHit = true;\n            }\n            if (metrics.persistedQueryRegister) {\n              treeBuilder.trace.persistedQueryRegister = true;\n            }\n\n            if (variables) {\n              treeBuilder.trace.details = makeTraceDetails(\n                variables,\n                options.sendVariableValues,\n                requestContext.source,\n              );\n            }\n\n            const clientInfo = (\n              options.generateClientInfo || defaultGenerateClientInfo\n            )(requestContext);\n            if (clientInfo) {\n              // While there is a clientAddress protobuf field, the backend\n              // doesn't pay attention to it yet, so we'll ignore it for now.\n              const { clientName, clientVersion } = clientInfo;\n              treeBuilder.trace.clientVersion = clientVersion || '';\n              treeBuilder.trace.clientName = clientName || '';\n            }\n          },\n          async validationDidStart() {\n            return async (validationErrors?: ReadonlyArray<Error>) => {\n              graphqlValidationFailure = validationErrors\n                ? validationErrors.length !== 0\n                : false;\n            };\n          },\n          async didResolveOperation(requestContext) {\n            // If operation is undefined then `getOperationAST` returned null\n            // and an unknown operation was specified.\n            graphqlUnknownOperationName =\n              requestContext.operation === undefined;\n            await maybeCallIncludeRequestHook(requestContext);\n\n            if (\n              includeOperationInUsageReporting &&\n              // No need to capture traces if the operation is going to\n              // immediately fail due to unknown operation name.\n              !graphqlUnknownOperationName\n            ) {\n              if (metrics.captureTraces === undefined) {\n                // We're not completely ignoring the operation. But should we\n                // calculate a detailed trace of every field while we do so (either\n                // directly in this plugin, or in a subgraph by sending the\n                // apollo-federation-include-trace header)? That will allow this\n                // operation to contribute to the \"field executions\" column in the\n                // Studio Fields page, to the timing hints in Explorer and\n                // vscode-graphql, and to the traces visible under Operations. (Note\n                // that `true` here does not imply that this operation will\n                // necessarily be *sent* to the usage-reporting endpoint in the form\n                // of a trace --- it still might be aggregated into stats first. But\n                // capturing a trace will mean we can understand exactly what fields\n                // were executed and what their performance was, at the tradeoff of\n                // some overhead for tracking the trace (and transmitting it between\n                // subgraph and gateway).\n                const rawWeight = await fieldLevelInstrumentation(\n                  requestContext,\n                );\n                treeBuilder.trace.fieldExecutionWeight =\n                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;\n\n                metrics.captureTraces =\n                  !!treeBuilder.trace.fieldExecutionWeight;\n              }\n            }\n          },\n          async executionDidStart() {\n            // If we're not capturing traces, don't return a willResolveField so\n            // that we don't build up a detailed trace inside treeBuilder. (We still\n            // will use treeBuilder as a convenient place to put top-level facts\n            // about the operation which can end up aggregated as stats, and we do\n            // eventually put *errors* onto the trace tree.)\n            if (!metrics.captureTraces) return;\n\n            return {\n              willResolveField({ info }) {\n                return treeBuilder.willResolveField(info);\n                // We could save the error into the trace during the end handler, but\n                // it won't have all the information that graphql-js adds to it later,\n                // like 'locations'.\n              },\n            };\n          },\n          async willSendResponse(requestContext) {\n            // Search above for a comment about \"didResolveSource\" to see which\n            // of the pre-source-resolution errors we are intentionally avoiding.\n            if (!didResolveSource) return;\n            if (requestContext.errors) {\n              treeBuilder.didEncounterErrors(requestContext.errors);\n            }\n\n            const resolvedOperation = !!requestContext.operation;\n\n            // If we got an error before we called didResolveOperation (eg parse or\n            // validation error), check to see if we should include the request.\n            await maybeCallIncludeRequestHook(requestContext);\n\n            treeBuilder.stopTiming();\n            const executableSchemaId =\n              overriddenExecutableSchemaId ??\n              executableSchemaIdForSchema(schema);\n\n            if (includeOperationInUsageReporting === false) {\n              if (resolvedOperation)\n                getReportWhichMustBeUsedImmediately(executableSchemaId)\n                  .operationCount++;\n              return;\n            }\n\n            treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;\n            treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;\n            treeBuilder.trace.registeredOperation =\n              !!metrics.registeredOperation;\n\n            const policyIfCacheable =\n              requestContext.overallCachePolicy.policyIfCacheable();\n            if (policyIfCacheable) {\n              treeBuilder.trace.cachePolicy = new Trace.CachePolicy({\n                scope:\n                  policyIfCacheable.scope === CacheScope.Private\n                    ? Trace.CachePolicy.Scope.PRIVATE\n                    : policyIfCacheable.scope === CacheScope.Public\n                    ? Trace.CachePolicy.Scope.PUBLIC\n                    : Trace.CachePolicy.Scope.UNKNOWN,\n                // Convert from seconds to ns.\n                maxAgeNs: policyIfCacheable.maxAge * 1e9,\n              });\n            }\n\n            // If this was a federated operation and we're the gateway, add the query plan\n            // to the trace.\n            if (metrics.queryPlanTrace) {\n              treeBuilder.trace.queryPlan = metrics.queryPlanTrace;\n            }\n\n            // Intentionally un-awaited so as not to block the response.  Any\n            // errors will be logged, but will not manifest a user-facing error.\n            // The logger in this case is a request specific logger OR the logger\n            // defined by the plugin if that's unavailable.  The request-specific\n            // logger is preferred since this is very much coupled directly to a\n            // client-triggered action which might be more granularly tagged by\n            // logging implementations.\n            addTrace().catch(logger.error);\n\n            async function addTrace(): Promise<void> {\n              // Ignore traces that come in after stop().\n              if (stopped) {\n                return;\n              }\n\n              // Ensure that the caller of addTrace (which does not await it) is\n              // not blocked. We use setImmediate rather than process.nextTick or\n              // just relying on the Promise microtask queue because setImmediate\n              // comes after IO, which is what we want.\n              await new Promise((res) => setImmediate(res));\n\n              const executableSchemaId =\n                overriddenExecutableSchemaId ??\n                executableSchemaIdForSchema(schema);\n\n              const { trace } = treeBuilder;\n\n              let statsReportKey: string | undefined = undefined;\n              let referencedFieldsByType: ReferencedFieldsByType;\n              if (!requestContext.document) {\n                statsReportKey = `## GraphQLParseFailure\\n`;\n              } else if (graphqlValidationFailure) {\n                statsReportKey = `## GraphQLValidationFailure\\n`;\n              } else if (graphqlUnknownOperationName) {\n                statsReportKey = `## GraphQLUnknownOperationName\\n`;\n              }\n\n              const isExecutable = statsReportKey === undefined;\n\n              if (statsReportKey) {\n                if (options.sendUnexecutableOperationDocuments) {\n                  trace.unexecutedOperationBody = requestContext.source;\n                  // Get the operation name from the request (which might not\n                  // correspond to an actual operation).\n                  trace.unexecutedOperationName =\n                    requestContext.request.operationName || '';\n                }\n                referencedFieldsByType = Object.create(null);\n              } else {\n                const operationDerivedData = getOperationDerivedData();\n                statsReportKey = `# ${requestContext.operationName || '-'}\\n${\n                  operationDerivedData.signature\n                }`;\n                referencedFieldsByType =\n                  operationDerivedData.referencedFieldsByType;\n              }\n\n              const protobufError = Trace.verify(trace);\n              if (protobufError) {\n                throw new Error(`Error encoding trace: ${protobufError}`);\n              }\n\n              if (resolvedOperation) {\n                getReportWhichMustBeUsedImmediately(executableSchemaId)\n                  .operationCount++;\n              }\n\n              getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({\n                statsReportKey,\n                trace,\n                // We include the operation as a trace (rather than aggregated\n                // into stats) only if we believe it's possible that our\n                // organization's plan allows for viewing traces *and* we\n                // actually captured this as a full trace *and*\n                // sendOperationAsTrace says so.\n                //\n                // (As an edge case, if the reason metrics.captureTraces is\n                // falsey is that this is an unexecutable operation and thus we\n                // never ran the code in didResolveOperation that sets\n                // metrics.captureTrace, we allow it to be sent as a trace. This\n                // means we'll still send some parse and validation failures as\n                // traces, for the sake of the Errors page.)\n                asTrace:\n                  graphMightSupportTraces &&\n                  (!isExecutable || !!metrics.captureTraces) &&\n                  sendOperationAsTrace(trace, statsReportKey),\n                includeTracesContributingToStats,\n                referencedFieldsByType,\n              });\n\n              // If the buffer gets big (according to our estimate), send.\n              if (\n                sendReportsImmediately ||\n                getReportWhichMustBeUsedImmediately(executableSchemaId)\n                  .sizeEstimator.bytes >=\n                  (options.maxUncompressedReportSize || 4 * 1024 * 1024)\n              ) {\n                await sendReportAndReportErrors(executableSchemaId);\n              }\n            }\n\n            // Calculates signature and referenced fields for the current document.\n            // Only call this when the document properly parses and validates and\n            // the given operation name (if any) is known!\n            function getOperationDerivedData(): OperationDerivedData {\n              if (!requestContext.document) {\n                // This shouldn't happen: no document means parse failure, which\n                // uses its own special statsReportKey.\n                throw new Error('No document?');\n              }\n\n              const cacheKey = operationDerivedDataCacheKey(\n                requestContext.queryHash,\n                requestContext.operationName || '',\n              );\n\n              // Ensure that the cache we have is for the right schema.\n              if (\n                !operationDerivedDataCache ||\n                operationDerivedDataCache.forSchema !== schema\n              ) {\n                operationDerivedDataCache = {\n                  forSchema: schema,\n                  cache: createOperationDerivedDataCache({ logger }),\n                };\n              }\n\n              // If we didn't have the signature in the cache, we'll resort to\n              // calculating it.\n              const cachedOperationDerivedData =\n                operationDerivedDataCache.cache.get(cacheKey);\n              if (cachedOperationDerivedData) {\n                return cachedOperationDerivedData;\n              }\n\n              const generatedSignature = (\n                options.calculateSignature || usageReportingSignature\n              )(requestContext.document, requestContext.operationName || '');\n\n              const generatedOperationDerivedData: OperationDerivedData = {\n                signature: generatedSignature,\n                referencedFieldsByType: calculateReferencedFieldsByType({\n                  document: requestContext.document,\n                  schema,\n                  resolvedOperationName: requestContext.operationName ?? null,\n                }),\n              };\n\n              // Note that this cache is always an in-memory cache.\n              // If we replace it with a more generic async cache, we should\n              // not await the write operation.\n              operationDerivedDataCache.cache.set(\n                cacheKey,\n                generatedOperationDerivedData,\n              );\n              return generatedOperationDerivedData;\n            }\n          },\n        };\n      };\n\n      return {\n        async serverWillStop() {\n          if (reportTimer) {\n            clearInterval(reportTimer);\n            reportTimer = undefined;\n          }\n\n          stopped = true;\n          await sendAllReportsAndReportErrors();\n        },\n      };\n    },\n  };\n}\n\nexport function makeHTTPRequestHeaders(\n  http: Trace.IHTTP,\n  headers: Headers,\n  sendHeaders?: SendValuesBaseOptions,\n): void {\n  if (\n    !sendHeaders ||\n    ('none' in sendHeaders && sendHeaders.none) ||\n    ('all' in sendHeaders && !sendHeaders.all)\n  ) {\n    return;\n  }\n  for (const [key, value] of headers) {\n    const lowerCaseKey = key.toLowerCase();\n    if (\n      ('exceptNames' in sendHeaders &&\n        // We assume that most users only have a few headers to hide, or will\n        // just set {none: true} ; we can change this linear-time\n        // operation if it causes real performance issues.\n        sendHeaders.exceptNames.some((exceptHeader) => {\n          // Headers are case-insensitive, and should be compared as such.\n          return exceptHeader.toLowerCase() === lowerCaseKey;\n        })) ||\n      ('onlyNames' in sendHeaders &&\n        !sendHeaders.onlyNames.some((header) => {\n          return header.toLowerCase() === lowerCaseKey;\n        }))\n    ) {\n      continue;\n    }\n\n    switch (key) {\n      case 'authorization':\n      case 'cookie':\n      case 'set-cookie':\n        break;\n      default:\n        http!.requestHeaders![key] = new Trace.HTTP.Values({\n          value: [value],\n        });\n    }\n  }\n}\n\nfunction defaultGenerateClientInfo({ request }: GraphQLRequestContext) {\n  const clientNameHeaderKey = 'apollographql-client-name';\n  const clientVersionHeaderKey = 'apollographql-client-version';\n\n  // Default to using the `apollo-client-x` header fields if present.\n  // If none are present, fallback on the `clientInfo` query extension\n  // for backwards compatibility.\n  // The default value if neither header values nor query extension is\n  // set is the empty String for all fields (as per protobuf defaults)\n  if (\n    request.http?.headers?.get(clientNameHeaderKey) ||\n    request.http?.headers?.get(clientVersionHeaderKey)\n  ) {\n    return {\n      clientName: request.http?.headers?.get(clientNameHeaderKey),\n      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),\n    };\n  } else if (request.extensions?.clientInfo) {\n    return request.extensions.clientInfo;\n  } else {\n    return {};\n  }\n}\n\n// This plugin does nothing, but it ensures that ApolloServer won't try\n// to add a default ApolloServerPluginUsageReporting.\nexport function ApolloServerPluginUsageReportingDisabled(): InternalApolloServerPlugin {\n  return {\n    __internal_plugin_id__() {\n      return 'UsageReporting';\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}