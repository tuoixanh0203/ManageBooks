{"ast":null,"code":"\"use strict\";\n\n// addTypes uses toConfig to create a new schema with a new or replaced\n// type or directive. Rewiring is employed so that the replaced type can be\n// reconnected with the existing types.\n//\n// Rewiring is employed even for new types or directives as a convenience, so\n// that type references within the new type or directive do not have to be to\n// the identical objects within the original schema.\n//\n// In fact, the type references could even be stub types with entirely different\n// fields, as long as the type references share the same name as the desired\n// type within the original schema's type map.\n//\n// This makes it easy to perform simple schema operations (e.g. adding a new\n// type with a fiew fields removed from an existing type) that could normally be\n// performed by using toConfig directly, but is blocked if any intervening\n// more advanced schema operations have caused the types to be recreated via\n// rewiring.\n//\n// Type recreation happens, for example, with every use of mapSchema, as the\n// types are always rewired. If fields are selected and removed using\n// mapSchema, adding those fields to a new type can no longer be simply done\n// by toConfig, as the types are not the identical JavaScript objects, and\n// schema creation will fail with errors referencing multiple types with the\n// same names.\n//\n// enhanceSchema can fill this gap by adding an additional round of rewiring.\n//\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTypes = void 0;\nconst graphql_1 = require(\"graphql\");\nconst getObjectTypeFromTypeMap_js_1 = require(\"./getObjectTypeFromTypeMap.js\");\nconst rewire_js_1 = require(\"./rewire.js\");\nfunction addTypes(schema, newTypesOrDirectives) {\n  const config = schema.toConfig();\n  const originalTypeMap = {};\n  for (const type of config.types) {\n    originalTypeMap[type.name] = type;\n  }\n  const originalDirectiveMap = {};\n  for (const directive of config.directives) {\n    originalDirectiveMap[directive.name] = directive;\n  }\n  for (const newTypeOrDirective of newTypesOrDirectives) {\n    if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {\n      originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n    } else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {\n      originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n    }\n  }\n  const {\n    typeMap,\n    directives\n  } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));\n  return new graphql_1.GraphQLSchema({\n    ...config,\n    query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),\n    mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),\n    subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),\n    types: Object.values(typeMap),\n    directives\n  });\n}\nexports.addTypes = addTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","addTypes","graphql_1","require","getObjectTypeFromTypeMap_js_1","rewire_js_1","schema","newTypesOrDirectives","config","toConfig","originalTypeMap","type","types","name","originalDirectiveMap","directive","directives","newTypeOrDirective","isNamedType","isDirective","typeMap","rewireTypes","values","GraphQLSchema","query","getObjectTypeFromTypeMap","getQueryType","mutation","getMutationType","subscription","getSubscriptionType"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/addTypes.js"],"sourcesContent":["\"use strict\";\n// addTypes uses toConfig to create a new schema with a new or replaced\n// type or directive. Rewiring is employed so that the replaced type can be\n// reconnected with the existing types.\n//\n// Rewiring is employed even for new types or directives as a convenience, so\n// that type references within the new type or directive do not have to be to\n// the identical objects within the original schema.\n//\n// In fact, the type references could even be stub types with entirely different\n// fields, as long as the type references share the same name as the desired\n// type within the original schema's type map.\n//\n// This makes it easy to perform simple schema operations (e.g. adding a new\n// type with a fiew fields removed from an existing type) that could normally be\n// performed by using toConfig directly, but is blocked if any intervening\n// more advanced schema operations have caused the types to be recreated via\n// rewiring.\n//\n// Type recreation happens, for example, with every use of mapSchema, as the\n// types are always rewired. If fields are selected and removed using\n// mapSchema, adding those fields to a new type can no longer be simply done\n// by toConfig, as the types are not the identical JavaScript objects, and\n// schema creation will fail with errors referencing multiple types with the\n// same names.\n//\n// enhanceSchema can fill this gap by adding an additional round of rewiring.\n//\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addTypes = void 0;\nconst graphql_1 = require(\"graphql\");\nconst getObjectTypeFromTypeMap_js_1 = require(\"./getObjectTypeFromTypeMap.js\");\nconst rewire_js_1 = require(\"./rewire.js\");\nfunction addTypes(schema, newTypesOrDirectives) {\n    const config = schema.toConfig();\n    const originalTypeMap = {};\n    for (const type of config.types) {\n        originalTypeMap[type.name] = type;\n    }\n    const originalDirectiveMap = {};\n    for (const directive of config.directives) {\n        originalDirectiveMap[directive.name] = directive;\n    }\n    for (const newTypeOrDirective of newTypesOrDirectives) {\n        if ((0, graphql_1.isNamedType)(newTypeOrDirective)) {\n            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n        else if ((0, graphql_1.isDirective)(newTypeOrDirective)) {\n            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n    }\n    const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(originalTypeMap, Object.values(originalDirectiveMap));\n    return new graphql_1.GraphQLSchema({\n        ...config,\n        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getQueryType()),\n        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getMutationType()),\n        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, schema.getSubscriptionType()),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nexports.addTypes = addTypes;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,QAAQ,GAAG,KAAK,CAAC;AACzB,MAAMC,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,6BAA6B,GAAGD,OAAO,CAAC,+BAA+B,CAAC;AAC9E,MAAME,WAAW,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC1C,SAASF,QAAQ,CAACK,MAAM,EAAEC,oBAAoB,EAAE;EAC5C,MAAMC,MAAM,GAAGF,MAAM,CAACG,QAAQ,EAAE;EAChC,MAAMC,eAAe,GAAG,CAAC,CAAC;EAC1B,KAAK,MAAMC,IAAI,IAAIH,MAAM,CAACI,KAAK,EAAE;IAC7BF,eAAe,CAACC,IAAI,CAACE,IAAI,CAAC,GAAGF,IAAI;EACrC;EACA,MAAMG,oBAAoB,GAAG,CAAC,CAAC;EAC/B,KAAK,MAAMC,SAAS,IAAIP,MAAM,CAACQ,UAAU,EAAE;IACvCF,oBAAoB,CAACC,SAAS,CAACF,IAAI,CAAC,GAAGE,SAAS;EACpD;EACA,KAAK,MAAME,kBAAkB,IAAIV,oBAAoB,EAAE;IACnD,IAAI,CAAC,CAAC,EAAEL,SAAS,CAACgB,WAAW,EAAED,kBAAkB,CAAC,EAAE;MAChDP,eAAe,CAACO,kBAAkB,CAACJ,IAAI,CAAC,GAAGI,kBAAkB;IACjE,CAAC,MACI,IAAI,CAAC,CAAC,EAAEf,SAAS,CAACiB,WAAW,EAAEF,kBAAkB,CAAC,EAAE;MACrDH,oBAAoB,CAACG,kBAAkB,CAACJ,IAAI,CAAC,GAAGI,kBAAkB;IACtE;EACJ;EACA,MAAM;IAAEG,OAAO;IAAEJ;EAAW,CAAC,GAAG,CAAC,CAAC,EAAEX,WAAW,CAACgB,WAAW,EAAEX,eAAe,EAAEb,MAAM,CAACyB,MAAM,CAACR,oBAAoB,CAAC,CAAC;EAClH,OAAO,IAAIZ,SAAS,CAACqB,aAAa,CAAC;IAC/B,GAAGf,MAAM;IACTgB,KAAK,EAAE,CAAC,CAAC,EAAEpB,6BAA6B,CAACqB,wBAAwB,EAAEL,OAAO,EAAEd,MAAM,CAACoB,YAAY,EAAE,CAAC;IAClGC,QAAQ,EAAE,CAAC,CAAC,EAAEvB,6BAA6B,CAACqB,wBAAwB,EAAEL,OAAO,EAAEd,MAAM,CAACsB,eAAe,EAAE,CAAC;IACxGC,YAAY,EAAE,CAAC,CAAC,EAAEzB,6BAA6B,CAACqB,wBAAwB,EAAEL,OAAO,EAAEd,MAAM,CAACwB,mBAAmB,EAAE,CAAC;IAChHlB,KAAK,EAAEf,MAAM,CAACyB,MAAM,CAACF,OAAO,CAAC;IAC7BJ;EACJ,CAAC,CAAC;AACN;AACAjB,OAAO,CAACE,QAAQ,GAAGA,QAAQ"},"metadata":{},"sourceType":"script","externalDependencies":[]}