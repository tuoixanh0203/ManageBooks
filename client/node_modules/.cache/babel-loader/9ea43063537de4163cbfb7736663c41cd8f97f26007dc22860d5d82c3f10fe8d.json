{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addResolversToSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst checkForResolveTypeResolver_js_1 = require(\"./checkForResolveTypeResolver.js\");\nconst extendResolversFromInterfaces_js_1 = require(\"./extendResolversFromInterfaces.js\");\nfunction addResolversToSchema(_ref) {\n  let {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false\n  } = _ref;\n  const {\n    requireResolversToMatchSchema = 'error',\n    requireResolversForResolveType\n  } = resolverValidationOptions;\n  const resolvers = inheritResolversFromInterfaces ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers) : inputResolvers;\n  for (const typeName in resolvers) {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n    if (resolverType !== 'object') {\n      throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n    }\n    const type = schema.getType(typeName);\n    if (type == null) {\n      if (requireResolversToMatchSchema === 'ignore') {\n        continue;\n      }\n      throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n    } else if ((0, graphql_1.isSpecifiedScalarType)(type)) {\n      // allow -- without recommending -- overriding of specified scalar types\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if ((0, graphql_1.isEnumType)(type)) {\n      const values = type.getValues();\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && !values.some(value => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n        }\n      }\n    } else if ((0, graphql_1.isUnionType)(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__') && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n          throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n        }\n      }\n    } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {\n      for (const fieldName in resolverValue) {\n        if (!fieldName.startsWith('__')) {\n          const fields = type.getFields();\n          const field = fields[fieldName];\n          if (field == null) {\n            // Field present in resolver but not in schema\n            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n            }\n          } else {\n            // Field present in both the resolver and schema\n            const fieldResolve = resolverValue[fieldName];\n            if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n            }\n          }\n        }\n      }\n    }\n  }\n  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n  if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n    (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);\n  }\n  return schema;\n}\nexports.addResolversToSchema = addResolversToSchema;\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n  const typeMap = schema.getTypeMap();\n  for (const typeName in resolvers) {\n    const type = schema.getType(typeName);\n    const resolverValue = resolvers[typeName];\n    if ((0, graphql_1.isScalarType)(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && type.astNode != null) {\n          type.astNode = {\n            ...type.astNode,\n            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,\n            directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n          type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      }\n    } else if ((0, graphql_1.isEnumType)(type)) {\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          config[fieldName.substring(2)] = resolverValue[fieldName];\n        } else if (fieldName === 'astNode' && config.astNode != null) {\n          config.astNode = {\n            ...config.astNode,\n            description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,\n            directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : [])\n          };\n        } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n          config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);\n        } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n        } else if (enumValueConfigMap[fieldName]) {\n          enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n        }\n      }\n      typeMap[typeName] = new graphql_1.GraphQLEnumType(config);\n    } else if ((0, graphql_1.isUnionType)(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        }\n      }\n    } else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {\n      for (const fieldName in resolverValue) {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          continue;\n        }\n        const fields = type.getFields();\n        const field = fields[fieldName];\n        if (field != null) {\n          const fieldResolve = resolverValue[fieldName];\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            field.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(field, fieldResolve);\n          }\n        }\n      }\n    }\n  }\n  // serialize all default values prior to healing fields with new scalar/enum types.\n  (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);\n  // schema may have new scalar/enum types that require healing\n  (0, utils_1.healSchema)(schema);\n  // reparse all default values with new parsing functions.\n  (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);\n  if (defaultFieldResolver != null) {\n    (0, utils_1.forEachField)(schema, field => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n  return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n  schema = (0, utils_1.mapSchema)(schema, {\n    [utils_1.MapperKind.SCALAR_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f;\n      const config = type.toConfig();\n      const resolverValue = resolvers[type.name];\n      if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = {\n              ...config.astNode,\n              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n              directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else {\n            config[fieldName] = resolverValue[fieldName];\n          }\n        }\n        return new graphql_1.GraphQLScalarType(config);\n      }\n    },\n    [utils_1.MapperKind.ENUM_TYPE]: type => {\n      var _a, _b, _c, _d, _e, _f;\n      const resolverValue = resolvers[type.name];\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n      if (resolverValue != null) {\n        for (const fieldName in resolverValue) {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = {\n              ...config.astNode,\n              description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n              directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        }\n        return new graphql_1.GraphQLEnumType(config);\n      }\n    },\n    [utils_1.MapperKind.UNION_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n        return new graphql_1.GraphQLUnionType(config);\n      }\n    },\n    [utils_1.MapperKind.OBJECT_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        if (resolverValue['__isTypeOf']) {\n          config.isTypeOf = resolverValue['__isTypeOf'];\n        }\n        return new graphql_1.GraphQLObjectType(config);\n      }\n    },\n    [utils_1.MapperKind.INTERFACE_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        if (resolverValue['__resolveType']) {\n          config.resolveType = resolverValue['__resolveType'];\n        }\n        return new graphql_1.GraphQLInterfaceType(config);\n      }\n    },\n    [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const resolverValue = resolvers[typeName];\n      if (resolverValue != null) {\n        const fieldResolve = resolverValue[fieldName];\n        if (fieldResolve != null) {\n          const newFieldConfig = {\n            ...fieldConfig\n          };\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n          } else {\n            setFieldProperties(newFieldConfig, fieldResolve);\n          }\n          return newFieldConfig;\n        }\n      }\n    }\n  });\n  if (defaultFieldResolver != null) {\n    schema = (0, utils_1.mapSchema)(schema, {\n      [utils_1.MapperKind.OBJECT_FIELD]: fieldConfig => ({\n        ...fieldConfig,\n        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver\n      })\n    });\n  }\n  return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n  for (const propertyName in propertiesObj) {\n    field[propertyName] = propertiesObj[propertyName];\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","addResolversToSchema","graphql_1","require","utils_1","checkForResolveTypeResolver_js_1","extendResolversFromInterfaces_js_1","schema","resolvers","inputResolvers","defaultFieldResolver","resolverValidationOptions","inheritResolversFromInterfaces","updateResolversInPlace","requireResolversToMatchSchema","requireResolversForResolveType","extendResolversFromInterfaces","typeName","resolverValue","resolverType","Error","type","getType","isSpecifiedScalarType","fieldName","startsWith","substring","isEnumType","values","getValues","some","name","isUnionType","isObjectType","isInterfaceType","fields","getFields","field","fieldResolve","addResolversToExistingSchema","createNewSchemaWithResolvers","checkForResolveTypeResolver","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","typeMap","getTypeMap","isScalarType","astNode","description","directives","concat","extensionASTNodes","extensions","assign","create","config","toConfig","enumValueConfigMap","GraphQLEnumType","resolve","bind","setFieldProperties","forEachDefaultValue","serializeInputValue","healSchema","parseInputValue","forEachField","mapSchema","MapperKind","SCALAR_TYPE","GraphQLScalarType","ENUM_TYPE","UNION_TYPE","resolveType","GraphQLUnionType","OBJECT_TYPE","isTypeOf","GraphQLObjectType","INTERFACE_TYPE","GraphQLInterfaceType","COMPOSITE_FIELD","fieldConfig","newFieldConfig","OBJECT_FIELD","propertiesObj","propertyName"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/addResolversToSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addResolversToSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst checkForResolveTypeResolver_js_1 = require(\"./checkForResolveTypeResolver.js\");\nconst extendResolversFromInterfaces_js_1 = require(\"./extendResolversFromInterfaces.js\");\nfunction addResolversToSchema({ schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, }) {\n    const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? (0, extendResolversFromInterfaces_js_1.extendResolversFromInterfaces)(schema, inputResolvers)\n        : inputResolvers;\n    for (const typeName in resolvers) {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (resolverType !== 'object') {\n            throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n        }\n        const type = schema.getType(typeName);\n        if (type == null) {\n            if (requireResolversToMatchSchema === 'ignore') {\n                continue;\n            }\n            throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n        }\n        else if ((0, graphql_1.isSpecifiedScalarType)(type)) {\n            // allow -- without recommending -- overriding of specified scalar types\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if ((0, graphql_1.isEnumType)(type)) {\n            const values = type.getValues();\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    !values.some(value => value.name === fieldName) &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n                }\n            }\n        }\n        else if ((0, graphql_1.isUnionType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__') &&\n                    requireResolversToMatchSchema &&\n                    requireResolversToMatchSchema !== 'ignore') {\n                    throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n                }\n            }\n        }\n        else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (!fieldName.startsWith('__')) {\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field == null) {\n                        // Field present in resolver but not in schema\n                        if (requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n                        }\n                    }\n                    else {\n                        // Field present in both the resolver and schema\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    if (requireResolversForResolveType && requireResolversForResolveType !== 'ignore') {\n        (0, checkForResolveTypeResolver_js_1.checkForResolveTypeResolver)(schema, requireResolversForResolveType);\n    }\n    return schema;\n}\nexports.addResolversToSchema = addResolversToSchema;\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n    const typeMap = schema.getTypeMap();\n    for (const typeName in resolvers) {\n        const type = schema.getType(typeName);\n        const resolverValue = resolvers[typeName];\n        if ((0, graphql_1.isScalarType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && type.astNode != null) {\n                    type.astNode = {\n                        ...type.astNode,\n                        description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : type.astNode.description,\n                        directives: ((_c = type.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                    type.extensionASTNodes = type.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else {\n                    type[fieldName] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if ((0, graphql_1.isEnumType)(type)) {\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    config[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n                else if (fieldName === 'astNode' && config.astNode != null) {\n                    config.astNode = {\n                        ...config.astNode,\n                        description: (_h = (_g = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _g === void 0 ? void 0 : _g.description) !== null && _h !== void 0 ? _h : config.astNode.description,\n                        directives: ((_j = config.astNode.directives) !== null && _j !== void 0 ? _j : []).concat((_l = (_k = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _k === void 0 ? void 0 : _k.directives) !== null && _l !== void 0 ? _l : []),\n                    };\n                }\n                else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                    config.extensionASTNodes = config.extensionASTNodes.concat((_m = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _m !== void 0 ? _m : []);\n                }\n                else if (fieldName === 'extensions' &&\n                    type.extensions != null &&\n                    resolverValue.extensions != null) {\n                    type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                }\n                else if (enumValueConfigMap[fieldName]) {\n                    enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                }\n            }\n            typeMap[typeName] = new graphql_1.GraphQLEnumType(config);\n        }\n        else if ((0, graphql_1.isUnionType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                }\n            }\n        }\n        else if ((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type)) {\n            for (const fieldName in resolverValue) {\n                if (fieldName.startsWith('__')) {\n                    // this is for isTypeOf and resolveType and all the other stuff.\n                    type[fieldName.substring(2)] = resolverValue[fieldName];\n                    continue;\n                }\n                const fields = type.getFields();\n                const field = fields[fieldName];\n                if (field != null) {\n                    const fieldResolve = resolverValue[fieldName];\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        field.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(field, fieldResolve);\n                    }\n                }\n            }\n        }\n    }\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    (0, utils_1.forEachDefaultValue)(schema, utils_1.serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    (0, utils_1.healSchema)(schema);\n    // reparse all default values with new parsing functions.\n    (0, utils_1.forEachDefaultValue)(schema, utils_1.parseInputValue);\n    if (defaultFieldResolver != null) {\n        (0, utils_1.forEachField)(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = (0, utils_1.mapSchema)(schema, {\n        [utils_1.MapperKind.SCALAR_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f;\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!(0, graphql_1.isSpecifiedScalarType)(type) && resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                }\n                return new graphql_1.GraphQLScalarType(config);\n            }\n        },\n        [utils_1.MapperKind.ENUM_TYPE]: type => {\n            var _a, _b, _c, _d, _e, _f;\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                for (const fieldName in resolverValue) {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_b = (_a = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : config.astNode.description,\n                            directives: ((_c = config.astNode.directives) !== null && _c !== void 0 ? _c : []).concat((_e = (_d = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.astNode) === null || _d === void 0 ? void 0 : _d.directives) !== null && _e !== void 0 ? _e : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_f = resolverValue === null || resolverValue === void 0 ? void 0 : resolverValue.extensionASTNodes) !== null && _f !== void 0 ? _f : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                }\n                return new graphql_1.GraphQLEnumType(config);\n            }\n        },\n        [utils_1.MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql_1.GraphQLUnionType(config);\n            }\n        },\n        [utils_1.MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__isTypeOf']) {\n                    config.isTypeOf = resolverValue['__isTypeOf'];\n                }\n                return new graphql_1.GraphQLObjectType(config);\n            }\n        },\n        [utils_1.MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                if (resolverValue['__resolveType']) {\n                    config.resolveType = resolverValue['__resolveType'];\n                }\n                return new graphql_1.GraphQLInterfaceType(config);\n            }\n        },\n        [utils_1.MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve.bind(resolverValue);\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = (0, utils_1.mapSchema)(schema, {\n            [utils_1.MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    for (const propertyName in propertiesObj) {\n        field[propertyName] = propertiesObj[propertyName];\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}