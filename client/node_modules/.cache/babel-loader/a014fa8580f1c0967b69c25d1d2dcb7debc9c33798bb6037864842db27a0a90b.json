{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMockStore = exports.MockStore = exports.defaultMocks = void 0;\nconst tslib_1 = require(\"tslib\");\nconst graphql_1 = require(\"graphql\");\nconst fast_json_stable_stringify_1 = tslib_1.__importDefault(require(\"fast-json-stable-stringify\"));\nconst types_js_1 = require(\"./types.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst MockList_js_1 = require(\"./MockList.js\");\nexports.defaultMocks = {\n  Int: () => Math.round(Math.random() * 200) - 100,\n  Float: () => Math.random() * 200 - 100,\n  String: () => 'Hello World',\n  Boolean: () => Math.random() > 0.5,\n  ID: () => (0, utils_js_1.uuidv4)()\n};\nconst defaultKeyFieldNames = ['id', '_id'];\nclass MockStore {\n  constructor(_ref) {\n    let {\n      schema,\n      mocks,\n      typePolicies\n    } = _ref;\n    this.store = {};\n    this.schema = schema;\n    this.mocks = {\n      ...exports.defaultMocks,\n      ...mocks\n    };\n    this.typePolicies = typePolicies || {};\n  }\n  has(typeName, key) {\n    return !!this.store[typeName] && !!this.store[typeName][key];\n  }\n  get(_typeName, _key, _fieldName, _fieldArgs) {\n    if (typeof _typeName !== 'string') {\n      if (_key === undefined) {\n        if ((0, types_js_1.isRef)(_typeName)) {\n          throw new Error(\"Can't provide a ref as first argument and no other argument\");\n        }\n        // get({...})\n        return this.getImpl(_typeName);\n      } else {\n        (0, types_js_1.assertIsRef)(_typeName);\n        const {\n          $ref\n        } = _typeName;\n        // arguments shift\n        _fieldArgs = _fieldName;\n        _fieldName = _key;\n        _key = $ref.key;\n        _typeName = $ref.typeName;\n      }\n    }\n    const args = {\n      typeName: _typeName\n    };\n    if ((0, types_js_1.isRecord)(_key) || _key === undefined) {\n      // get('User', { name: 'Alex'})\n      args.defaultValue = _key;\n      return this.getImpl(args);\n    }\n    args.key = _key;\n    if (Array.isArray(_fieldName) && _fieldName.length === 1) {\n      _fieldName = _fieldName[0];\n    }\n    if (typeof _fieldName !== 'string' && !Array.isArray(_fieldName)) {\n      // get('User', 'me', { name: 'Alex'})\n      args.defaultValue = _fieldName;\n      return this.getImpl(args);\n    }\n    if (Array.isArray(_fieldName)) {\n      // get('User', 'me', ['father', 'name'])\n      const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);\n      (0, types_js_1.assertIsRef)(ref);\n      return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));\n    }\n    // get('User', 'me', 'name'...);\n    args.fieldName = _fieldName;\n    args.fieldArgs = _fieldArgs;\n    return this.getImpl(args);\n  }\n  set(_typeName, _key, _fieldName, _value) {\n    if (typeof _typeName !== 'string') {\n      if (_key === undefined) {\n        if ((0, types_js_1.isRef)(_typeName)) {\n          throw new Error(\"Can't provide a ref as first argument and no other argument\");\n        }\n        // set({...})\n        return this.setImpl(_typeName);\n      } else {\n        (0, types_js_1.assertIsRef)(_typeName);\n        const {\n          $ref\n        } = _typeName;\n        // arguments shift\n        _value = _fieldName;\n        _fieldName = _key;\n        _key = $ref.key;\n        _typeName = $ref.typeName;\n      }\n    }\n    assertIsDefined(_key, 'key was not provided');\n    const args = {\n      typeName: _typeName,\n      key: _key\n    };\n    if (typeof _fieldName !== 'string') {\n      // set('User', 1, { name: 'Foo' })\n      if (!(0, types_js_1.isRecord)(_fieldName)) throw new Error('Expected value to be a record');\n      args.value = _fieldName;\n      return this.setImpl(args);\n    }\n    args.fieldName = _fieldName;\n    args.value = _value;\n    return this.setImpl(args);\n  }\n  reset() {\n    this.store = {};\n  }\n  filter(key, predicate) {\n    const entity = this.store[key];\n    return Object.values(entity).filter(predicate);\n  }\n  find(key, predicate) {\n    const entity = this.store[key];\n    return Object.values(entity).find(predicate);\n  }\n  getImpl(args) {\n    const {\n      typeName,\n      key,\n      fieldName,\n      fieldArgs,\n      defaultValue\n    } = args;\n    if (!fieldName) {\n      if (defaultValue !== undefined && !(0, types_js_1.isRecord)(defaultValue)) {\n        throw new Error('`defaultValue` should be an object');\n      }\n      let valuesToInsert = defaultValue || {};\n      if (key) {\n        valuesToInsert = {\n          ...valuesToInsert,\n          ...(0, utils_js_1.makeRef)(typeName, key)\n        };\n      }\n      return this.insert(typeName, valuesToInsert, true);\n    }\n    assertIsDefined(key, 'key argument should be given when fieldName is given');\n    const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n    if (this.store[typeName] === undefined || this.store[typeName][key] === undefined || this.store[typeName][key][fieldNameInStore] === undefined) {\n      let value;\n      if (defaultValue !== undefined) {\n        value = defaultValue;\n      } else if (this.isKeyField(typeName, fieldName)) {\n        value = key;\n      } else {\n        value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {\n          // if we get a key field in the mix we don't care\n          if (this.isKeyField(typeName, otherFieldName)) return;\n          this.set({\n            typeName,\n            key,\n            fieldName: otherFieldName,\n            value: otherValue,\n            noOverride: true\n          });\n        });\n      }\n      this.set({\n        typeName,\n        key,\n        fieldName,\n        fieldArgs,\n        value,\n        noOverride: true\n      });\n    }\n    return this.store[typeName][key][fieldNameInStore];\n  }\n  setImpl(args) {\n    const {\n      typeName,\n      key,\n      fieldName,\n      fieldArgs,\n      noOverride\n    } = args;\n    let {\n      value\n    } = args;\n    if ((0, MockList_js_1.isMockList)(value)) {\n      value = (0, MockList_js_1.deepResolveMockList)(value);\n    }\n    if (this.store[typeName] === undefined) {\n      this.store[typeName] = {};\n    }\n    if (this.store[typeName][key] === undefined) {\n      this.store[typeName][key] = {};\n    }\n    if (!fieldName) {\n      if (!(0, types_js_1.isRecord)(value)) {\n        throw new Error('When no `fieldName` is provided, `value` should be a record.');\n      }\n      for (const fieldName in value) {\n        this.setImpl({\n          typeName,\n          key,\n          fieldName,\n          value: value[fieldName],\n          noOverride\n        });\n      }\n      return;\n    }\n    const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n    if (this.isKeyField(typeName, fieldName) && value !== key) {\n      throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);\n    }\n    // if already set and we don't override\n    if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {\n      return;\n    }\n    const fieldType = this.getFieldType(typeName, fieldName);\n    const currentValue = this.store[typeName][key][fieldNameInStore];\n    let valueToStore;\n    try {\n      valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName, values) => this.insert(typeName, values, noOverride));\n    } catch (e) {\n      throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);\n    }\n    this.store[typeName][key] = {\n      ...this.store[typeName][key],\n      [fieldNameInStore]: valueToStore\n    };\n  }\n  normalizeValueToStore(fieldType, value, currentValue, onInsertType) {\n    const fieldTypeName = fieldType.toString();\n    if (value === null) {\n      if (!(0, graphql_1.isNullableType)(fieldType)) {\n        throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);\n      }\n      return null;\n    }\n    const nullableFieldType = (0, graphql_1.getNullableType)(fieldType);\n    if (value === undefined) return this.generateValueFromType(nullableFieldType);\n    // deal with nesting insert\n    if ((0, graphql_1.isCompositeType)(nullableFieldType)) {\n      if (!(0, types_js_1.isRecord)(value)) throw new Error(`should be an object or null or undefined. Received ${value}`);\n      let joinedTypeName;\n      if ((0, graphql_1.isAbstractType)(nullableFieldType)) {\n        if ((0, types_js_1.isRef)(value)) {\n          joinedTypeName = value.$ref.typeName;\n        } else {\n          if (typeof value['__typename'] !== 'string') {\n            throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);\n          }\n          joinedTypeName = value['__typename'];\n        }\n      } else {\n        joinedTypeName = nullableFieldType.name;\n      }\n      return onInsertType(joinedTypeName, (0, types_js_1.isRef)(currentValue) ? {\n        ...currentValue,\n        ...value\n      } : value);\n    }\n    if ((0, graphql_1.isListType)(nullableFieldType)) {\n      if (!Array.isArray(value)) throw new Error(`should be an array or null or undefined. Received ${value}`);\n      return value.map((v, index) => {\n        return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === 'object' && currentValue != null && currentValue[index] ? currentValue : undefined, onInsertType);\n      });\n    }\n    return value;\n  }\n  insert(typeName, values, noOverride) {\n    const keyFieldName = this.getKeyFieldName(typeName);\n    let key;\n    // when we generate a key for the type, we might produce\n    // other associated values with it\n    // We keep track of them and we'll insert them, with propririty\n    // for the ones that we areasked to insert\n    const otherValues = {};\n    if ((0, types_js_1.isRef)(values)) {\n      key = values.$ref.key;\n    } else if (keyFieldName && keyFieldName in values) {\n      key = values[keyFieldName];\n    } else {\n      key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {\n        otherValues[otherFieldName] = otherFieldValue;\n      });\n    }\n    const toInsert = {\n      ...otherValues,\n      ...values\n    };\n    for (const fieldName in toInsert) {\n      if (fieldName === '$ref') continue;\n      if (fieldName === '__typename') continue;\n      this.set({\n        typeName,\n        key,\n        fieldName,\n        value: toInsert[fieldName],\n        noOverride\n      });\n    }\n    if (this.store[typeName] === undefined) {\n      this.store[typeName] = {};\n    }\n    if (this.store[typeName][key] === undefined) {\n      this.store[typeName][key] = {};\n    }\n    return (0, utils_js_1.makeRef)(typeName, key);\n  }\n  generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {\n    const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);\n    if (mockedValue !== undefined) return mockedValue;\n    const fieldType = this.getFieldType(typeName, fieldName);\n    return this.generateValueFromType(fieldType);\n  }\n  generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {\n    let value;\n    const mock = this.mocks ? this.mocks[typeName] : undefined;\n    if (mock) {\n      if (typeof mock === 'function') {\n        const values = mock();\n        if (typeof values !== 'object' || values == null) {\n          throw new Error(`Value returned by the mock for ${typeName} is not an object`);\n        }\n        for (const otherFieldName in values) {\n          if (otherFieldName === fieldName) continue;\n          if (typeof values[otherFieldName] === 'function') continue;\n          onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);\n        }\n        value = values[fieldName];\n        if (typeof value === 'function') value = value();\n      } else if (typeof mock === 'object' && mock != null && typeof mock[fieldName] === 'function') {\n        value = mock[fieldName]();\n      }\n    }\n    if (value !== undefined) return value;\n    const type = this.getType(typeName);\n    // GraphQL 14 Compatibility\n    const interfaces = 'getInterfaces' in type ? type.getInterfaces() : [];\n    if (interfaces.length > 0) {\n      for (const interface_ of interfaces) {\n        if (value) break;\n        value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);\n      }\n    }\n    return value;\n  }\n  generateKeyForType(typeName, onOtherFieldsGenerated) {\n    const keyFieldName = this.getKeyFieldName(typeName);\n    if (!keyFieldName) return (0, utils_js_1.uuidv4)();\n    return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);\n  }\n  generateValueFromType(fieldType) {\n    const nullableType = (0, graphql_1.getNullableType)(fieldType);\n    if ((0, graphql_1.isScalarType)(nullableType)) {\n      const mockFn = this.mocks[nullableType.name];\n      if (typeof mockFn !== 'function') throw new Error(`No mock defined for type \"${nullableType.name}\"`);\n      return mockFn();\n    } else if ((0, graphql_1.isEnumType)(nullableType)) {\n      const mockFn = this.mocks[nullableType.name];\n      if (typeof mockFn === 'function') return mockFn();\n      const values = nullableType.getValues().map(v => v.value);\n      return (0, utils_js_1.takeRandom)(values);\n    } else if ((0, graphql_1.isObjectType)(nullableType)) {\n      // this will create a new random ref\n      return this.insert(nullableType.name, {});\n    } else if ((0, graphql_1.isListType)(nullableType)) {\n      return [...new Array((0, utils_js_1.randomListLength)())].map(() => this.generateValueFromType(nullableType.ofType));\n    } else if ((0, graphql_1.isAbstractType)(nullableType)) {\n      const mock = this.mocks[nullableType.name];\n      let typeName;\n      let values = {};\n      if (!mock) {\n        typeName = (0, utils_js_1.takeRandom)(this.schema.getPossibleTypes(nullableType).map(t => t.name));\n      } else if (typeof mock === 'function') {\n        const mockRes = mock();\n        if (mockRes === null) return null;\n        if (!(0, types_js_1.isRecord)(mockRes)) {\n          throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);\n        }\n        values = mockRes;\n        if (typeof values['__typename'] !== 'string') {\n          throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n        }\n        typeName = values['__typename'];\n      } else if (typeof mock === 'object' && mock != null && typeof mock['__typename'] === 'function') {\n        const mockRes = mock['__typename']();\n        if (typeof mockRes !== 'string') throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);\n        typeName = mockRes;\n      } else {\n        throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n      }\n      const toInsert = {};\n      for (const fieldName in values) {\n        if (fieldName === '__typename') continue;\n        const fieldValue = values[fieldName];\n        toInsert[fieldName] = typeof fieldValue === 'function' ? fieldValue() : fieldValue;\n      }\n      return this.insert(typeName, toInsert);\n    } else {\n      throw new Error(`${nullableType} not implemented`);\n    }\n  }\n  getFieldType(typeName, fieldName) {\n    if (fieldName === '__typename') {\n      return graphql_1.GraphQLString;\n    }\n    const type = this.getType(typeName);\n    const field = type.getFields()[fieldName];\n    if (!field) {\n      throw new Error(`${fieldName} does not exist on type ${typeName}`);\n    }\n    return field.type;\n  }\n  getType(typeName) {\n    const type = this.schema.getType(typeName);\n    if (!type || !((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type))) {\n      throw new Error(`${typeName} does not exist on schema or is not an object or interface`);\n    }\n    return type;\n  }\n  isKeyField(typeName, fieldName) {\n    return this.getKeyFieldName(typeName) === fieldName;\n  }\n  getKeyFieldName(typeName) {\n    var _a;\n    const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;\n    if (typePolicyKeyField !== undefined) {\n      if (typePolicyKeyField === false) return null;\n      return typePolicyKeyField;\n    }\n    // How about common key field names?\n    const gqlType = this.getType(typeName);\n    for (const fieldName in gqlType.getFields()) {\n      if (defaultKeyFieldNames.includes(fieldName)) {\n        return fieldName;\n      }\n    }\n    return null;\n  }\n}\nexports.MockStore = MockStore;\nconst getFieldNameInStore = (fieldName, fieldArgs) => {\n  if (!fieldArgs) return fieldName;\n  if (typeof fieldArgs === 'string') {\n    return `${fieldName}:${fieldArgs}`;\n  }\n  // empty args\n  if (Object.keys(fieldArgs).length === 0) {\n    return fieldName;\n  }\n  return `${fieldName}:${(0, fast_json_stable_stringify_1.default)(fieldArgs)}`;\n};\nfunction assertIsDefined(value, message) {\n  if (value !== undefined && value !== null) {\n    return;\n  }\n  throw new Error(process.env['NODE_ENV'] === 'production' ? 'Invariant failed:' : `Invariant failed: ${message || ''}`);\n}\n/**\n * Will create `MockStore` for the given `schema`.\n *\n * A `MockStore` will generate mock values for the given schem when queried.\n *\n * It will stores generated mocks, so that, provided with same arguments\n * the returned values will be the same.\n *\n * Its API also allows to modify the stored values.\n *\n * Basic example:\n * ```ts\n * store.get('User', 1, 'name');\n * // > \"Hello World\"\n * store.set('User', 1, 'name', 'Alexandre');\n * store.get('User', 1, 'name');\n * // > \"Alexandre\"\n * ```\n *\n * The storage key will correspond to the \"key field\"\n * of the type. Field with name `id` or `_id` will be\n * by default considered as the key field for the type.\n * However, use `typePolicies` to precise the field to use\n * as key.\n */\nfunction createMockStore(options) {\n  return new MockStore(options);\n}\nexports.createMockStore = createMockStore;","map":{"version":3,"names":["Object","defineProperty","exports","value","createMockStore","MockStore","defaultMocks","tslib_1","require","graphql_1","fast_json_stable_stringify_1","__importDefault","types_js_1","utils_js_1","MockList_js_1","Int","Math","round","random","Float","String","Boolean","ID","uuidv4","defaultKeyFieldNames","constructor","schema","mocks","typePolicies","store","has","typeName","key","get","_typeName","_key","_fieldName","_fieldArgs","undefined","isRef","Error","getImpl","assertIsRef","$ref","args","isRecord","defaultValue","Array","isArray","length","ref","slice","fieldName","fieldArgs","set","_value","setImpl","assertIsDefined","reset","filter","predicate","entity","values","find","valuesToInsert","makeRef","insert","fieldNameInStore","getFieldNameInStore","isKeyField","generateFieldValue","otherFieldName","otherValue","noOverride","isMockList","deepResolveMockList","fieldType","getFieldType","currentValue","valueToStore","normalizeValueToStore","e","message","onInsertType","fieldTypeName","toString","isNullableType","nullableFieldType","getNullableType","generateValueFromType","isCompositeType","joinedTypeName","isAbstractType","name","isListType","map","v","index","ofType","keyFieldName","getKeyFieldName","otherValues","generateKeyForType","otherFieldValue","toInsert","onOtherFieldsGenerated","mockedValue","generateFieldValueFromMocks","mock","type","getType","interfaces","getInterfaces","interface_","nullableType","isScalarType","mockFn","isEnumType","getValues","takeRandom","isObjectType","randomListLength","getPossibleTypes","t","mockRes","fieldValue","GraphQLString","field","getFields","isInterfaceType","_a","typePolicyKeyField","gqlType","includes","keys","default","process","env","options"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/mock/cjs/MockStore.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMockStore = exports.MockStore = exports.defaultMocks = void 0;\nconst tslib_1 = require(\"tslib\");\nconst graphql_1 = require(\"graphql\");\nconst fast_json_stable_stringify_1 = tslib_1.__importDefault(require(\"fast-json-stable-stringify\"));\nconst types_js_1 = require(\"./types.js\");\nconst utils_js_1 = require(\"./utils.js\");\nconst MockList_js_1 = require(\"./MockList.js\");\nexports.defaultMocks = {\n    Int: () => Math.round(Math.random() * 200) - 100,\n    Float: () => Math.random() * 200 - 100,\n    String: () => 'Hello World',\n    Boolean: () => Math.random() > 0.5,\n    ID: () => (0, utils_js_1.uuidv4)(),\n};\nconst defaultKeyFieldNames = ['id', '_id'];\nclass MockStore {\n    constructor({ schema, mocks, typePolicies, }) {\n        this.store = {};\n        this.schema = schema;\n        this.mocks = { ...exports.defaultMocks, ...mocks };\n        this.typePolicies = typePolicies || {};\n    }\n    has(typeName, key) {\n        return !!this.store[typeName] && !!this.store[typeName][key];\n    }\n    get(_typeName, _key, _fieldName, _fieldArgs) {\n        if (typeof _typeName !== 'string') {\n            if (_key === undefined) {\n                if ((0, types_js_1.isRef)(_typeName)) {\n                    throw new Error(\"Can't provide a ref as first argument and no other argument\");\n                }\n                // get({...})\n                return this.getImpl(_typeName);\n            }\n            else {\n                (0, types_js_1.assertIsRef)(_typeName);\n                const { $ref } = _typeName;\n                // arguments shift\n                _fieldArgs = _fieldName;\n                _fieldName = _key;\n                _key = $ref.key;\n                _typeName = $ref.typeName;\n            }\n        }\n        const args = {\n            typeName: _typeName,\n        };\n        if ((0, types_js_1.isRecord)(_key) || _key === undefined) {\n            // get('User', { name: 'Alex'})\n            args.defaultValue = _key;\n            return this.getImpl(args);\n        }\n        args.key = _key;\n        if (Array.isArray(_fieldName) && _fieldName.length === 1) {\n            _fieldName = _fieldName[0];\n        }\n        if (typeof _fieldName !== 'string' && !Array.isArray(_fieldName)) {\n            // get('User', 'me', { name: 'Alex'})\n            args.defaultValue = _fieldName;\n            return this.getImpl(args);\n        }\n        if (Array.isArray(_fieldName)) {\n            // get('User', 'me', ['father', 'name'])\n            const ref = this.get(_typeName, _key, _fieldName[0], _fieldArgs);\n            (0, types_js_1.assertIsRef)(ref);\n            return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));\n        }\n        // get('User', 'me', 'name'...);\n        args.fieldName = _fieldName;\n        args.fieldArgs = _fieldArgs;\n        return this.getImpl(args);\n    }\n    set(_typeName, _key, _fieldName, _value) {\n        if (typeof _typeName !== 'string') {\n            if (_key === undefined) {\n                if ((0, types_js_1.isRef)(_typeName)) {\n                    throw new Error(\"Can't provide a ref as first argument and no other argument\");\n                }\n                // set({...})\n                return this.setImpl(_typeName);\n            }\n            else {\n                (0, types_js_1.assertIsRef)(_typeName);\n                const { $ref } = _typeName;\n                // arguments shift\n                _value = _fieldName;\n                _fieldName = _key;\n                _key = $ref.key;\n                _typeName = $ref.typeName;\n            }\n        }\n        assertIsDefined(_key, 'key was not provided');\n        const args = {\n            typeName: _typeName,\n            key: _key,\n        };\n        if (typeof _fieldName !== 'string') {\n            // set('User', 1, { name: 'Foo' })\n            if (!(0, types_js_1.isRecord)(_fieldName))\n                throw new Error('Expected value to be a record');\n            args.value = _fieldName;\n            return this.setImpl(args);\n        }\n        args.fieldName = _fieldName;\n        args.value = _value;\n        return this.setImpl(args);\n    }\n    reset() {\n        this.store = {};\n    }\n    filter(key, predicate) {\n        const entity = this.store[key];\n        return Object.values(entity).filter(predicate);\n    }\n    find(key, predicate) {\n        const entity = this.store[key];\n        return Object.values(entity).find(predicate);\n    }\n    getImpl(args) {\n        const { typeName, key, fieldName, fieldArgs, defaultValue } = args;\n        if (!fieldName) {\n            if (defaultValue !== undefined && !(0, types_js_1.isRecord)(defaultValue)) {\n                throw new Error('`defaultValue` should be an object');\n            }\n            let valuesToInsert = defaultValue || {};\n            if (key) {\n                valuesToInsert = { ...valuesToInsert, ...(0, utils_js_1.makeRef)(typeName, key) };\n            }\n            return this.insert(typeName, valuesToInsert, true);\n        }\n        assertIsDefined(key, 'key argument should be given when fieldName is given');\n        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n        if (this.store[typeName] === undefined ||\n            this.store[typeName][key] === undefined ||\n            this.store[typeName][key][fieldNameInStore] === undefined) {\n            let value;\n            if (defaultValue !== undefined) {\n                value = defaultValue;\n            }\n            else if (this.isKeyField(typeName, fieldName)) {\n                value = key;\n            }\n            else {\n                value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {\n                    // if we get a key field in the mix we don't care\n                    if (this.isKeyField(typeName, otherFieldName))\n                        return;\n                    this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });\n                });\n            }\n            this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });\n        }\n        return this.store[typeName][key][fieldNameInStore];\n    }\n    setImpl(args) {\n        const { typeName, key, fieldName, fieldArgs, noOverride } = args;\n        let { value } = args;\n        if ((0, MockList_js_1.isMockList)(value)) {\n            value = (0, MockList_js_1.deepResolveMockList)(value);\n        }\n        if (this.store[typeName] === undefined) {\n            this.store[typeName] = {};\n        }\n        if (this.store[typeName][key] === undefined) {\n            this.store[typeName][key] = {};\n        }\n        if (!fieldName) {\n            if (!(0, types_js_1.isRecord)(value)) {\n                throw new Error('When no `fieldName` is provided, `value` should be a record.');\n            }\n            for (const fieldName in value) {\n                this.setImpl({\n                    typeName,\n                    key,\n                    fieldName,\n                    value: value[fieldName],\n                    noOverride,\n                });\n            }\n            return;\n        }\n        const fieldNameInStore = getFieldNameInStore(fieldName, fieldArgs);\n        if (this.isKeyField(typeName, fieldName) && value !== key) {\n            throw new Error(`Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`);\n        }\n        // if already set and we don't override\n        if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {\n            return;\n        }\n        const fieldType = this.getFieldType(typeName, fieldName);\n        const currentValue = this.store[typeName][key][fieldNameInStore];\n        let valueToStore;\n        try {\n            valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName, values) => this.insert(typeName, values, noOverride));\n        }\n        catch (e) {\n            throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);\n        }\n        this.store[typeName][key] = {\n            ...this.store[typeName][key],\n            [fieldNameInStore]: valueToStore,\n        };\n    }\n    normalizeValueToStore(fieldType, value, currentValue, onInsertType) {\n        const fieldTypeName = fieldType.toString();\n        if (value === null) {\n            if (!(0, graphql_1.isNullableType)(fieldType)) {\n                throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);\n            }\n            return null;\n        }\n        const nullableFieldType = (0, graphql_1.getNullableType)(fieldType);\n        if (value === undefined)\n            return this.generateValueFromType(nullableFieldType);\n        // deal with nesting insert\n        if ((0, graphql_1.isCompositeType)(nullableFieldType)) {\n            if (!(0, types_js_1.isRecord)(value))\n                throw new Error(`should be an object or null or undefined. Received ${value}`);\n            let joinedTypeName;\n            if ((0, graphql_1.isAbstractType)(nullableFieldType)) {\n                if ((0, types_js_1.isRef)(value)) {\n                    joinedTypeName = value.$ref.typeName;\n                }\n                else {\n                    if (typeof value['__typename'] !== 'string') {\n                        throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);\n                    }\n                    joinedTypeName = value['__typename'];\n                }\n            }\n            else {\n                joinedTypeName = nullableFieldType.name;\n            }\n            return onInsertType(joinedTypeName, (0, types_js_1.isRef)(currentValue) ? { ...currentValue, ...value } : value);\n        }\n        if ((0, graphql_1.isListType)(nullableFieldType)) {\n            if (!Array.isArray(value))\n                throw new Error(`should be an array or null or undefined. Received ${value}`);\n            return value.map((v, index) => {\n                return this.normalizeValueToStore(nullableFieldType.ofType, v, typeof currentValue === 'object' && currentValue != null && currentValue[index] ? currentValue : undefined, onInsertType);\n            });\n        }\n        return value;\n    }\n    insert(typeName, values, noOverride) {\n        const keyFieldName = this.getKeyFieldName(typeName);\n        let key;\n        // when we generate a key for the type, we might produce\n        // other associated values with it\n        // We keep track of them and we'll insert them, with propririty\n        // for the ones that we areasked to insert\n        const otherValues = {};\n        if ((0, types_js_1.isRef)(values)) {\n            key = values.$ref.key;\n        }\n        else if (keyFieldName && keyFieldName in values) {\n            key = values[keyFieldName];\n        }\n        else {\n            key = this.generateKeyForType(typeName, (otherFieldName, otherFieldValue) => {\n                otherValues[otherFieldName] = otherFieldValue;\n            });\n        }\n        const toInsert = { ...otherValues, ...values };\n        for (const fieldName in toInsert) {\n            if (fieldName === '$ref')\n                continue;\n            if (fieldName === '__typename')\n                continue;\n            this.set({\n                typeName,\n                key,\n                fieldName,\n                value: toInsert[fieldName],\n                noOverride,\n            });\n        }\n        if (this.store[typeName] === undefined) {\n            this.store[typeName] = {};\n        }\n        if (this.store[typeName][key] === undefined) {\n            this.store[typeName][key] = {};\n        }\n        return (0, utils_js_1.makeRef)(typeName, key);\n    }\n    generateFieldValue(typeName, fieldName, onOtherFieldsGenerated) {\n        const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);\n        if (mockedValue !== undefined)\n            return mockedValue;\n        const fieldType = this.getFieldType(typeName, fieldName);\n        return this.generateValueFromType(fieldType);\n    }\n    generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated) {\n        let value;\n        const mock = this.mocks ? this.mocks[typeName] : undefined;\n        if (mock) {\n            if (typeof mock === 'function') {\n                const values = mock();\n                if (typeof values !== 'object' || values == null) {\n                    throw new Error(`Value returned by the mock for ${typeName} is not an object`);\n                }\n                for (const otherFieldName in values) {\n                    if (otherFieldName === fieldName)\n                        continue;\n                    if (typeof values[otherFieldName] === 'function')\n                        continue;\n                    onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, values[otherFieldName]);\n                }\n                value = values[fieldName];\n                if (typeof value === 'function')\n                    value = value();\n            }\n            else if (typeof mock === 'object' && mock != null && typeof mock[fieldName] === 'function') {\n                value = mock[fieldName]();\n            }\n        }\n        if (value !== undefined)\n            return value;\n        const type = this.getType(typeName);\n        // GraphQL 14 Compatibility\n        const interfaces = 'getInterfaces' in type ? type.getInterfaces() : [];\n        if (interfaces.length > 0) {\n            for (const interface_ of interfaces) {\n                if (value)\n                    break;\n                value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);\n            }\n        }\n        return value;\n    }\n    generateKeyForType(typeName, onOtherFieldsGenerated) {\n        const keyFieldName = this.getKeyFieldName(typeName);\n        if (!keyFieldName)\n            return (0, utils_js_1.uuidv4)();\n        return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated);\n    }\n    generateValueFromType(fieldType) {\n        const nullableType = (0, graphql_1.getNullableType)(fieldType);\n        if ((0, graphql_1.isScalarType)(nullableType)) {\n            const mockFn = this.mocks[nullableType.name];\n            if (typeof mockFn !== 'function')\n                throw new Error(`No mock defined for type \"${nullableType.name}\"`);\n            return mockFn();\n        }\n        else if ((0, graphql_1.isEnumType)(nullableType)) {\n            const mockFn = this.mocks[nullableType.name];\n            if (typeof mockFn === 'function')\n                return mockFn();\n            const values = nullableType.getValues().map(v => v.value);\n            return (0, utils_js_1.takeRandom)(values);\n        }\n        else if ((0, graphql_1.isObjectType)(nullableType)) {\n            // this will create a new random ref\n            return this.insert(nullableType.name, {});\n        }\n        else if ((0, graphql_1.isListType)(nullableType)) {\n            return [...new Array((0, utils_js_1.randomListLength)())].map(() => this.generateValueFromType(nullableType.ofType));\n        }\n        else if ((0, graphql_1.isAbstractType)(nullableType)) {\n            const mock = this.mocks[nullableType.name];\n            let typeName;\n            let values = {};\n            if (!mock) {\n                typeName = (0, utils_js_1.takeRandom)(this.schema.getPossibleTypes(nullableType).map(t => t.name));\n            }\n            else if (typeof mock === 'function') {\n                const mockRes = mock();\n                if (mockRes === null)\n                    return null;\n                if (!(0, types_js_1.isRecord)(mockRes)) {\n                    throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);\n                }\n                values = mockRes;\n                if (typeof values['__typename'] !== 'string') {\n                    throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n                }\n                typeName = values['__typename'];\n            }\n            else if (typeof mock === 'object' && mock != null && typeof mock['__typename'] === 'function') {\n                const mockRes = mock['__typename']();\n                if (typeof mockRes !== 'string')\n                    throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);\n                typeName = mockRes;\n            }\n            else {\n                throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n            }\n            const toInsert = {};\n            for (const fieldName in values) {\n                if (fieldName === '__typename')\n                    continue;\n                const fieldValue = values[fieldName];\n                toInsert[fieldName] = typeof fieldValue === 'function' ? fieldValue() : fieldValue;\n            }\n            return this.insert(typeName, toInsert);\n        }\n        else {\n            throw new Error(`${nullableType} not implemented`);\n        }\n    }\n    getFieldType(typeName, fieldName) {\n        if (fieldName === '__typename') {\n            return graphql_1.GraphQLString;\n        }\n        const type = this.getType(typeName);\n        const field = type.getFields()[fieldName];\n        if (!field) {\n            throw new Error(`${fieldName} does not exist on type ${typeName}`);\n        }\n        return field.type;\n    }\n    getType(typeName) {\n        const type = this.schema.getType(typeName);\n        if (!type || !((0, graphql_1.isObjectType)(type) || (0, graphql_1.isInterfaceType)(type))) {\n            throw new Error(`${typeName} does not exist on schema or is not an object or interface`);\n        }\n        return type;\n    }\n    isKeyField(typeName, fieldName) {\n        return this.getKeyFieldName(typeName) === fieldName;\n    }\n    getKeyFieldName(typeName) {\n        var _a;\n        const typePolicyKeyField = (_a = this.typePolicies[typeName]) === null || _a === void 0 ? void 0 : _a.keyFieldName;\n        if (typePolicyKeyField !== undefined) {\n            if (typePolicyKeyField === false)\n                return null;\n            return typePolicyKeyField;\n        }\n        // How about common key field names?\n        const gqlType = this.getType(typeName);\n        for (const fieldName in gqlType.getFields()) {\n            if (defaultKeyFieldNames.includes(fieldName)) {\n                return fieldName;\n            }\n        }\n        return null;\n    }\n}\nexports.MockStore = MockStore;\nconst getFieldNameInStore = (fieldName, fieldArgs) => {\n    if (!fieldArgs)\n        return fieldName;\n    if (typeof fieldArgs === 'string') {\n        return `${fieldName}:${fieldArgs}`;\n    }\n    // empty args\n    if (Object.keys(fieldArgs).length === 0) {\n        return fieldName;\n    }\n    return `${fieldName}:${(0, fast_json_stable_stringify_1.default)(fieldArgs)}`;\n};\nfunction assertIsDefined(value, message) {\n    if (value !== undefined && value !== null) {\n        return;\n    }\n    throw new Error(process.env['NODE_ENV'] === 'production' ? 'Invariant failed:' : `Invariant failed: ${message || ''}`);\n}\n/**\n * Will create `MockStore` for the given `schema`.\n *\n * A `MockStore` will generate mock values for the given schem when queried.\n *\n * It will stores generated mocks, so that, provided with same arguments\n * the returned values will be the same.\n *\n * Its API also allows to modify the stored values.\n *\n * Basic example:\n * ```ts\n * store.get('User', 1, 'name');\n * // > \"Hello World\"\n * store.set('User', 1, 'name', 'Alexandre');\n * store.get('User', 1, 'name');\n * // > \"Alexandre\"\n * ```\n *\n * The storage key will correspond to the \"key field\"\n * of the type. Field with name `id` or `_id` will be\n * by default considered as the key field for the type.\n * However, use `typePolicies` to precise the field to use\n * as key.\n */\nfunction createMockStore(options) {\n    return new MockStore(options);\n}\nexports.createMockStore = createMockStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}