{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultSendOperationsAsTrace = void 0;\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nconst durationHistogram_1 = require(\"./durationHistogram\");\nfunction defaultSendOperationsAsTrace() {\n  const cache = new lru_cache_1.default({\n    max: Math.pow(2, 20),\n    length: (_val, key) => {\n      return key && Buffer.byteLength(key) || 0;\n    }\n  });\n  return (trace, statsReportKey) => {\n    var _a;\n    const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([statsReportKey, durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs), Math.floor(endTimeSeconds / 60), hasErrors ? Math.floor(endTimeSeconds / 5) : '']);\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\nexports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;\nfunction traceHasErrors(trace) {\n  let hasErrors = false;\n  function traceNodeStats(node) {\n    var _a, _b;\n    if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n  (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, false);\n  return hasErrors;\n}","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;AAEA;AACA;AAEA,SAAgBA,4BAA4B;EAO1C,MAAMC,KAAK,GAAG,IAAIC,mBAAQ,CAAe;IAWvCC,GAAG,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;IACpBC,MAAM,EAAE,CAACC,IAAI,EAAEC,GAAG,KAAI;MACpB,OAAQA,GAAG,IAAIC,MAAM,CAACC,UAAU,CAACF,GAAG,CAAC,IAAK,CAAC;IAC7C;GACD,CAAC;EAEF,OAAO,CAACG,KAAY,EAAEC,cAAsB,KAAa;;IACvD,MAAMC,cAAc,GAAG,WAAK,CAACC,OAAO,0CAAEC,OAAO;IAC7C,IAAIF,cAAc,IAAI,IAAI,EAAE;MAC1B,MAAMG,KAAK,CAAC,6CAA6C,CAAC;;IAG5D,MAAMC,SAAS,GAAGC,cAAc,CAACP,KAAK,CAAC;IACvC,MAAMQ,QAAQ,GAAGC,IAAI,CAACC,SAAS,CAAC,CAC9BT,cAAc,EACdU,qCAAiB,CAACC,gBAAgB,CAACZ,KAAK,CAACa,UAAU,CAAC,EAEpDpB,IAAI,CAACqB,KAAK,CAACZ,cAAc,GAAG,EAAE,CAAC,EAG/BI,SAAS,GAAGb,IAAI,CAACqB,KAAK,CAACZ,cAAc,GAAG,CAAC,CAAC,GAAG,EAAE,CAChD,CAAC;IAGF,IAAIZ,KAAK,CAACyB,GAAG,CAACP,QAAQ,CAAC,EAAE;MACvB,OAAO,KAAK;;IAGdlB,KAAK,CAAC0B,GAAG,CAACR,QAAQ,EAAE,IAAI,CAAC;IACzB,OAAO,IAAI;EACb,CAAC;AACH;AAjDAS;AAqDA,SAASV,cAAc,CAACP,KAAY;EAClC,IAAIM,SAAS,GAAG,KAAK;EAErB,SAASY,cAAc,CAACC,IAAiB;;IACvC,IAAI,CAAC,gBAAI,CAACC,KAAK,0CAAEzB,MAAM,mCAAI,CAAC,IAAI,CAAC,EAAE;MACjCW,SAAS,GAAG,IAAI;;IAElB,OAAOA,SAAS;EAClB;EAEA,uCAAgB,EAACN,KAAK,EAAEkB,cAAc,EAAE,KAAK,CAAC;EAC9C,OAAOZ,SAAS;AAClB","names":["defaultSendOperationsAsTrace","cache","lru_cache_1","max","Math","pow","length","_val","key","Buffer","byteLength","trace","statsReportKey","endTimeSeconds","endTime","seconds","Error","hasErrors","traceHasErrors","cacheKey","JSON","stringify","durationHistogram_1","durationToBucket","durationNs","floor","get","set","exports","traceNodeStats","node","error"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\usageReporting\\defaultSendOperationsAsTrace.ts"],"sourcesContent":["import LRUCache from 'lru-cache';\nimport type { Trace } from 'apollo-reporting-protobuf';\nimport { iterateOverTrace } from './iterateOverTrace';\nimport { DurationHistogram } from './durationHistogram';\n\nexport function defaultSendOperationsAsTrace() {\n  // We keep an LRU cache mapping from a trace key (which consists of the\n  // operation as defined by statsReportKey, the rough duration of the\n  // operation, what minute the operation ended at, etc) to `true` if we've seen\n  // it recently. We actually split this into one cache per minute so we can\n  // throw away a full minute's worth of cache at once; we keep only the last\n  // three minutes\n  const cache = new LRUCache<string, true>({\n    // 3MiB limit, very much approximately since we can't be sure how V8 might\n    // be storing these strings internally. Though this should be enough to\n    // store a fair amount of trace keys.\n\n    // A future version of this might expose some\n    // configuration option to grow the cache, but ideally, we could do that\n    // dynamically based on the resources available to the server, and not add\n    // more configuration surface area. Hopefully the warning message will allow\n    // us to evaluate the need with more validated input from those that receive\n    // it.\n    max: Math.pow(2, 20),\n    length: (_val, key) => {\n      return (key && Buffer.byteLength(key)) || 0;\n    },\n  });\n\n  return (trace: Trace, statsReportKey: string): boolean => {\n    const endTimeSeconds = trace.endTime?.seconds;\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([\n      statsReportKey,\n      DurationHistogram.durationToBucket(trace.durationNs),\n      // What minute it started at\n      Math.floor(endTimeSeconds / 60),\n      // If the trace has an error, send one errored trace per 5 second interval\n      // instead of the normal minutely bucket a non-errored trace takes.\n      hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n    ]);\n\n    // If we've already seen something roughly like this, don't send as a trace.\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\n// Returns true if any node on the trace has errors. (If this ends up being a\n// hot spot, we can precalculate it in TraceTreeBuilder.)\nfunction traceHasErrors(trace: Trace): boolean {\n  let hasErrors = false;\n\n  function traceNodeStats(node: Trace.INode): boolean {\n    if ((node.error?.length ?? 0) > 0) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}