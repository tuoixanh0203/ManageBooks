{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ErrorsAreMissesCache = void 0;\nclass ErrorsAreMissesCache {\n  constructor(cache, logger) {\n    this.cache = cache;\n    this.logger = logger;\n  }\n  async get(key) {\n    try {\n      return await this.cache.get(key);\n    } catch (e) {\n      if (this.logger) {\n        if (e instanceof Error) {\n          this.logger.error(e.message);\n        } else {\n          this.logger.error(e);\n        }\n      }\n      return undefined;\n    }\n  }\n  async set(key, value, opts) {\n    return this.cache.set(key, value, opts);\n  }\n  async delete(key) {\n    return this.cache.delete(key);\n  }\n}\nexports.ErrorsAreMissesCache = ErrorsAreMissesCache;","map":{"version":3,"mappings":";;;;;;AAQA,MAAaA,oBAAoB;EAC/BC,YAAoBC,KAAuB,EAAUC,MAAe;IAAhD,UAAK,GAALD,KAAK;IAA4B,WAAM,GAANC,MAAM;EAAY;EAEvE,MAAMC,GAAG,CAACC,GAAW;IACnB,IAAI;MACF,OAAO,MAAM,IAAI,CAACH,KAAK,CAACE,GAAG,CAACC,GAAG,CAAC;KACjC,CAAC,OAAOC,CAAC,EAAE;MACV,IAAI,IAAI,CAACH,MAAM,EAAE;QACf,IAAIG,CAAC,YAAYC,KAAK,EAAE;UACtB,IAAI,CAACJ,MAAM,CAACK,KAAK,CAACF,CAAC,CAACG,OAAO,CAAC;SAC7B,MAAM;UACL,IAAI,CAACN,MAAM,CAACK,KAAK,CAACF,CAAC,CAAC;;;MAGxB,OAAOI,SAAS;;EAEpB;EAEA,MAAMC,GAAG,CAACN,GAAW,EAAEO,KAAQ,EAAEC,IAAuB;IACtD,OAAO,IAAI,CAACX,KAAK,CAACS,GAAG,CAACN,GAAG,EAAEO,KAAK,EAAEC,IAAI,CAAC;EACzC;EAEA,MAAMC,MAAM,CAACT,GAAW;IACtB,OAAO,IAAI,CAACH,KAAK,CAACY,MAAM,CAACT,GAAG,CAAC;EAC/B;;AAxBFU","names":["ErrorsAreMissesCache","constructor","cache","logger","get","key","e","Error","error","message","undefined","set","value","opts","delete","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\@apollo\\utils.keyvaluecache\\src\\ErrorsAreMissesCache.ts"],"sourcesContent":["import type { KeyValueCache } from \"./KeyValueCache\";\nimport type { Logger } from \"@apollo/utils.logger\";\n\n/**\n * This cache wraps a KeyValueCache and returns undefined (a cache miss) for any\n * errors thrown by the underlying cache. You can also provide a logger to\n * capture these errors rather than just swallow them.\n */\nexport class ErrorsAreMissesCache<V = string> implements KeyValueCache<V> {\n  constructor(private cache: KeyValueCache<V>, private logger?: Logger) {}\n\n  async get(key: string): Promise<V | undefined> {\n    try {\n      return await this.cache.get(key);\n    } catch (e) {\n      if (this.logger) {\n        if (e instanceof Error) {\n          this.logger.error(e.message);\n        } else {\n          this.logger.error(e);\n        }\n      }\n      return undefined;\n    }\n  }\n\n  async set(key: string, value: V, opts?: { ttl?: number }): Promise<void> {\n    return this.cache.set(key, value, opts);\n  }\n\n  async delete(key: string): Promise<boolean | void> {\n    return this.cache.delete(key);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}