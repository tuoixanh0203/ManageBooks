{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrefixingKeyValueCache = void 0;\nclass PrefixingKeyValueCache {\n  constructor(wrapped, prefix) {\n    this.wrapped = wrapped;\n    this.prefix = prefix;\n  }\n  get(key) {\n    return this.wrapped.get(this.prefix + key);\n  }\n  set(key, value, options) {\n    return this.wrapped.set(this.prefix + key, value, options);\n  }\n  delete(key) {\n    return this.wrapped.delete(this.prefix + key);\n  }\n}\nexports.PrefixingKeyValueCache = PrefixingKeyValueCache;","map":{"version":3,"mappings":";;;;;;AAYA,MAAaA,sBAAsB;EACjCC,YAAoBC,OAAyB,EAAUC,MAAc;IAAjD,YAAO,GAAPD,OAAO;IAA4B,WAAM,GAANC,MAAM;EAAW;EAExEC,GAAG,CAACC,GAAW;IACb,OAAO,IAAI,CAACH,OAAO,CAACE,GAAG,CAAC,IAAI,CAACD,MAAM,GAAGE,GAAG,CAAC;EAC5C;EACAC,GAAG,CAACD,GAAW,EAAEE,KAAQ,EAAEC,OAAiC;IAC1D,OAAO,IAAI,CAACN,OAAO,CAACI,GAAG,CAAC,IAAI,CAACH,MAAM,GAAGE,GAAG,EAAEE,KAAK,EAAEC,OAAO,CAAC;EAC5D;EACAC,MAAM,CAACJ,GAAW;IAChB,OAAO,IAAI,CAACH,OAAO,CAACO,MAAM,CAAC,IAAI,CAACN,MAAM,GAAGE,GAAG,CAAC;EAC/C;;AAXFK","names":["PrefixingKeyValueCache","constructor","wrapped","prefix","get","key","set","value","options","delete","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\@apollo\\utils.keyvaluecache\\src\\PrefixingKeyValueCache.ts"],"sourcesContent":["import type { KeyValueCache, KeyValueCacheSetOptions } from \".\";\n\n// PrefixingKeyValueCache wraps another cache and adds a prefix to all keys used\n// by all operations. This allows multiple features to share the same underlying\n// cache without conflicts.\n//\n// Note that PrefixingKeyValueCache explicitly does not implement methods like\n// flush() that aren't part of KeyValueCache, even though most KeyValueCache\n// implementations also have a flush() method. Most implementations of flush()\n// send a simple command that wipes the entire backend cache system, which\n// wouldn't support \"only wipe the part of the cache with this prefix\", so\n// trying to provide a flush() method here could be confusingly dangerous.\nexport class PrefixingKeyValueCache<V = string> implements KeyValueCache<V> {\n  constructor(private wrapped: KeyValueCache<V>, private prefix: string) {}\n\n  get(key: string) {\n    return this.wrapped.get(this.prefix + key);\n  }\n  set(key: string, value: V, options?: KeyValueCacheSetOptions) {\n    return this.wrapped.set(this.prefix + key, value, options);\n  }\n  delete(key: string) {\n    return this.wrapped.delete(this.prefix + key);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}