{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cloneObject = exports.processHTTPRequest = exports.runHttpQuery = exports.throwHttpGraphQLError = exports.isHttpQueryError = exports.HttpQueryError = void 0;\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst whatwg_mimetype_1 = __importDefault(require(\"whatwg-mimetype\"));\nconst cachePolicy_1 = require(\"./cachePolicy\");\nconst graphqlOptions_1 = require(\"./graphqlOptions\");\nconst requestPipeline_1 = require(\"./requestPipeline\");\nclass HttpQueryError extends Error {\n  constructor(statusCode, message) {\n    let isGraphQLError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let headers = arguments.length > 3 ? arguments[3] : undefined;\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n}\nexports.HttpQueryError = HttpQueryError;\nfunction isHttpQueryError(e) {\n  return (e === null || e === void 0 ? void 0 : e.name) === 'HttpQueryError';\n}\nexports.isHttpQueryError = isHttpQueryError;\nfunction throwHttpGraphQLError(statusCode, errors, options, extensions, headers) {\n  const allHeaders = {\n    'Content-Type': 'application/json'\n  };\n  if (headers) {\n    for (const [name, value] of headers) {\n      allHeaders[name] = value;\n    }\n  }\n  const result = {\n    errors: options ? (0, apollo_server_errors_1.formatApolloErrors)(errors, {\n      debug: options.debug,\n      formatter: options.formatError\n    }) : errors\n  };\n  if (extensions) {\n    result.extensions = extensions;\n  }\n  throw new HttpQueryError(statusCode, prettyJSONStringify(result), true, allHeaders);\n}\nexports.throwHttpGraphQLError = throwHttpGraphQLError;\nconst NODE_ENV = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : '';\nconst NON_PREFLIGHTED_CONTENT_TYPES = ['application/x-www-form-urlencoded', 'multipart/form-data', 'text/plain'];\nfunction preventCsrf(headers, csrfPreventionRequestHeaders) {\n  const contentType = headers.get('content-type');\n  if (contentType !== null) {\n    const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);\n    if (contentTypeParsed === null) {\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      return;\n    }\n  }\n  if (csrfPreventionRequestHeaders.some(header => {\n    const value = headers.get(header);\n    return value !== null && value.length > 0;\n  })) {\n    return;\n  }\n  throw new HttpQueryError(400, `This operation has been blocked as a potential Cross-Site Request Forgery ` + `(CSRF). Please either specify a 'content-type' header (with a type that ` + `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` + `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(', ')}\\n`);\n}\nasync function runHttpQuery(handlerArguments, request, csrfPreventionRequestHeaders) {\n  function debugFromNodeEnv() {\n    let nodeEnv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NODE_ENV;\n    return nodeEnv !== 'production' && nodeEnv !== 'test';\n  }\n  if (csrfPreventionRequestHeaders) {\n    preventCsrf(request.request.headers, csrfPreventionRequestHeaders);\n  }\n  let options;\n  try {\n    options = await (0, graphqlOptions_1.resolveGraphqlOptions)(request.options, ...handlerArguments);\n  } catch (e) {\n    return throwHttpGraphQLError(500, [e], {\n      debug: debugFromNodeEnv()\n    });\n  }\n  if (options.debug === undefined) {\n    options.debug = debugFromNodeEnv(options.nodeEnv);\n  }\n  if (typeof options.context === 'function') {\n    try {\n      options.context();\n    } catch (e) {\n      e.message = `Context creation failed: ${e.message}`;\n      if (e.extensions && e.extensions.code && e.extensions.code !== 'INTERNAL_SERVER_ERROR') {\n        return throwHttpGraphQLError(400, [e], options);\n      } else {\n        return throwHttpGraphQLError(500, [e], options);\n      }\n    }\n  }\n  const config = {\n    schema: options.schema,\n    schemaHash: options.schemaHash,\n    logger: options.logger,\n    rootValue: options.rootValue,\n    context: options.context || {},\n    validationRules: options.validationRules,\n    executor: options.executor,\n    fieldResolver: options.fieldResolver,\n    cache: options.cache,\n    dataSources: options.dataSources,\n    documentStore: options.documentStore,\n    persistedQueries: options.persistedQueries,\n    formatError: options.formatError,\n    formatResponse: options.formatResponse,\n    debug: options.debug,\n    plugins: options.plugins || [],\n    allowBatchedHttpRequests: options.allowBatchedHttpRequests\n  };\n  return processHTTPRequest(config, request);\n}\nexports.runHttpQuery = runHttpQuery;\nasync function processHTTPRequest(options, httpRequest) {\n  var _a, _b;\n  let requestPayload;\n  switch (httpRequest.method) {\n    case 'POST':\n      if (!httpRequest.query || typeof httpRequest.query === 'string' || Buffer.isBuffer(httpRequest.query) || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'POST body missing, invalid Content-Type, or JSON object has no keys.');\n      }\n      requestPayload = httpRequest.query;\n      break;\n    case 'GET':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'GET query missing.');\n      }\n      requestPayload = httpRequest.query;\n      break;\n    default:\n      throw new HttpQueryError(405, 'Apollo Server supports only GET/POST requests.', false, {\n        Allow: 'GET, POST'\n      });\n  }\n  options = {\n    ...options,\n    plugins: [checkOperationPlugin, ...options.plugins]\n  };\n  function buildRequestContext(request, requestIsBatched) {\n    const context = cloneObject(options.context);\n    return {\n      logger: options.logger || console,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request,\n      response: {\n        http: {\n          headers: new apollo_server_env_1.Headers()\n        }\n      },\n      context,\n      cache: options.cache,\n      debug: options.debug,\n      metrics: {},\n      overallCachePolicy: (0, cachePolicy_1.newCachePolicy)(),\n      requestIsBatched\n    };\n  }\n  const responseInit = {\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  };\n  let body;\n  try {\n    if (Array.isArray(requestPayload)) {\n      if (options.allowBatchedHttpRequests === false) {\n        return throwHttpGraphQLError(400, [new Error('Operation batching disabled.')], options);\n      }\n      const requests = requestPayload.map(requestParams => parseGraphQLRequest(httpRequest.request, requestParams));\n      const responses = await Promise.all(requests.map(async request => {\n        try {\n          const requestContext = buildRequestContext(request, true);\n          const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n          if (response.http) {\n            for (const [name, value] of response.http.headers) {\n              responseInit.headers[name] = value;\n            }\n            if (response.http.status) {\n              responseInit.status = response.http.status;\n            }\n          }\n          return response;\n        } catch (error) {\n          return {\n            errors: (0, apollo_server_errors_1.formatApolloErrors)([error], options)\n          };\n        }\n      }));\n      body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n    } else {\n      const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n      const requestContext = buildRequestContext(request, false);\n      const response = await (0, requestPipeline_1.processGraphQLRequest)(options, requestContext);\n      if (response.errors && typeof response.data === 'undefined') {\n        return throwHttpGraphQLError(((_a = response.http) === null || _a === void 0 ? void 0 : _a.status) || 400, response.errors, undefined, response.extensions, (_b = response.http) === null || _b === void 0 ? void 0 : _b.headers);\n      }\n      if (response.http) {\n        for (const [name, value] of response.http.headers) {\n          responseInit.headers[name] = value;\n        }\n        if (response.http.status) {\n          responseInit.status = response.http.status;\n        }\n      }\n      body = prettyJSONStringify(serializeGraphQLResponse(response));\n    }\n  } catch (error) {\n    if (error instanceof HttpQueryError) {\n      throw error;\n    }\n    return throwHttpGraphQLError(500, [error], options);\n  }\n  responseInit.headers['Content-Length'] = Buffer.byteLength(body, 'utf8').toString();\n  return {\n    graphqlResponse: body,\n    responseInit\n  };\n}\nexports.processHTTPRequest = processHTTPRequest;\nfunction parseGraphQLRequest(httpRequest, requestParams) {\n  let queryString = requestParams.query;\n  let extensions = requestParams.extensions;\n  if (typeof extensions === 'string' && extensions !== '') {\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n  if (queryString && typeof queryString !== 'string') {\n    if (queryString.kind === 'Document') {\n      throw new HttpQueryError(400, \"GraphQL queries must be strings. It looks like you're sending the \" + 'internal graphql-js representation of a parsed query in your ' + 'request instead of a request in the GraphQL query language. You ' + 'can convert an AST to a string using the `print` function from ' + '`graphql`, or use a client like `apollo-client` which converts ' + 'the internal representation to a string for you.');\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n  const operationName = requestParams.operationName;\n  let variables = requestParams.variables;\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest\n  };\n}\nconst checkOperationPlugin = {\n  async requestDidStart() {\n    return {\n      async didResolveOperation(_ref) {\n        let {\n          request,\n          operation\n        } = _ref;\n        if (!request.http) return;\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(405, `GET supports only query operation`, false, {\n            Allow: 'POST'\n          });\n        }\n      }\n    };\n  }\n};\nfunction serializeGraphQLResponse(response) {\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions\n  };\n}\nfunction prettyJSONStringify(value) {\n  return JSON.stringify(value) + '\\n';\n}\nfunction cloneObject(object) {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\nexports.cloneObject = cloneObject;","map":{"version":3,"mappings":"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","names":["HttpQueryError","Error","constructor","statusCode","message","isGraphQLError","headers","name","exports","isHttpQueryError","e","throwHttpGraphQLError","errors","options","extensions","allHeaders","value","result","debug","formatter","formatError","prettyJSONStringify","NODE_ENV","env","NON_PREFLIGHTED_CONTENT_TYPES","preventCsrf","csrfPreventionRequestHeaders","contentType","get","contentTypeParsed","whatwg_mimetype_1","parse","includes","essence","some","header","length","join","runHttpQuery","handlerArguments","request","debugFromNodeEnv","nodeEnv","undefined","context","code","config","schema","schemaHash","logger","rootValue","validationRules","executor","fieldResolver","cache","dataSources","documentStore","persistedQueries","formatResponse","plugins","allowBatchedHttpRequests","processHTTPRequest","httpRequest","requestPayload","method","query","Buffer","isBuffer","Object","keys","Allow","checkOperationPlugin","buildRequestContext","requestIsBatched","cloneObject","console","response","http","apollo_server_env_1","metrics","overallCachePolicy","responseInit","body","Array","isArray","requests","map","requestParams","parseGraphQLRequest","responses","Promise","all","requestContext","status","error","serializeGraphQLResponse","data","byteLength","toString","graphqlResponse","queryString","JSON","kind","operationName","variables","requestDidStart","didResolveOperation","operation","stringify","object","assign","create","getPrototypeOf"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\runHttpQuery.ts"],"sourcesContent":["import { Headers, Request } from 'apollo-server-env';\nimport { ApolloError, formatApolloErrors } from 'apollo-server-errors';\nimport type { ApolloServerPlugin } from 'apollo-server-plugin-base';\nimport type {\n  BaseContext,\n  GraphQLExecutionResult,\n  ValueOrPromise,\n  WithRequired,\n} from 'apollo-server-types';\nimport MIMEType from 'whatwg-mimetype';\nimport { newCachePolicy } from './cachePolicy';\nimport {\n  default as GraphQLOptions,\n  resolveGraphqlOptions,\n} from './graphqlOptions';\nimport {\n  GraphQLRequest,\n  GraphQLRequestContext,\n  GraphQLResponse,\n  processGraphQLRequest,\n} from './requestPipeline';\n\nexport interface HttpQueryRequest {\n  method: string;\n  // query is either the POST body or the GET query string map.  In the GET\n  // case, all values are strings and need to be parsed as JSON; in the POST\n  // case they should already be parsed. query has keys like 'query' (whose\n  // value should always be a string), 'variables', 'operationName',\n  // 'extensions', etc.\n  query: Record<string, any> | Array<Record<string, any>>;\n  options:\n    | GraphQLOptions\n    | ((...args: Array<any>) => ValueOrPromise<GraphQLOptions>);\n  request: Pick<Request, 'url' | 'method' | 'headers'>;\n}\n\ninterface ApolloServerHttpResponse {\n  headers?: Record<string, string>;\n  status?: number;\n  // ResponseInit contains the follow, which we do not use\n  // statusText?: string;\n}\n\ninterface HttpQueryResponse {\n  // TODO: This isn't actually an individual GraphQL response, but the body\n  // of the HTTP response, which could contain multiple GraphQL responses\n  // when using batching.\n  graphqlResponse: string;\n  responseInit: ApolloServerHttpResponse;\n}\n\nexport class HttpQueryError extends Error {\n  public statusCode: number;\n  public isGraphQLError: boolean;\n  public headers?: { [key: string]: string };\n\n  constructor(\n    statusCode: number,\n    message: string,\n    isGraphQLError: boolean = false,\n    headers?: { [key: string]: string },\n  ) {\n    super(message);\n    this.name = 'HttpQueryError';\n    this.statusCode = statusCode;\n    this.isGraphQLError = isGraphQLError;\n    this.headers = headers;\n  }\n}\n\nexport function isHttpQueryError(e: unknown): e is HttpQueryError {\n  return (e as any)?.name === 'HttpQueryError';\n}\n\n/**\n * If options is specified, then the errors array will be formatted\n */\nexport function throwHttpGraphQLError<E extends Error>(\n  statusCode: number,\n  errors: Array<E>,\n  options?: Pick<GraphQLOptions, 'debug' | 'formatError'>,\n  extensions?: GraphQLExecutionResult['extensions'],\n  headers?: Headers,\n): never {\n  const allHeaders: Record<string, string> = {\n    'Content-Type': 'application/json',\n  };\n  if (headers) {\n    for (const [name, value] of headers) {\n      allHeaders[name] = value;\n    }\n  }\n\n  type Result = Pick<GraphQLExecutionResult, 'extensions'> & {\n    errors: E[] | ApolloError[];\n  };\n\n  const result: Result = {\n    errors: options\n      ? formatApolloErrors(errors, {\n          debug: options.debug,\n          formatter: options.formatError,\n        })\n      : errors,\n  };\n\n  if (extensions) {\n    result.extensions = extensions;\n  }\n\n  throw new HttpQueryError(\n    statusCode,\n    prettyJSONStringify(result),\n    true,\n    allHeaders,\n  );\n}\n\nconst NODE_ENV = process.env.NODE_ENV ?? '';\n\n// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header\nconst NON_PREFLIGHTED_CONTENT_TYPES = [\n  'application/x-www-form-urlencoded',\n  'multipart/form-data',\n  'text/plain',\n];\n\n// We don't want random websites to be able to execute actual GraphQL operations\n// from a user's browser unless our CORS policy supports it. It's not good\n// enough just to ensure that the browser can't read the response from the\n// operation; we also want to prevent CSRF, where the attacker can cause side\n// effects with an operation or can measure the timing of a read operation. Our\n// goal is to ensure that we don't run the context function or execute the\n// GraphQL operation until the browser has evaluated the CORS policy, which\n// means we want all operations to be pre-flighted. We can do that by only\n// processing operations that have at least one header set that appears to be\n// manually set by the JS code rather than by the browser automatically.\n//\n// POST requests generally have a content-type `application/json`, which is\n// sufficient to trigger preflighting. So we take extra care with requests that\n// specify no content-type or that specify one of the three non-preflighted\n// content types. For those operations, we require (if this feature is enabled)\n// one of a set of specific headers to be set. By ensuring that every operation\n// either has a custom content-type or sets one of these headers, we know we\n// won't execute operations at the request of origins who our CORS policy will\n// block.\nfunction preventCsrf(headers: Headers, csrfPreventionRequestHeaders: string[]) {\n  const contentType = headers.get('content-type');\n\n  // We have to worry about CSRF if it looks like this may have been a\n  // non-preflighted request. If we see a content-type header that is not one of\n  // the three CORS-safelisted MIME types (see\n  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know\n  // it was preflighted and we don't have to worry.\n  if (contentType !== null) {\n    const contentTypeParsed = MIMEType.parse(contentType);\n    if (contentTypeParsed === null) {\n      // If we got null, then parsing the content-type failed... which is\n      // actually *ok* because that would lead to a preflight. (For example, the\n      // header is empty, or doesn't have a slash, or has bad characters.) The\n      // scary CSRF case is only if there's *not* an error. So it is actually\n      // fine for us to just `return` here. (That said, it would also be\n      // reasonable to reject such requests with provided yet unparsable\n      // Content-Type here.)\n      return;\n    }\n    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {\n      // We managed to parse a MIME type that was not one of the\n      // CORS-safelisted ones. (Probably application/json!) That means that if\n      // the client is a browser, the browser must have applied CORS\n      // preflighting and we don't have to worry about CSRF.\n      return;\n    }\n  }\n\n  // Either there was no content-type, or the content-type parsed properly as\n  // one of the three CORS-safelisted values. Let's look for another header that\n  // (if this was a browser) must have been set by the user's code and would\n  // have caused a preflight.\n  if (\n    csrfPreventionRequestHeaders.some((header) => {\n      const value = headers.get(header);\n      return value !== null && value.length > 0;\n    })\n  ) {\n    return;\n  }\n\n  throw new HttpQueryError(\n    400,\n    `This operation has been blocked as a potential Cross-Site Request Forgery ` +\n      `(CSRF). Please either specify a 'content-type' header (with a type that ` +\n      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +\n      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(\n        ', ',\n      )}\\n`,\n  );\n}\n\nexport async function runHttpQuery(\n  handlerArguments: Array<any>,\n  request: HttpQueryRequest,\n  csrfPreventionRequestHeaders?: string[] | null,\n): Promise<HttpQueryResponse> {\n  function debugFromNodeEnv(nodeEnv: string = NODE_ENV) {\n    return nodeEnv !== 'production' && nodeEnv !== 'test';\n  }\n\n  // If enabled, check to ensure that this request was preflighted before doing\n  // anything real (such as running the context function).\n  if (csrfPreventionRequestHeaders) {\n    preventCsrf(request.request.headers, csrfPreventionRequestHeaders);\n  }\n\n  let options: GraphQLOptions;\n  try {\n    options = await resolveGraphqlOptions(request.options, ...handlerArguments);\n  } catch (e) {\n    // The options can be generated asynchronously, so we don't have access to\n    // the normal options provided by the user, such as: formatError,\n    // debug. Therefore, we need to do some unnatural things, such\n    // as use NODE_ENV to determine the debug settings. Please note that this\n    // will not be sensitive to any runtime changes made to NODE_ENV.\n    return throwHttpGraphQLError(500, [e as Error], {\n      debug: debugFromNodeEnv(),\n    });\n  }\n\n  if (options.debug === undefined) {\n    options.debug = debugFromNodeEnv(options.nodeEnv);\n  }\n\n  // TODO: Errors thrown while resolving the context in\n  // ApolloServer#graphQLServerOptions are currently converted to\n  // a throwing function, which we invoke here to rethrow an HTTP error.\n  // When we refactor the integration between ApolloServer, the middleware and\n  // runHttpQuery, we should pass the original context function through,\n  // so we can resolve it on every GraphQL request (as opposed to once per HTTP\n  // request, which could be a batch).\n  if (typeof options.context === 'function') {\n    try {\n      (options.context as () => never)();\n    } catch (e: any) {\n      // XXX `any` isn't ideal, but this is the easiest thing for now, without\n      // introducing a strong `instanceof GraphQLError` requirement.\n      e.message = `Context creation failed: ${e.message}`;\n      // For errors that are not internal, such as authentication, we\n      // should provide a 400 response\n      if (\n        e.extensions &&\n        e.extensions.code &&\n        e.extensions.code !== 'INTERNAL_SERVER_ERROR'\n      ) {\n        return throwHttpGraphQLError(400, [e], options);\n      } else {\n        return throwHttpGraphQLError(500, [e], options);\n      }\n    }\n  }\n\n  const config = {\n    schema: options.schema,\n    schemaHash: options.schemaHash,\n    logger: options.logger,\n    rootValue: options.rootValue,\n    context: options.context || {},\n    validationRules: options.validationRules,\n    executor: options.executor,\n    fieldResolver: options.fieldResolver,\n\n    // TODO: Use proper option types to ensure this\n    // The cache is guaranteed to be initialized in ApolloServer, and\n    // cacheControl defaults will also have been set if a boolean argument is\n    // passed in.\n    cache: options.cache!,\n    dataSources: options.dataSources,\n    documentStore: options.documentStore,\n\n    persistedQueries: options.persistedQueries,\n\n    formatError: options.formatError,\n    formatResponse: options.formatResponse,\n\n    debug: options.debug,\n\n    plugins: options.plugins || [],\n\n    allowBatchedHttpRequests: options.allowBatchedHttpRequests,\n  };\n\n  return processHTTPRequest(config, request);\n}\n\nexport async function processHTTPRequest<TContext extends BaseContext>(\n  options: WithRequired<GraphQLOptions<TContext>, 'cache' | 'plugins'> & {\n    context: TContext;\n  },\n  httpRequest: HttpQueryRequest,\n): Promise<HttpQueryResponse> {\n  let requestPayload;\n\n  switch (httpRequest.method) {\n    case 'POST':\n      if (\n        !httpRequest.query ||\n        typeof httpRequest.query === 'string' ||\n        Buffer.isBuffer(httpRequest.query) ||\n        Object.keys(httpRequest.query).length === 0\n      ) {\n        throw new HttpQueryError(\n          400,\n          'POST body missing, invalid Content-Type, or JSON object has no keys.',\n        );\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n    case 'GET':\n      if (!httpRequest.query || Object.keys(httpRequest.query).length === 0) {\n        throw new HttpQueryError(400, 'GET query missing.');\n      }\n\n      requestPayload = httpRequest.query;\n      break;\n\n    default:\n      throw new HttpQueryError(\n        405,\n        'Apollo Server supports only GET/POST requests.',\n        false,\n        {\n          Allow: 'GET, POST',\n        },\n      );\n  }\n\n  // Create a local copy of `options`, based on global options, but maintaining\n  // that appropriate plugins are in place.\n  options = {\n    ...options,\n    plugins: [checkOperationPlugin, ...options.plugins],\n  };\n\n  function buildRequestContext(\n    request: GraphQLRequest,\n    requestIsBatched: boolean,\n  ): GraphQLRequestContext<TContext> {\n    // TODO: We currently shallow clone the context for every request,\n    // but that's unlikely to be what people want.\n    // We allow passing in a function for `context` to ApolloServer,\n    // but this only runs once for a batched request (because this is resolved\n    // in ApolloServer#graphQLServerOptions, before runHttpQuery is invoked).\n    // NOTE: THIS IS DUPLICATED IN ApolloServerBase.prototype.executeOperation.\n    const context = cloneObject(options.context);\n    return {\n      // While `logger` is guaranteed by internal Apollo Server usage of\n      // this `processHTTPRequest` method, this method has been publicly\n      // exported since perhaps as far back as Apollo Server 1.x.  Therefore,\n      // for compatibility reasons, we'll default to `console`.\n      logger: options.logger || console,\n      schema: options.schema,\n      schemaHash: options.schemaHash,\n      request,\n      response: {\n        http: {\n          headers: new Headers(),\n        },\n      },\n      context,\n      cache: options.cache,\n      debug: options.debug,\n      metrics: {},\n      overallCachePolicy: newCachePolicy(),\n      requestIsBatched,\n    };\n  }\n\n  const responseInit: ApolloServerHttpResponse = {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n\n  let body: string;\n\n  try {\n    if (Array.isArray(requestPayload)) {\n      if (options.allowBatchedHttpRequests === false) {\n        return throwHttpGraphQLError(\n          400,\n          [new Error('Operation batching disabled.')],\n          options,\n        );\n      }\n\n      // We're processing a batch request\n      const requests = requestPayload.map((requestParams) =>\n        parseGraphQLRequest(httpRequest.request, requestParams),\n      );\n\n      const responses = await Promise.all(\n        requests.map(async (request) => {\n          try {\n            const requestContext = buildRequestContext(request, true);\n            const response = await processGraphQLRequest(\n              options,\n              requestContext,\n            );\n            if (response.http) {\n              for (const [name, value] of response.http.headers) {\n                responseInit.headers![name] = value;\n              }\n\n              if (response.http.status) {\n                responseInit.status = response.http.status;\n              }\n            }\n            return response;\n          } catch (error) {\n            // A batch can contain another query that returns data,\n            // so we don't error out the entire request with an HttpError\n            return {\n              errors: formatApolloErrors([error as Error], options),\n            };\n          }\n        }),\n      );\n\n      body = prettyJSONStringify(responses.map(serializeGraphQLResponse));\n    } else {\n      // We're processing a normal request\n      const request = parseGraphQLRequest(httpRequest.request, requestPayload);\n\n      const requestContext = buildRequestContext(request, false);\n\n      const response = await processGraphQLRequest(options, requestContext);\n\n      // This code is run on parse/validation errors and any other error that\n      // doesn't reach GraphQL execution\n      if (response.errors && typeof response.data === 'undefined') {\n        // don't include options, since the errors have already been formatted\n        return throwHttpGraphQLError(\n          response.http?.status || 400,\n          response.errors as any,\n          undefined,\n          response.extensions,\n          response.http?.headers,\n        );\n      }\n\n      if (response.http) {\n        for (const [name, value] of response.http.headers) {\n          responseInit.headers![name] = value;\n        }\n\n        if (response.http.status) {\n          responseInit.status = response.http.status;\n        }\n      }\n\n      body = prettyJSONStringify(serializeGraphQLResponse(response));\n    }\n  } catch (error) {\n    if (error instanceof HttpQueryError) {\n      throw error;\n    }\n    return throwHttpGraphQLError(500, [error as Error], options);\n  }\n\n  responseInit.headers!['Content-Length'] = Buffer.byteLength(\n    body,\n    'utf8',\n  ).toString();\n\n  return {\n    graphqlResponse: body,\n    responseInit,\n  };\n}\n\nfunction parseGraphQLRequest(\n  httpRequest: Pick<Request, 'url' | 'method' | 'headers'>,\n  requestParams: Record<string, any>,\n): GraphQLRequest {\n  let queryString: string | undefined = requestParams.query;\n  let extensions = requestParams.extensions;\n\n  if (typeof extensions === 'string' && extensions !== '') {\n    // For GET requests, we have to JSON-parse extensions. (For POST\n    // requests they get parsed as part of parsing the larger body they're\n    // inside.)\n    try {\n      extensions = JSON.parse(extensions);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Extensions are invalid JSON.');\n    }\n  }\n\n  if (queryString && typeof queryString !== 'string') {\n    // Check for a common error first.\n    if ((queryString as any).kind === 'Document') {\n      throw new HttpQueryError(\n        400,\n        \"GraphQL queries must be strings. It looks like you're sending the \" +\n          'internal graphql-js representation of a parsed query in your ' +\n          'request instead of a request in the GraphQL query language. You ' +\n          'can convert an AST to a string using the `print` function from ' +\n          '`graphql`, or use a client like `apollo-client` which converts ' +\n          'the internal representation to a string for you.',\n      );\n    } else {\n      throw new HttpQueryError(400, 'GraphQL queries must be strings.');\n    }\n  }\n\n  const operationName = requestParams.operationName;\n\n  let variables = requestParams.variables;\n  if (typeof variables === 'string' && variables !== '') {\n    try {\n      // XXX Really we should only do this for GET requests, but for\n      // compatibility reasons we'll keep doing this at least for now for\n      // broken clients that ship variables in a string for no good reason.\n      variables = JSON.parse(variables);\n    } catch (error) {\n      throw new HttpQueryError(400, 'Variables are invalid JSON.');\n    }\n  }\n\n  return {\n    query: queryString,\n    operationName,\n    variables,\n    extensions,\n    http: httpRequest,\n  };\n}\n\n// GET operations should only be queries (not mutations). We want to throw\n// a particular HTTP error in that case.\nconst checkOperationPlugin: ApolloServerPlugin = {\n  async requestDidStart() {\n    return {\n      async didResolveOperation({ request, operation }) {\n        if (!request.http) return;\n\n        if (request.http.method === 'GET' && operation.operation !== 'query') {\n          throw new HttpQueryError(\n            405,\n            `GET supports only query operation`,\n            false,\n            {\n              Allow: 'POST',\n            },\n          );\n        }\n      },\n    };\n  },\n};\n\nfunction serializeGraphQLResponse(\n  response: GraphQLResponse,\n): Pick<GraphQLResponse, 'errors' | 'data' | 'extensions'> {\n  // See https://github.com/facebook/graphql/pull/384 for why\n  // errors comes first.\n  return {\n    errors: response.errors,\n    data: response.data,\n    extensions: response.extensions,\n  };\n}\n\n// The result of a curl does not appear well in the terminal, so we add an extra new line\nfunction prettyJSONStringify(value: any) {\n  return JSON.stringify(value) + '\\n';\n}\n\nexport function cloneObject<T extends Object>(object: T): T {\n  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}