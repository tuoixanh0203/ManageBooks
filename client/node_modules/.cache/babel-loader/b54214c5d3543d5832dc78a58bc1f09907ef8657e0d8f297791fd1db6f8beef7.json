{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.whenResultIsFinished = exports.pluginsEnabledForSchemaResolvers = exports.enablePluginsForSchemaResolvers = exports.symbolUserFieldResolver = exports.symbolExecutionDispatcherWillResolveField = void 0;\nconst type_1 = require(\"graphql/type\");\nconst execution_1 = require(\"graphql/execution\");\nexports.symbolExecutionDispatcherWillResolveField = Symbol('apolloServerExecutionDispatcherWillResolveField');\nexports.symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');\nconst symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');\nfunction enablePluginsForSchemaResolvers(schema) {\n  if (pluginsEnabledForSchemaResolvers(schema)) {\n    return schema;\n  }\n  Object.defineProperty(schema, symbolPluginsEnabled, {\n    value: true\n  });\n  forEachField(schema, wrapField);\n  return schema;\n}\nexports.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;\nfunction pluginsEnabledForSchemaResolvers(schema) {\n  return !!schema[symbolPluginsEnabled];\n}\nexports.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;\nfunction wrapField(field) {\n  const originalFieldResolve = field.resolve;\n  field.resolve = (source, args, context, info) => {\n    const parentPath = info.path.prev;\n    const willResolveField = context === null || context === void 0 ? void 0 : context[exports.symbolExecutionDispatcherWillResolveField];\n    const userFieldResolver = context === null || context === void 0 ? void 0 : context[exports.symbolUserFieldResolver];\n    const didResolveField = typeof willResolveField === 'function' && willResolveField({\n      source,\n      args,\n      context,\n      info\n    });\n    const resolveObject = info.parentType.resolveObject;\n    let whenObjectResolved;\n    if (parentPath && resolveObject) {\n      if (!parentPath.__fields) {\n        parentPath.__fields = {};\n      }\n      parentPath.__fields[info.fieldName] = info.fieldNodes;\n      whenObjectResolved = parentPath.__whenObjectResolved;\n      if (!whenObjectResolved) {\n        whenObjectResolved = Promise.resolve().then(() => {\n          return resolveObject(source, parentPath.__fields, context, info);\n        });\n        parentPath.__whenObjectResolved = whenObjectResolved;\n      }\n    }\n    const fieldResolver = originalFieldResolve || userFieldResolver || execution_1.defaultFieldResolver;\n    try {\n      let result;\n      if (whenObjectResolved) {\n        result = whenObjectResolved.then(resolvedObject => {\n          return fieldResolver(resolvedObject, args, context, info);\n        });\n      } else {\n        result = fieldResolver(source, args, context, info);\n      }\n      if (typeof didResolveField === 'function') {\n        whenResultIsFinished(result, didResolveField);\n      }\n      return result;\n    } catch (error) {\n      if (typeof didResolveField === 'function') {\n        didResolveField(error);\n      }\n      throw error;\n    }\n  };\n}\nfunction isPromise(x) {\n  return x && typeof x.then === 'function';\n}\nfunction whenResultIsFinished(result, callback) {\n  if (isPromise(result)) {\n    result.then(r => callback(null, r), err => callback(err));\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(r => callback(null, r), err => callback(err));\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\nexports.whenResultIsFinished = whenResultIsFinished;\nfunction forEachField(schema, fn) {\n  const typeMap = schema.getTypeMap();\n  Object.entries(typeMap).forEach(_ref => {\n    let [typeName, type] = _ref;\n    if (!(0, type_1.getNamedType)(type).name.startsWith('__') && type instanceof type_1.GraphQLObjectType) {\n      const fields = type.getFields();\n      Object.entries(fields).forEach(_ref2 => {\n        let [fieldName, field] = _ref2;\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["exports","Symbol","symbolPluginsEnabled","enablePluginsForSchemaResolvers","schema","pluginsEnabledForSchemaResolvers","Object","defineProperty","value","forEachField","wrapField","field","originalFieldResolve","resolve","source","args","context","info","parentPath","path","prev","willResolveField","userFieldResolver","didResolveField","resolveObject","parentType","whenObjectResolved","__fields","fieldName","fieldNodes","__whenObjectResolved","Promise","then","fieldResolver","execution_1","result","resolvedObject","whenResultIsFinished","error","isPromise","x","callback","r","err","Array","isArray","some","all","fn","typeMap","getTypeMap","entries","forEach","typeName","type","name","startsWith","type_1","fields","getFields"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\utils\\schemaInstrumentation.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLField,\n  ResponsePath,\n  getNamedType,\n  GraphQLObjectType,\n  GraphQLFieldResolver,\n} from 'graphql/type';\nimport { defaultFieldResolver } from 'graphql/execution';\nimport type { FieldNode } from 'graphql/language';\nimport type { GraphQLRequestExecutionListener } from 'apollo-server-plugin-base';\nimport type { GraphQLObjectResolver } from '@apollographql/apollo-tools';\n\nexport const symbolExecutionDispatcherWillResolveField = Symbol(\n  'apolloServerExecutionDispatcherWillResolveField',\n);\nexport const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');\nconst symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');\n\nexport function enablePluginsForSchemaResolvers(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n) {\n  if (pluginsEnabledForSchemaResolvers(schema)) {\n    return schema;\n  }\n  Object.defineProperty(schema, symbolPluginsEnabled, {\n    value: true,\n  });\n\n  forEachField(schema, wrapField);\n\n  return schema;\n}\n\nexport function pluginsEnabledForSchemaResolvers(\n  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },\n): boolean {\n  return !!schema[symbolPluginsEnabled];\n}\n\nfunction wrapField(field: GraphQLField<any, any>): void {\n  const originalFieldResolve = field.resolve;\n\n  field.resolve = (source, args, context, info) => {\n    // This is a bit of a hack, but since `ResponsePath` is a linked list,\n    // a new object gets created every time a path segment is added.\n    // So we can use that to share our `whenObjectResolved` promise across\n    // all field resolvers for the same object.\n    const parentPath = info.path.prev as ResponsePath & {\n      __fields?: Record<string, ReadonlyArray<FieldNode>>;\n      __whenObjectResolved?: Promise<any>;\n    };\n\n    const willResolveField = context?.[\n      symbolExecutionDispatcherWillResolveField\n    ] as GraphQLRequestExecutionListener['willResolveField'] | undefined;\n\n    const userFieldResolver = context?.[symbolUserFieldResolver] as\n      | GraphQLFieldResolver<any, any>\n      | undefined;\n\n    // The technique for implementing a  \"did resolve field\" is accomplished by\n    // returning a function from the `willResolveField` handler.  While there\n    // may be several callbacks, depending on the number of plugins which have\n    // implemented a `willResolveField` hook, this hook will call them all\n    // as dictated by the dispatcher.  We will call this when object\n    // resolution is complete.\n    const didResolveField =\n      typeof willResolveField === 'function' &&\n      willResolveField({ source, args, context, info });\n\n    const resolveObject: GraphQLObjectResolver<any, any> | undefined = (\n      info.parentType as any\n    ).resolveObject;\n\n    let whenObjectResolved: Promise<any> | undefined;\n\n    if (parentPath && resolveObject) {\n      if (!parentPath.__fields) {\n        parentPath.__fields = {};\n      }\n\n      parentPath.__fields[info.fieldName] = info.fieldNodes;\n\n      whenObjectResolved = parentPath.__whenObjectResolved;\n      if (!whenObjectResolved) {\n        // Use `Promise.resolve().then()` to delay executing\n        // `resolveObject()` so we can collect all the fields first.\n        whenObjectResolved = Promise.resolve().then(() => {\n          return resolveObject(source, parentPath.__fields!, context, info);\n        });\n        parentPath.__whenObjectResolved = whenObjectResolved;\n      }\n    }\n\n    const fieldResolver =\n      originalFieldResolve || userFieldResolver || defaultFieldResolver;\n\n    try {\n      let result: any;\n      if (whenObjectResolved) {\n        result = whenObjectResolved.then((resolvedObject: any) => {\n          return fieldResolver(resolvedObject, args, context, info);\n        });\n      } else {\n        result = fieldResolver(source, args, context, info);\n      }\n\n      // Call the stack's handlers either immediately (if result is not a\n      // Promise) or once the Promise is done. Then return that same\n      // maybe-Promise value.\n      if (typeof didResolveField === 'function') {\n        whenResultIsFinished(result, didResolveField);\n      }\n      return result;\n    } catch (error) {\n      // Normally it's a bad sign to see an error both handled and\n      // re-thrown. But it is useful to allow extensions to track errors while\n      // still handling them in the normal GraphQL way.\n      if (typeof didResolveField === 'function') {\n        didResolveField(error as Error);\n      }\n      throw error;\n    }\n  };\n}\n\nfunction isPromise(x: any): boolean {\n  return x && typeof x.then === 'function';\n}\n\n// Given result (which may be a Promise or an array some of whose elements are\n// promises) Promises, set up 'callback' to be invoked when result is fully\n// resolved.\nexport function whenResultIsFinished(\n  result: any,\n  callback: (err: Error | null, result?: any) => void,\n) {\n  if (isPromise(result)) {\n    result.then(\n      (r: any) => callback(null, r),\n      (err: Error) => callback(err),\n    );\n  } else if (Array.isArray(result)) {\n    if (result.some(isPromise)) {\n      Promise.all(result).then(\n        (r: any) => callback(null, r),\n        (err: Error) => callback(err),\n      );\n    } else {\n      callback(null, result);\n    }\n  } else {\n    callback(null, result);\n  }\n}\n\nfunction forEachField(schema: GraphQLSchema, fn: FieldIteratorFn): void {\n  const typeMap = schema.getTypeMap();\n  Object.entries(typeMap).forEach(([typeName, type]) => {\n    if (\n      !getNamedType(type).name.startsWith('__') &&\n      type instanceof GraphQLObjectType\n    ) {\n      const fields = type.getFields();\n      Object.entries(fields).forEach(([fieldName, field]) => {\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n\ntype FieldIteratorFn = (\n  fieldDef: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) => void;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}