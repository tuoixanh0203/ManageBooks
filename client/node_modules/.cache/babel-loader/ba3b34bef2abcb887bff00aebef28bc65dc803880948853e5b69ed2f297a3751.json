{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.healTypes = exports.healSchema = void 0;\nconst graphql_1 = require(\"graphql\");\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nfunction healSchema(schema) {\n  healTypes(schema.getTypeMap(), schema.getDirectives());\n  return schema;\n}\nexports.healSchema = healSchema;\nfunction healTypes(originalTypeMap, directives) {\n  const actualNamedTypeMap = Object.create(null);\n  // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName];\n    if (namedType == null || typeName.startsWith('__')) {\n      continue;\n    }\n    const actualName = namedType.name;\n    if (actualName.startsWith('__')) {\n      continue;\n    }\n    if (actualNamedTypeMap[actualName] != null) {\n      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);\n      continue;\n    }\n    actualNamedTypeMap[actualName] = namedType;\n    // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  }\n  // Now add back every named type by its actual name.\n  for (const typeName in actualNamedTypeMap) {\n    const namedType = actualNamedTypeMap[typeName];\n    originalTypeMap[typeName] = namedType;\n  }\n  // Directive declaration argument types can refer to named types.\n  for (const decl of directives) {\n    decl.args = decl.args.filter(arg => {\n      arg.type = healType(arg.type);\n      return arg.type !== null;\n    });\n  }\n  for (const typeName in originalTypeMap) {\n    const namedType = originalTypeMap[typeName];\n    // Heal all named types, except for dangling references, kept only to redirect.\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  }\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      delete originalTypeMap[typeName];\n    }\n  }\n  function healNamedType(type) {\n    if ((0, graphql_1.isObjectType)(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if ((0, graphql_1.isInterfaceType)(type)) {\n      healFields(type);\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n      return;\n    } else if ((0, graphql_1.isUnionType)(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if ((0, graphql_1.isInputObjectType)(type)) {\n      healInputFields(type);\n      return;\n    } else if ((0, graphql_1.isLeafType)(type)) {\n      return;\n    }\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n  function healFields(type) {\n    const fieldMap = type.getFields();\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.args.map(arg => {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      }).filter(Boolean);\n      field.type = healType(field.type);\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n  function healInterfaces(type) {\n    if ('getInterfaces' in type) {\n      const interfaces = type.getInterfaces();\n      interfaces.push(...interfaces.splice(0).map(iface => healType(iface)).filter(Boolean));\n    }\n  }\n  function healInputFields(type) {\n    const fieldMap = type.getFields();\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.type = healType(field.type);\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n  function healUnderlyingTypes(type) {\n    const types = type.getTypes();\n    types.push(...types.splice(0).map(t => healType(t)).filter(Boolean));\n  }\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if ((0, graphql_1.isListType)(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new graphql_1.GraphQLList(healedType) : null;\n    } else if ((0, graphql_1.isNonNullType)(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;\n    } else if ((0, graphql_1.isNamedType)(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      const officialType = originalTypeMap[type.name];\n      if (officialType && type !== officialType) {\n        return officialType;\n      }\n    }\n    return type;\n  }\n}\nexports.healTypes = healTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","healTypes","healSchema","graphql_1","require","schema","getTypeMap","getDirectives","originalTypeMap","directives","actualNamedTypeMap","create","typeName","namedType","startsWith","actualName","name","console","warn","decl","args","filter","arg","type","healType","healNamedType","isObjectType","healFields","healInterfaces","isInterfaceType","isUnionType","healUnderlyingTypes","isInputObjectType","healInputFields","isLeafType","Error","fieldMap","getFields","key","field","entries","map","Boolean","interfaces","getInterfaces","push","splice","iface","types","getTypes","t","isListType","healedType","ofType","GraphQLList","isNonNullType","GraphQLNonNull","isNamedType","officialType"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/utils/cjs/heal.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.healTypes = exports.healSchema = void 0;\nconst graphql_1 = require(\"graphql\");\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nfunction healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nexports.healSchema = healSchema;\nfunction healTypes(originalTypeMap, directives) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            continue;\n        }\n        if (actualNamedTypeMap[actualName] != null) {\n            console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);\n            continue;\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    }\n    // Now add back every named type by its actual name.\n    for (const typeName in actualNamedTypeMap) {\n        const namedType = actualNamedTypeMap[typeName];\n        originalTypeMap[typeName] = namedType;\n    }\n    // Directive declaration argument types can refer to named types.\n    for (const decl of directives) {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    }\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    }\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    function healNamedType(type) {\n        if ((0, graphql_1.isObjectType)(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if ((0, graphql_1.isInterfaceType)(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if ((0, graphql_1.isUnionType)(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if ((0, graphql_1.isInputObjectType)(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if ((0, graphql_1.isLeafType)(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if ((0, graphql_1.isListType)(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new graphql_1.GraphQLList(healedType) : null;\n        }\n        else if ((0, graphql_1.isNonNullType)(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new graphql_1.GraphQLNonNull(healedType) : null;\n        }\n        else if ((0, graphql_1.isNamedType)(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\nexports.healTypes = healTypes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}