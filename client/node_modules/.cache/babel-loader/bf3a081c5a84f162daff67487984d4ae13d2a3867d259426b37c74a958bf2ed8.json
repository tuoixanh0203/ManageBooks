{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GatewayIsTooOldError = exports.SchemaManager = void 0;\nclass SchemaManager {\n  constructor(options) {\n    this.onSchemaLoadOrUpdateListeners = new Set();\n    this.isStopped = false;\n    this.logger = options.logger;\n    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;\n    if ('gateway' in options) {\n      this.modeSpecificState = {\n        mode: 'gateway',\n        gateway: options.gateway,\n        apolloConfig: options.apolloConfig\n      };\n    } else {\n      this.modeSpecificState = {\n        mode: 'schema',\n        apiSchema: options.apiSchema,\n        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema)\n      };\n    }\n  }\n  async start() {\n    if (this.modeSpecificState.mode === 'gateway') {\n      const gateway = this.modeSpecificState.gateway;\n      if (gateway.onSchemaLoadOrUpdate) {\n        this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaLoadOrUpdate(schemaContext => {\n          this.processSchemaLoadOrUpdateEvent(schemaContext);\n        });\n      } else if (gateway.onSchemaChange) {\n        this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange(apiSchema => {\n          this.processSchemaLoadOrUpdateEvent({\n            apiSchema\n          });\n        });\n      } else {\n        throw new Error(\"Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway\");\n      }\n      const config = await this.modeSpecificState.gateway.load({\n        apollo: this.modeSpecificState.apolloConfig\n      });\n      if (!this.schemaDerivedData) {\n        this.processSchemaLoadOrUpdateEvent({\n          apiSchema: config.schema\n        });\n      }\n      return config.executor;\n    } else {\n      this.processSchemaLoadOrUpdateEvent({\n        apiSchema: this.modeSpecificState.apiSchema\n      }, this.modeSpecificState.schemaDerivedData);\n      return null;\n    }\n  }\n  onSchemaLoadOrUpdate(callback) {\n    if (this.modeSpecificState.mode === 'gateway' && !this.modeSpecificState.gateway.onSchemaLoadOrUpdate) {\n      throw new GatewayIsTooOldError([`Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`, `Please update your version of @apollo/gateway to at least 0.35.0.`].join(' '));\n    } else {\n      if (!this.schemaContext) {\n        throw new Error('You must call start() before onSchemaLoadOrUpdate()');\n      }\n      if (!this.isStopped) {\n        try {\n          callback(this.schemaContext);\n        } catch (e) {\n          throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);\n        }\n      }\n      this.onSchemaLoadOrUpdateListeners.add(callback);\n    }\n    return () => {\n      this.onSchemaLoadOrUpdateListeners.delete(callback);\n    };\n  }\n  getSchemaDerivedData() {\n    if (!this.schemaDerivedData) {\n      throw new Error('You must call start() before getSchemaDerivedData()');\n    }\n    return this.schemaDerivedData;\n  }\n  async stop() {\n    var _a, _b, _c, _d;\n    this.isStopped = true;\n    if (this.modeSpecificState.mode === 'gateway') {\n      (_b = (_a = this.modeSpecificState).unsubscribeFromGateway) === null || _b === void 0 ? void 0 : _b.call(_a);\n      await ((_d = (_c = this.modeSpecificState.gateway).stop) === null || _d === void 0 ? void 0 : _d.call(_c));\n    }\n  }\n  processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {\n    if (!this.isStopped) {\n      this.schemaDerivedData = schemaDerivedData !== null && schemaDerivedData !== void 0 ? schemaDerivedData : this.schemaDerivedDataProvider(schemaContext.apiSchema);\n      this.schemaContext = schemaContext;\n      this.onSchemaLoadOrUpdateListeners.forEach(listener => {\n        try {\n          listener(schemaContext);\n        } catch (e) {\n          this.logger.error(\"An error was thrown from an 'onSchemaLoadOrUpdate' listener\");\n          this.logger.error(e);\n        }\n      });\n    }\n  }\n}\nexports.SchemaManager = SchemaManager;\nclass GatewayIsTooOldError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nexports.GatewayIsTooOldError = GatewayIsTooOldError;","map":{"version":3,"mappings":"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","names":["SchemaManager","constructor","options","Set","logger","schemaDerivedDataProvider","modeSpecificState","mode","gateway","apolloConfig","apiSchema","schemaDerivedData","start","onSchemaLoadOrUpdate","unsubscribeFromGateway","schemaContext","processSchemaLoadOrUpdateEvent","onSchemaChange","Error","config","load","apollo","schema","executor","callback","GatewayIsTooOldError","join","isStopped","e","message","onSchemaLoadOrUpdateListeners","add","delete","getSchemaDerivedData","stop","forEach","listener","error","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\utils\\schemaManager.ts"],"sourcesContent":["import type { GraphQLSchema } from 'graphql';\nimport type {\n  ApolloConfig,\n  GraphQLExecutor,\n  GraphQLSchemaContext,\n} from 'apollo-server-types';\nimport type { Logger } from '@apollo/utils.logger';\nimport type { GatewayInterface, Unsubscriber } from '../types';\nimport type { SchemaDerivedData } from '../ApolloServer';\n\ntype SchemaDerivedDataProvider = (\n  apiSchema: GraphQLSchema,\n) => SchemaDerivedData;\n\n/**\n * An async-safe class for tracking changes in schemas and schema-derived data.\n *\n * Specifically, as long as start() is called (and completes) before stop() is\n * called, any set of executions of public methods is linearizable.\n *\n * Note that linearizability in Javascript is trivial if all public methods are\n * non-async, but increasingly difficult to guarantee if public methods become\n * async. Accordingly, if you believe a public method should be async, think\n * carefully on whether it's worth the mental overhead. (E.g. if you wished that\n * a callback was async, consider instead resolving a Promise in a non-async\n * callback and having your async code wait on the Promise in setTimeout().)\n */\nexport class SchemaManager {\n  private readonly logger: Logger;\n  private readonly schemaDerivedDataProvider: SchemaDerivedDataProvider;\n  private readonly onSchemaLoadOrUpdateListeners = new Set<\n    (schemaContext: GraphQLSchemaContext) => void\n  >();\n  private isStopped = false;\n  private schemaDerivedData?: SchemaDerivedData;\n  private schemaContext?: GraphQLSchemaContext;\n\n  // For state that's specific to the mode of operation.\n  private readonly modeSpecificState:\n    | {\n        readonly mode: 'gateway';\n        readonly gateway: GatewayInterface;\n        readonly apolloConfig: ApolloConfig;\n        unsubscribeFromGateway?: Unsubscriber;\n      }\n    | {\n        readonly mode: 'schema';\n        readonly apiSchema: GraphQLSchema;\n        readonly schemaDerivedData: SchemaDerivedData;\n      };\n\n  constructor(\n    options: (\n      | { gateway: GatewayInterface; apolloConfig: ApolloConfig }\n      | { apiSchema: GraphQLSchema }\n    ) & {\n      logger: Logger;\n      schemaDerivedDataProvider: SchemaDerivedDataProvider;\n    },\n  ) {\n    this.logger = options.logger;\n    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;\n    if ('gateway' in options) {\n      this.modeSpecificState = {\n        mode: 'gateway',\n        gateway: options.gateway,\n        apolloConfig: options.apolloConfig,\n      };\n    } else {\n      this.modeSpecificState = {\n        mode: 'schema',\n        apiSchema: options.apiSchema,\n        // The caller of the constructor expects us to fail early if the schema\n        // given is invalid/has errors, so we call the provider here. We also\n        // pass the result to start(), as the provider can be expensive to call.\n        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),\n      };\n    }\n  }\n\n  /**\n   * Calling start() will:\n   * - Start gateway schema fetching (if a gateway was provided).\n   * - Initialize schema-derived data.\n   * - Synchronously notify onSchemaLoadOrUpdate() listeners of schema load, and\n   *   asynchronously notify them of schema updates.\n   * - If we started a gateway, returns the gateway's executor; otherwise null.\n   */\n  public async start(): Promise<GraphQLExecutor | null> {\n    if (this.modeSpecificState.mode === 'gateway') {\n      const gateway = this.modeSpecificState.gateway;\n      if (gateway.onSchemaLoadOrUpdate) {\n        // Use onSchemaLoadOrUpdate if available, as it reports the core\n        // supergraph SDL and always reports the initial schema load.\n        this.modeSpecificState.unsubscribeFromGateway =\n          gateway.onSchemaLoadOrUpdate((schemaContext) => {\n            this.processSchemaLoadOrUpdateEvent(schemaContext);\n          });\n      } else if (gateway.onSchemaChange) {\n        this.modeSpecificState.unsubscribeFromGateway = gateway.onSchemaChange(\n          (apiSchema) => {\n            this.processSchemaLoadOrUpdateEvent({ apiSchema });\n          },\n        );\n      } else {\n        throw new Error(\n          \"Unexpectedly couldn't find onSchemaChange or onSchemaLoadOrUpdate on gateway\",\n        );\n      }\n\n      const config = await this.modeSpecificState.gateway.load({\n        apollo: this.modeSpecificState.apolloConfig,\n      });\n\n      // Note that for old gateways that have onSchemaChange() and no\n      // onSchemaLoadOrUpdate(), this.schemaDerivedData may not be initialized\n      // during gateway.load() (because old gateways don't notify listeners on\n      // schema load in some cases), so we must initialize it here if needed.\n      if (!this.schemaDerivedData) {\n        this.processSchemaLoadOrUpdateEvent({ apiSchema: config.schema });\n      }\n      return config.executor;\n    } else {\n      this.processSchemaLoadOrUpdateEvent(\n        {\n          apiSchema: this.modeSpecificState.apiSchema,\n        },\n        this.modeSpecificState.schemaDerivedData,\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Registers a listener for schema load/update events. Note that the latest\n   * event is buffered, i.e.\n   * - If registered before start(), this method will throw. (We have no need\n   *   for registration before start(), but this is easy enough to change.)\n   * - If registered after start() but before stop(), the callback will be first\n   *   called in this method (for whatever the current schema is), and then\n   *   later for updates.\n   * - If registered after stop(), the callback will never be called.\n   *\n   * For gateways, a core supergraph SDL will be provided to the callback. If\n   * your gateway is too old to provide a core supergraph SDL, this method will\n   * throw.\n   *\n   * @param callback The listener to execute on schema load/updates.\n   */\n  public onSchemaLoadOrUpdate(\n    callback: (schemaContext: GraphQLSchemaContext) => void,\n  ): Unsubscriber {\n    if (\n      this.modeSpecificState.mode === 'gateway' &&\n      !this.modeSpecificState.gateway.onSchemaLoadOrUpdate\n    ) {\n      throw new GatewayIsTooOldError(\n        [\n          `Your gateway is too old to register a 'onSchemaLoadOrUpdate' listener.`,\n          `Please update your version of @apollo/gateway to at least 0.35.0.`,\n        ].join(' '),\n      );\n    } else {\n      if (!this.schemaContext) {\n        throw new Error('You must call start() before onSchemaLoadOrUpdate()');\n      }\n      if (!this.isStopped) {\n        try {\n          callback(this.schemaContext);\n        } catch (e) {\n          // Note that onSchemaLoadOrUpdate() is currently only called from\n          // ApolloServerBase._start(), so we throw here to alert the user early\n          // that their callback is failing.\n          throw new Error(\n            `An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${\n              (e as Error).message\n            }`,\n          );\n        }\n      }\n      this.onSchemaLoadOrUpdateListeners.add(callback);\n    }\n\n    return () => {\n      this.onSchemaLoadOrUpdateListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Get the schema-derived state for the current schema. This throws if called\n   * before start() is called.\n   */\n  public getSchemaDerivedData(): SchemaDerivedData {\n    if (!this.schemaDerivedData) {\n      throw new Error('You must call start() before getSchemaDerivedData()');\n    }\n    return this.schemaDerivedData;\n  }\n\n  /**\n   * Calling stop() will:\n   * - Stop gateway schema fetching (if a gateway was provided).\n   *   - Note that this specific step may not succeed if gateway is old.\n   * - Stop updating schema-derived data.\n   * - Stop notifying onSchemaLoadOrUpdate() listeners.\n   */\n  public async stop(): Promise<void> {\n    this.isStopped = true;\n    if (this.modeSpecificState.mode === 'gateway') {\n      this.modeSpecificState.unsubscribeFromGateway?.();\n      await this.modeSpecificState.gateway.stop?.();\n    }\n  }\n\n  private processSchemaLoadOrUpdateEvent(\n    schemaContext: GraphQLSchemaContext,\n    schemaDerivedData?: SchemaDerivedData,\n  ): void {\n    if (!this.isStopped) {\n      this.schemaDerivedData =\n        schemaDerivedData ??\n        this.schemaDerivedDataProvider(schemaContext.apiSchema);\n      this.schemaContext = schemaContext;\n      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {\n        try {\n          listener(schemaContext);\n        } catch (e) {\n          this.logger.error(\n            \"An error was thrown from an 'onSchemaLoadOrUpdate' listener\",\n          );\n          this.logger.error(e);\n        }\n      });\n    }\n  }\n}\n\nexport class GatewayIsTooOldError extends Error {\n  public constructor(message: string) {\n    super(message);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}