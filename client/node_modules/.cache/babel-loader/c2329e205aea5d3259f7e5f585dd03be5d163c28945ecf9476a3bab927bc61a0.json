{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dispatcher = void 0;\nclass Dispatcher {\n  constructor(targets) {\n    this.targets = targets;\n  }\n  callTargets(methodName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return this.targets.map(target => {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n  hasHook(methodName) {\n    return this.targets.some(target => typeof target[methodName] === 'function');\n  }\n  async invokeHook(methodName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return Promise.all(this.callTargets(methodName, ...args));\n  }\n  async invokeHooksUntilNonNull(methodName) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method !== 'function') {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n  async invokeDidStartHook(methodName) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));\n    const didEndHooks = hookReturnValues.filter(hook => !!hook);\n    didEndHooks.reverse();\n    return async function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      await Promise.all(didEndHooks.map(hook => hook(...args)));\n    };\n  }\n  invokeSyncDidStartHook(methodName) {\n    const didEndHooks = [];\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    didEndHooks.reverse();\n    return function () {\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...arguments);\n      }\n    };\n  }\n}\nexports.Dispatcher = Dispatcher;","map":{"version":3,"mappings":";;;;;;AASA,MAAaA,UAAU;EACrBC,YAAsBC,OAAY;IAAZ,YAAO,GAAPA,OAAO;EAAQ;EAE7BC,WAAW,CACjBC,UAAuB,EACM;IAAA,kCAA1BC,IAA0B;MAA1BA,IAA0B;IAAA;IAE7B,OAAO,IAAI,CAACH,OAAO,CAACI,GAAG,CAAEC,MAAM,IAAI;MACjC,MAAMC,MAAM,GAAGD,MAAM,CAACH,UAAU,CAAC;MACjC,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;QAChC,OAAOA,MAAM,CAACC,KAAK,CAACF,MAAM,EAAEF,IAAI,CAAC;;IAErC,CAAC,CAAC;EACJ;EAEOK,OAAO,CAACN,UAAmB;IAChC,OAAO,IAAI,CAACF,OAAO,CAACS,IAAI,CACrBJ,MAAM,IAAK,OAAOA,MAAM,CAACH,UAAU,CAAC,KAAK,UAAU,CACrD;EACH;EAEO,MAAMQ,UAAU,CAIrBR,UAAuB,EACM;IAAA,mCAA1BC,IAA0B;MAA1BA,IAA0B;IAAA;IAE7B,OAAOQ,OAAO,CAACC,GAAG,CAAC,IAAI,CAACX,WAAW,CAACC,UAAU,EAAE,GAAGC,IAAI,CAAC,CAAC;EAC3D;EAEO,MAAMU,uBAAuB,CAClCX,UAAuB,EACM;IAAA,mCAA1BC,IAA0B;MAA1BA,IAA0B;IAAA;IAE7B,KAAK,MAAME,MAAM,IAAI,IAAI,CAACL,OAAO,EAAE;MACjC,MAAMM,MAAM,GAAGD,MAAM,CAACH,UAAU,CAAC;MACjC,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;QAChC;;MAEF,MAAMQ,KAAK,GAAG,MAAMR,MAAM,CAACC,KAAK,CAACF,MAAM,EAAEF,IAAI,CAAC;MAC9C,IAAIW,KAAK,KAAK,IAAI,EAAE;QAClB,OAAOA,KAAK;;;IAGhB,OAAO,IAAI;EACb;EAEO,MAAMC,kBAAkB,CAM7Bb,UAAuB,EACM;IAAA,mCAA1BC,IAA0B;MAA1BA,IAA0B;IAAA;IAE7B,MAAMa,gBAAgB,GACpB,MAAML,OAAO,CAACC,GAAG,CAAC,IAAI,CAACX,WAAW,CAACC,UAAU,EAAE,GAAGC,IAAI,CAAC,CAAC;IAE1D,MAAMc,WAAW,GAAGD,gBAAgB,CAACE,MAAM,CACxCC,IAAI,IAA4C,CAAC,CAACA,IAAI,CACxD;IACDF,WAAW,CAACG,OAAO,EAAE;IAErB,OAAO,kBAAgC;MAAA,mCAAtBjB,IAAkB;QAAlBA,IAAkB;MAAA;MACjC,MAAMQ,OAAO,CAACC,GAAG,CAACK,WAAW,CAACb,GAAG,CAAEe,IAAI,IAAKA,IAAI,CAAC,GAAGhB,IAAI,CAAC,CAAC,CAAC;IAC7D,CAAC;EACH;EAIOkB,sBAAsB,CAI3BnB,UAAuB,EACM;IAE7B,MAAMe,WAAW,GAA+B,EAAE;IAAC,mCAFhDd,IAA0B;MAA1BA,IAA0B;IAAA;IAI7B,KAAK,MAAME,MAAM,IAAI,IAAI,CAACL,OAAO,EAAE;MACjC,MAAMM,MAAM,GAAGD,MAAM,CAACH,UAAU,CAAC;MACjC,IAAI,OAAOI,MAAM,KAAK,UAAU,EAAE;QAChC,MAAMgB,UAAU,GAAGhB,MAAM,CAACC,KAAK,CAACF,MAAM,EAAEF,IAAI,CAAC;QAC7C,IAAImB,UAAU,EAAE;UACdL,WAAW,CAACM,IAAI,CAACD,UAAU,CAAC;;;;IAIlCL,WAAW,CAACG,OAAO,EAAE;IAErB,OAAO,YAA0B;MAC/B,KAAK,MAAME,UAAU,IAAIL,WAAW,EAAE;QACpCK,UAAU,CAAC,YAAO,CAAC;;IAEvB,CAAC;EACH;;AAjGFE","names":["Dispatcher","constructor","targets","callTargets","methodName","args","map","target","method","apply","hasHook","some","invokeHook","Promise","all","invokeHooksUntilNonNull","value","invokeDidStartHook","hookReturnValues","didEndHooks","filter","hook","reverse","invokeSyncDidStartHook","didEndHook","push","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\utils\\dispatcher.ts"],"sourcesContent":["import type { AnyFunction, AnyFunctionMap } from 'apollo-server-types';\n\ntype Args<F> = F extends (...args: infer A) => any ? A : never;\ntype AsFunction<F> = F extends AnyFunction ? F : never;\ntype StripPromise<T> = T extends Promise<infer U> ? U : never;\n\ntype DidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\n\nexport class Dispatcher<T extends AnyFunctionMap> {\n  constructor(protected targets: T[]) {}\n\n  private callTargets<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): ReturnType<AsFunction<T[TMethodName]>>[] {\n    return this.targets.map((target) => {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n\n  public hasHook(methodName: keyof T): boolean {\n    return this.targets.some(\n      (target) => typeof target[methodName] === 'function',\n    );\n  }\n\n  public async invokeHook<\n    TMethodName extends keyof T,\n    THookReturn extends StripPromise<ReturnType<AsFunction<T[TMethodName]>>>,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<THookReturn[]> {\n    return Promise.all(this.callTargets(methodName, ...args));\n  }\n\n  public async invokeHooksUntilNonNull<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<StripPromise<ReturnType<AsFunction<T[TMethodName]>>> | null> {\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method !== 'function') {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  public async invokeDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<\n      StripPromise<ReturnType<AsFunction<T[TMethodName]>>>\n    >,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<AsyncDidEndHook<TEndHookArgs>> {\n    const hookReturnValues: (AsyncDidEndHook<TEndHookArgs> | void)[] =\n      await Promise.all(this.callTargets(methodName, ...args));\n\n    const didEndHooks = hookReturnValues.filter(\n      (hook): hook is AsyncDidEndHook<TEndHookArgs> => !!hook,\n    );\n    didEndHooks.reverse();\n\n    return async (...args: TEndHookArgs) => {\n      await Promise.all(didEndHooks.map((hook) => hook(...args)));\n    };\n  }\n\n  // Almost all hooks are async, but as a special case, willResolveField is sync\n  // due to performance concerns.\n  public invokeSyncDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<ReturnType<AsFunction<T[TMethodName]>>>,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): DidEndHook<TEndHookArgs> {\n    const didEndHooks: DidEndHook<TEndHookArgs>[] = [];\n\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    didEndHooks.reverse();\n\n    return (...args: TEndHookArgs) => {\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...args);\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}