{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ApolloServer = void 0;\nconst express_1 = __importDefault(require(\"express\"));\nconst cors_1 = __importDefault(require(\"cors\"));\nconst body_parser_1 = require(\"body-parser\");\nconst apollo_server_core_1 = require(\"apollo-server-core\");\nconst accepts_1 = __importDefault(require(\"accepts\"));\nvar apollo_server_core_2 = require(\"apollo-server-core\");\nclass ApolloServer extends apollo_server_core_1.ApolloServerBase {\n  async createGraphQLServerOptions(req, res) {\n    const contextParams = {\n      req,\n      res\n    };\n    return super.graphQLServerOptions(contextParams);\n  }\n  applyMiddleware(_ref) {\n    let {\n      app,\n      ...rest\n    } = _ref;\n    this.assertStarted('applyMiddleware');\n    app.use(this.getMiddleware(rest));\n  }\n  getMiddleware() {\n    let {\n      path,\n      cors,\n      bodyParserConfig,\n      disableHealthCheck,\n      onHealthCheck,\n      __internal_healthCheckPath\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!path) path = '/graphql';\n    this.assertStarted('getMiddleware');\n    const router = express_1.default.Router();\n    if (!disableHealthCheck && __internal_healthCheckPath !== null) {\n      router.use(__internal_healthCheckPath !== null && __internal_healthCheckPath !== void 0 ? __internal_healthCheckPath : '/.well-known/apollo/server-health', (req, res) => {\n        res.type('application/health+json');\n        if (onHealthCheck) {\n          onHealthCheck(req).then(() => {\n            res.json({\n              status: 'pass'\n            });\n          }).catch(() => {\n            res.status(503).json({\n              status: 'fail'\n            });\n          });\n        } else {\n          res.json({\n            status: 'pass'\n          });\n        }\n      });\n    }\n    this.graphqlPath = path;\n    if (cors === true) {\n      router.use(path, (0, cors_1.default)());\n    } else if (cors !== false) {\n      router.use(path, (0, cors_1.default)(cors));\n    }\n    if (bodyParserConfig === true) {\n      router.use(path, (0, body_parser_1.json)());\n    } else if (bodyParserConfig !== false) {\n      router.use(path, (0, body_parser_1.json)(bodyParserConfig));\n    }\n    const landingPage = this.getLandingPage();\n    router.use(path, (req, res, next) => {\n      if (landingPage && prefersHtml(req)) {\n        res.setHeader('Content-Type', 'text/html');\n        res.write(landingPage.html);\n        res.end();\n        return;\n      }\n      if (!req.body) {\n        res.status(500);\n        if (bodyParserConfig === false) {\n          res.send('`res.body` is not set; you passed `bodyParserConfig: false`, ' + 'but you still need to use `body-parser` middleware yourself.');\n        } else {\n          res.send('`res.body` is not set even though Apollo Server installed ' + \"`body-parser` middleware; this shouldn't happen!\");\n        }\n        return;\n      }\n      (0, apollo_server_core_1.runHttpQuery)([], {\n        method: req.method,\n        options: () => this.createGraphQLServerOptions(req, res),\n        query: req.method === 'POST' ? req.body : req.query,\n        request: (0, apollo_server_core_1.convertNodeHttpToRequest)(req)\n      }, this.csrfPreventionRequestHeaders).then(_ref2 => {\n        let {\n          graphqlResponse,\n          responseInit\n        } = _ref2;\n        if (responseInit.headers) {\n          for (const [name, value] of Object.entries(responseInit.headers)) {\n            res.setHeader(name, value);\n          }\n        }\n        res.statusCode = responseInit.status || 200;\n        if (typeof res.send === 'function') {\n          res.send(graphqlResponse);\n        } else {\n          res.end(graphqlResponse);\n        }\n      }, error => {\n        if (!(0, apollo_server_core_1.isHttpQueryError)(error)) {\n          return next(error);\n        }\n        if (error.headers) {\n          for (const [name, value] of Object.entries(error.headers)) {\n            res.setHeader(name, value);\n          }\n        }\n        res.statusCode = error.statusCode;\n        if (typeof res.send === 'function') {\n          res.send(error.message);\n        } else {\n          res.end(error.message);\n        }\n      });\n    });\n    return router;\n  }\n}\nexports.ApolloServer = ApolloServer;\nfunction prefersHtml(req) {\n  if (req.method !== 'GET') {\n    return false;\n  }\n  const accept = (0, accepts_1.default)(req);\n  const types = accept.types();\n  return types.find(x => x === 'text/html' || x === 'application/json') === 'text/html';\n}","map":{"version":3,"mappings":"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","names":["ApolloServer","apollo_server_core_1","createGraphQLServerOptions","req","res","contextParams","graphQLServerOptions","applyMiddleware","app","rest","assertStarted","use","getMiddleware","path","cors","bodyParserConfig","disableHealthCheck","onHealthCheck","__internal_healthCheckPath","router","express_1","Router","type","then","json","status","catch","graphqlPath","landingPage","getLandingPage","next","prefersHtml","setHeader","write","html","end","body","send","method","options","query","request","csrfPreventionRequestHeaders","graphqlResponse","responseInit","headers","name","value","Object","entries","statusCode","error","message","exports","accept","types","find","x"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-express\\src\\ApolloServer.ts"],"sourcesContent":["import express from 'express';\nimport corsMiddleware from 'cors';\nimport { json, OptionsJson } from 'body-parser';\nimport {\n  GraphQLOptions,\n  ApolloServerBase,\n  Config,\n  runHttpQuery,\n  convertNodeHttpToRequest,\n  isHttpQueryError,\n} from 'apollo-server-core';\nimport accepts from 'accepts';\n\nexport { GraphQLOptions } from 'apollo-server-core';\n\nexport interface GetMiddlewareOptions {\n  path?: string;\n  cors?:\n    | corsMiddleware.CorsOptions\n    | corsMiddleware.CorsOptionsDelegate\n    | boolean;\n  bodyParserConfig?: OptionsJson | boolean;\n  onHealthCheck?: (req: express.Request) => Promise<any>;\n  disableHealthCheck?: boolean;\n  // There's no real point to allowing you to customize the health check path in\n  // an Apollo Server web framework integration package. You're already using\n  // Express --- just define a health check yourself by adding a handler that\n  // returns 200 to the URL path of your choice. This option only exists to\n  // provide a small amount of configuration for `apollo-server`, which doesn't\n  // otherwise give you direct access to the web server. (Honestly, the health\n  // check feature really should *only* exist in `apollo-server`; that it exists\n  // elsewhere (and doesn't even check to see if GraphQL operations can\n  // execute!) is a mistake we're stuck with due to backwards compatibility.)\n  // Passing `null` here implies disableHealthCheck:true.\n  __internal_healthCheckPath?: string | null;\n}\n\nexport interface ServerRegistration extends GetMiddlewareOptions {\n  // Note: You can also pass a connect.Server here. If we changed this field to\n  // `express.Application | connect.Server`, it would be very hard to get the\n  // app.use calls to typecheck even though they do work properly. Our\n  // assumption is that very few people use connect with TypeScript (and in fact\n  // we suspect the only connect users left writing GraphQL apps are Meteor\n  // users).\n  app: express.Application;\n}\n\nexport interface ExpressContext {\n  req: express.Request;\n  res: express.Response;\n}\n\nexport type ApolloServerExpressConfig = Config<ExpressContext>;\n\nexport class ApolloServer<\n  ContextFunctionParams = ExpressContext,\n> extends ApolloServerBase<ContextFunctionParams> {\n  // This translates the arguments from the middleware into graphQL options It\n  // provides typings for the integration specific behavior, ideally this would\n  // be propagated with a generic to the super class\n  async createGraphQLServerOptions(\n    req: express.Request,\n    res: express.Response,\n  ): Promise<GraphQLOptions> {\n    const contextParams: ExpressContext = { req, res };\n    return super.graphQLServerOptions(contextParams);\n  }\n\n  public applyMiddleware({ app, ...rest }: ServerRegistration) {\n    // getMiddleware calls this too, but we want the right method name in the error\n    this.assertStarted('applyMiddleware');\n\n    app.use(this.getMiddleware(rest));\n  }\n\n  // TODO: While `express` is not Promise-aware, this should become `async` in\n  // a major release in order to align the API with other integrations (e.g.\n  // Hapi) which must be `async`.\n  public getMiddleware({\n    path,\n    cors,\n    bodyParserConfig,\n    disableHealthCheck,\n    onHealthCheck,\n    __internal_healthCheckPath,\n  }: GetMiddlewareOptions = {}): express.Router {\n    if (!path) path = '/graphql';\n    this.assertStarted('getMiddleware');\n\n    // Note that even though we use Express's router here, we still manage to be\n    // Connect-compatible because express.Router just implements the same\n    // middleware interface that Connect and Express share!\n    const router = express.Router();\n\n    if (!disableHealthCheck && __internal_healthCheckPath !== null) {\n      router.use(\n        __internal_healthCheckPath ?? '/.well-known/apollo/server-health',\n        (req, res) => {\n          // Response follows https://tools.ietf.org/html/draft-inadarei-api-health-check-01\n          res.type('application/health+json');\n\n          if (onHealthCheck) {\n            onHealthCheck(req)\n              .then(() => {\n                res.json({ status: 'pass' });\n              })\n              .catch(() => {\n                res.status(503).json({ status: 'fail' });\n              });\n          } else {\n            res.json({ status: 'pass' });\n          }\n        },\n      );\n    }\n\n    // XXX multiple paths?\n    this.graphqlPath = path;\n\n    // Note that we don't just pass all of these handlers to a single app.use call\n    // for 'connect' compatibility.\n    if (cors === true) {\n      router.use(path, corsMiddleware<corsMiddleware.CorsRequest>());\n    } else if (cors !== false) {\n      router.use(path, corsMiddleware(cors));\n    }\n\n    if (bodyParserConfig === true) {\n      router.use(path, json());\n    } else if (bodyParserConfig !== false) {\n      router.use(path, json(bodyParserConfig));\n    }\n\n    const landingPage = this.getLandingPage();\n    router.use(path, (req, res, next) => {\n      if (landingPage && prefersHtml(req)) {\n        res.setHeader('Content-Type', 'text/html');\n        res.write(landingPage.html);\n        res.end();\n        return;\n      }\n\n      if (!req.body) {\n        // The json body-parser *always* sets req.body to {} if it's unset (even\n        // if the Content-Type doesn't match), so if it isn't set, you probably\n        // forgot to set up body-parser.\n        res.status(500);\n        if (bodyParserConfig === false) {\n          res.send(\n            '`res.body` is not set; you passed `bodyParserConfig: false`, ' +\n              'but you still need to use `body-parser` middleware yourself.',\n          );\n        } else {\n          res.send(\n            '`res.body` is not set even though Apollo Server installed ' +\n              \"`body-parser` middleware; this shouldn't happen!\",\n          );\n        }\n        return;\n      }\n\n      runHttpQuery(\n        [],\n        {\n          method: req.method,\n          options: () => this.createGraphQLServerOptions(req, res),\n          query: req.method === 'POST' ? req.body : req.query,\n          request: convertNodeHttpToRequest(req),\n        },\n        this.csrfPreventionRequestHeaders,\n      ).then(\n        ({ graphqlResponse, responseInit }) => {\n          if (responseInit.headers) {\n            for (const [name, value] of Object.entries(responseInit.headers)) {\n              res.setHeader(name, value);\n            }\n          }\n          res.statusCode = responseInit.status || 200;\n\n          // Using `.send` is a best practice for Express, but we also just use\n          // `.end` for compatibility with `connect`.\n          if (typeof res.send === 'function') {\n            res.send(graphqlResponse);\n          } else {\n            res.end(graphqlResponse);\n          }\n        },\n        (error: Error) => {\n          if (!isHttpQueryError(error)) {\n            return next(error);\n          }\n\n          if (error.headers) {\n            for (const [name, value] of Object.entries(error.headers)) {\n              res.setHeader(name, value);\n            }\n          }\n\n          res.statusCode = error.statusCode;\n          if (typeof res.send === 'function') {\n            // Using `.send` is a best practice for Express, but we also just use\n            // `.end` for compatibility with `connect`.\n            res.send(error.message);\n          } else {\n            res.end(error.message);\n          }\n        },\n      );\n    });\n\n    return router;\n  }\n}\n\nfunction prefersHtml(req: express.Request): boolean {\n  if (req.method !== 'GET') {\n    return false;\n  }\n  const accept = accepts(req);\n  const types = accept.types() as string[];\n  return (\n    types.find((x: string) => x === 'text/html' || x === 'application/json') ===\n    'text/html'\n  );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}