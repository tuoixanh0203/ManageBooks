{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dateToProtoTimestamp = exports.TraceTreeBuilder = void 0;\nconst graphql_1 = require(\"graphql\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nfunction internalError(message) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\nclass TraceTreeBuilder {\n  constructor(options) {\n    this.rootNode = new apollo_reporting_protobuf_1.Trace.Node();\n    this.logger = console;\n    this.trace = new apollo_reporting_protobuf_1.Trace({\n      root: this.rootNode,\n      fieldExecutionWeight: 1\n    });\n    this.stopped = false;\n    this.nodes = new Map([[responsePathAsString(), this.rootNode]]);\n    this.rewriteError = options.rewriteError;\n    if (options.logger) this.logger = options.logger;\n  }\n  startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n  stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n    this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n  willResolveField(info) {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      return () => {};\n    }\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      node.originalFieldName = info.fieldName;\n    }\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n  didEncounterErrors(errors) {\n    errors.forEach(err => {\n      var _a;\n      if ((_a = err.extensions) === null || _a === void 0 ? void 0 : _a.serviceName) {\n        return;\n      }\n      const errorForReporting = this.rewriteAndNormalizeError(err);\n      if (errorForReporting === null) {\n        return;\n      }\n      this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));\n    });\n  }\n  addProtobufError(path, error) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n    let node = this.rootNode;\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        this.logger.warn(`Could not find node with path ${path.join('.')}; defaulting to put errors on root node.`);\n      }\n    }\n    node.error.push(error);\n  }\n  newNode(path) {\n    const node = new apollo_reporting_protobuf_1.Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n  ensureParentNode(path) {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    return this.newNode(path.prev);\n  }\n  rewriteAndNormalizeError(err) {\n    if (this.rewriteError) {\n      const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);\n      const rewrittenError = this.rewriteError(clonedError);\n      if (rewrittenError === null) {\n        return null;\n      }\n      if (!(rewrittenError instanceof graphql_1.GraphQLError)) {\n        return err;\n      }\n      return new graphql_1.GraphQLError(rewrittenError.message, err.nodes, err.source, err.positions, err.path, err.originalError, rewrittenError.extensions || err.extensions);\n    }\n    return err;\n  }\n}\nexports.TraceTreeBuilder = TraceTreeBuilder;\nfunction durationHrTimeToNanos(hrtime) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\nfunction responsePathAsString(p) {\n  if (p === undefined) {\n    return '';\n  }\n  let res = String(p.key);\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n  return res;\n}\nfunction errorToProtobufError(error) {\n  return new apollo_reporting_protobuf_1.Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(_ref => {\n      let {\n        line,\n        column\n      } = _ref;\n      return new apollo_reporting_protobuf_1.Trace.Location({\n        line,\n        column\n      });\n    }),\n    json: JSON.stringify(error)\n  });\n}\nfunction dateToProtoTimestamp(date) {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new apollo_reporting_protobuf_1.google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6\n  });\n}\nexports.dateToProtoTimestamp = dateToProtoTimestamp;","map":{"version":3,"mappings":"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","names":["internalError","message","Error","TraceTreeBuilder","constructor","options","apollo_reporting_protobuf_1","Node","console","root","rootNode","fieldExecutionWeight","Map","responsePathAsString","rewriteError","logger","startTiming","startHrTime","stopped","trace","startTime","dateToProtoTimestamp","Date","process","hrtime","stopTiming","durationNs","durationHrTimeToNanos","endTime","willResolveField","info","path","node","newNode","type","returnType","toString","parentType","key","fieldName","originalFieldName","didEncounterErrors","errors","forEach","err","extensions","serviceName","errorForReporting","rewriteAndNormalizeError","addProtobufError","errorToProtobufError","error","Array","isArray","specificNode","nodes","get","join","warn","push","id","index","responseName","set","parentNode","ensureParentNode","child","parentPath","prev","clonedError","Object","assign","create","getPrototypeOf","rewrittenError","graphql_1","source","positions","originalError","exports","p","undefined","res","String","location","locations","map","line","column","Location","json","JSON","stringify","date","totalMillis","millis","protobuf","Timestamp","seconds","nanos"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\plugin\\traceTreeBuilder.ts"],"sourcesContent":["// This class is a helper for ApolloServerPluginUsageReporting and\n// ApolloServerPluginInlineTrace.\nimport { GraphQLError, GraphQLResolveInfo, ResponsePath } from 'graphql';\nimport { Trace, google } from 'apollo-reporting-protobuf';\nimport type { Logger } from '@apollo/utils.logger';\n\nfunction internalError(message: string) {\n  return new Error(`[internal apollo-server error] ${message}`);\n}\n\nexport class TraceTreeBuilder {\n  private rootNode = new Trace.Node();\n  private logger: Logger = console;\n  public trace = new Trace({\n    root: this.rootNode,\n    // By default, each trace counts as one operation for the sake of field\n    // execution counts. If we end up calling the fieldLevelInstrumentation\n    // callback (once we've successfully resolved the operation) then we\n    // may set this to a higher number; but we'll start it at 1 so that traces\n    // that don't successfully resolve the operation (eg parse failures) or\n    // where we don't call the callback because a plugin set captureTraces to\n    // true have a reasonable default.\n    fieldExecutionWeight: 1,\n  });\n  public startHrTime?: [number, number];\n  private stopped = false;\n  private nodes = new Map<string, Trace.Node>([\n    [responsePathAsString(), this.rootNode],\n  ]);\n  private readonly rewriteError?: (err: GraphQLError) => GraphQLError | null;\n\n  public constructor(options: {\n    logger?: Logger;\n    rewriteError?: (err: GraphQLError) => GraphQLError | null;\n  }) {\n    this.rewriteError = options.rewriteError;\n    if (options.logger) this.logger = options.logger;\n  }\n\n  public startTiming() {\n    if (this.startHrTime) {\n      throw internalError('startTiming called twice!');\n    }\n    if (this.stopped) {\n      throw internalError('startTiming called after stopTiming!');\n    }\n    this.trace.startTime = dateToProtoTimestamp(new Date());\n    this.startHrTime = process.hrtime();\n  }\n\n  public stopTiming() {\n    if (!this.startHrTime) {\n      throw internalError('stopTiming called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('stopTiming called twice!');\n    }\n\n    this.trace.durationNs = durationHrTimeToNanos(\n      process.hrtime(this.startHrTime),\n    );\n    this.trace.endTime = dateToProtoTimestamp(new Date());\n    this.stopped = true;\n  }\n\n  public willResolveField(info: GraphQLResolveInfo): () => void {\n    if (!this.startHrTime) {\n      throw internalError('willResolveField called before startTiming!');\n    }\n    if (this.stopped) {\n      // We've been stopped, which means execution is done... and yet we're\n      // still resolving more fields? How can that be? Shouldn't we throw an\n      // error or something?\n      //\n      // Well... we used to do exactly that. But this \"shouldn't happen\" error\n      // showed up in practice! Turns out that graphql-js can actually continue\n      // to execute more fields indefinitely long after `execute()` resolves!\n      // That's because parallelism on a selection set is implemented using\n      // `Promise.all`, and as soon as one of its arguments (ie, one field)\n      // throws an error, the combined Promise resolves, but there's no\n      // \"cancellation\" of the Promises that are the other arguments to\n      // `Promise.all`. So the code contributing to those Promises keeps on\n      // chugging away indefinitely.\n      //\n      // Concrete example: let’s say you have\n      //\n      //    { x y { ARBITRARY_SELECTION_SET } }\n      //\n      // where x has a non-null return type, and x and y both have resolvers\n      // that return Promises. And let’s say that x returns a Promise that\n      // rejects (or resolves to null). What this means is that we’re going to\n      // eventually end up with `data: null` (nothing under y will actually\n      // matter), but graphql-js execution will continue running whatever is\n      // under ARBITRARY_SELECTION_SET without any sort of short circuiting. In\n      // fact, the Promise returned from execute itself can happily resolve\n      // while execution is still chugging away on an arbitrary amount of fields\n      // under that ARBITRARY_SELECTION_SET. There’s no way to detect from the\n      // outside \"all the execution related to this operation is done\", nor to\n      // \"short-circuit\" execution so that it stops going.\n      //\n      // So, um. We will record any field whose execution we manage to observe\n      // before we \"stop\" the TraceTreeBuilder (whether it is one that actually\n      // ends up in the response or whether it gets thrown away due to null\n      // bubbling), but if we get any more fields afterwards, we just ignore\n      // them rather than throwing a confusing error.\n      //\n      // (That said, the error we used to throw here generally was hidden\n      // anyway, for the same reason: it comes from a branch of execution that\n      // ends up not being included in the response. But\n      // https://github.com/graphql/graphql-js/pull/3529 means that this\n      // sometimes crashed execution anyway. Our error never caught any actual\n      // problematic cases, so keeping it around doesn't really help.)\n      return () => {};\n    }\n\n    const path = info.path;\n    const node = this.newNode(path);\n    node.type = info.returnType.toString();\n    node.parentType = info.parentType.toString();\n    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    if (typeof path.key === 'string' && path.key !== info.fieldName) {\n      // This field was aliased; send the original field name too (for FieldStats).\n      node.originalFieldName = info.fieldName;\n    }\n\n    return () => {\n      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));\n    };\n  }\n\n  public didEncounterErrors(errors: readonly GraphQLError[]) {\n    errors.forEach((err) => {\n      // This is an error from a federated service. We will already be reporting\n      // it in the nested Trace in the query plan.\n      //\n      // XXX This probably shouldn't skip query or validation errors, which are\n      //      not in nested Traces because format() isn't called in this case! Or\n      //      maybe format() should be called in that case?\n      if (err.extensions?.serviceName) {\n        return;\n      }\n\n      // In terms of reporting, errors can be re-written by the user by\n      // utilizing the `rewriteError` parameter.  This allows changing\n      // the message or stack to remove potentially sensitive information.\n      // Returning `null` will result in the error not being reported at all.\n      const errorForReporting = this.rewriteAndNormalizeError(err);\n\n      if (errorForReporting === null) {\n        return;\n      }\n\n      this.addProtobufError(\n        errorForReporting.path,\n        errorToProtobufError(errorForReporting),\n      );\n    });\n  }\n\n  private addProtobufError(\n    path: ReadonlyArray<string | number> | undefined,\n    error: Trace.Error,\n  ) {\n    if (!this.startHrTime) {\n      throw internalError('addProtobufError called before startTiming!');\n    }\n    if (this.stopped) {\n      throw internalError('addProtobufError called after stopTiming!');\n    }\n\n    // By default, put errors on the root node.\n    let node = this.rootNode;\n    // If a non-GraphQLError Error sneaks in here somehow with a non-array\n    // path, don't crash.\n    if (Array.isArray(path)) {\n      const specificNode = this.nodes.get(path.join('.'));\n      if (specificNode) {\n        node = specificNode;\n      } else {\n        this.logger.warn(\n          `Could not find node with path ${path.join(\n            '.',\n          )}; defaulting to put errors on root node.`,\n        );\n      }\n    }\n\n    node.error.push(error);\n  }\n\n  private newNode(path: ResponsePath): Trace.Node {\n    const node = new Trace.Node();\n    const id = path.key;\n    if (typeof id === 'number') {\n      node.index = id;\n    } else {\n      node.responseName = id;\n    }\n    this.nodes.set(responsePathAsString(path), node);\n    const parentNode = this.ensureParentNode(path);\n    parentNode.child.push(node);\n    return node;\n  }\n\n  private ensureParentNode(path: ResponsePath): Trace.Node {\n    const parentPath = responsePathAsString(path.prev);\n    const parentNode = this.nodes.get(parentPath);\n    if (parentNode) {\n      return parentNode;\n    }\n    // Because we set up the root path when creating this.nodes, we now know\n    // that path.prev isn't undefined.\n    return this.newNode(path.prev!);\n  }\n\n  private rewriteAndNormalizeError(err: GraphQLError): GraphQLError | null {\n    if (this.rewriteError) {\n      // Before passing the error to the user-provided `rewriteError` function,\n      // we'll make a shadow copy of the error so the user is free to change\n      // the object as they see fit.\n\n      // At this stage, this error is only for the purposes of reporting, but\n      // this is even more important since this is still a reference to the\n      // original error object and changing it would also change the error which\n      // is returned in the response to the client.\n\n      // For the clone, we'll create a new object which utilizes the exact same\n      // prototype of the error being reported.\n      const clonedError = Object.assign(\n        Object.create(Object.getPrototypeOf(err)),\n        err,\n      );\n\n      const rewrittenError = this.rewriteError(clonedError);\n\n      // Returning an explicit `null` means the user is requesting that the error\n      // not be reported to Apollo.\n      if (rewrittenError === null) {\n        return null;\n      }\n\n      // We don't want users to be inadvertently not reporting errors, so if\n      // they haven't returned an explicit `GraphQLError` (or `null`, handled\n      // above), then we'll report the error as usual.\n      if (!(rewrittenError instanceof GraphQLError)) {\n        return err;\n      }\n\n      // We only allow rewriteError to change the message and extensions of the\n      // error; we keep everything else the same. That way people don't have to\n      // do extra work to keep the error on the same trace node. We also keep\n      // extensions the same if it isn't explicitly changed (to, eg, {}). (Note\n      // that many of the fields of GraphQLError are not enumerable and won't\n      // show up in the trace (even in the json field) anyway.)\n      return new GraphQLError(\n        rewrittenError.message,\n        err.nodes,\n        err.source,\n        err.positions,\n        err.path,\n        err.originalError,\n        rewrittenError.extensions || err.extensions,\n      );\n    }\n    return err;\n  }\n}\n\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\n//\n// XXX We should probably use google.protobuf.Duration on the wire instead of\n// ever trying to store durations in a single number.\nfunction durationHrTimeToNanos(hrtime: [number, number]) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}\n\n// Convert from the linked-list ResponsePath format to a dot-joined\n// string. Includes the full path (field names and array indices).\nfunction responsePathAsString(p?: ResponsePath): string {\n  if (p === undefined) {\n    return '';\n  }\n\n  // A previous implementation used `responsePathAsArray` from `graphql-js/execution`,\n  // however, that employed an approach that created new arrays unnecessarily.\n  let res = String(p.key);\n\n  while ((p = p.prev) !== undefined) {\n    res = `${p.key}.${res}`;\n  }\n\n  return res;\n}\n\nfunction errorToProtobufError(error: GraphQLError): Trace.Error {\n  return new Trace.Error({\n    message: error.message,\n    location: (error.locations || []).map(\n      ({ line, column }) => new Trace.Location({ line, column }),\n    ),\n    json: JSON.stringify(error),\n  });\n}\n\n// Converts a JS Date into a Timestamp.\nexport function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp {\n  const totalMillis = +date;\n  const millis = totalMillis % 1000;\n  return new google.protobuf.Timestamp({\n    seconds: (totalMillis - millis) / 1000,\n    nanos: millis * 1e6,\n  });\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}