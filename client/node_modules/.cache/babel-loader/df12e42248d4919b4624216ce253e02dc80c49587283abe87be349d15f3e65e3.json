{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectSubFields = exports.getDeferValues = exports.getFieldEntryKey = exports.doesFragmentConditionMatch = exports.shouldIncludeNode = exports.collectFields = void 0;\nconst memoize_js_1 = require(\"./memoize.js\");\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst AccumulatorMap_js_1 = require(\"./AccumulatorMap.js\");\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case graphql_1.Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          fields.add(getFieldEntryKey(selection), selection);\n          break;\n        }\n      case graphql_1.Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n          const defer = getDeferValues(variableValues, selection);\n          if (defer) {\n            const patchFields = new AccumulatorMap_js_1.AccumulatorMap();\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);\n            patches.push({\n              label: defer.label,\n              fields: patchFields\n            });\n          } else {\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);\n          }\n          break;\n        }\n      case graphql_1.Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          const defer = getDeferValues(variableValues, selection);\n          if (visitedFragmentNames.has(fragName) && !defer) {\n            continue;\n          }\n          const fragment = fragments[fragName];\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n          if (!defer) {\n            visitedFragmentNames.add(fragName);\n          }\n          if (defer) {\n            const patchFields = new AccumulatorMap_js_1.AccumulatorMap();\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);\n            patches.push({\n              label: defer.label,\n              fields: patchFields\n            });\n          } else {\n            collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);\n          }\n          break;\n        }\n    }\n  }\n}\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n */\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n  const fields = new AccumulatorMap_js_1.AccumulatorMap();\n  const patches = [];\n  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set());\n  return {\n    fields,\n    patches\n  };\n}\nexports.collectFields = collectFields;\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);\n  if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n    return false;\n  }\n  const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);\n  if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n    return false;\n  }\n  return true;\n}\nexports.shouldIncludeNode = shouldIncludeNode;\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if ((0, graphql_1.isAbstractType)(conditionalType)) {\n    const possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type);\n  }\n  return false;\n}\nexports.doesFragmentConditionMatch = doesFragmentConditionMatch;\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\nexports.getFieldEntryKey = getFieldEntryKey;\n/**\n * Returns an object containing the `@defer` arguments if a field should be\n * deferred based on the experimental flag, defer directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getDeferValues(variableValues, node) {\n  const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);\n  if (!defer) {\n    return;\n  }\n  if (defer['if'] === false) {\n    return;\n  }\n  return {\n    label: typeof defer['label'] === 'string' ? defer['label'] : undefined\n  };\n}\nexports.getDeferValues = getDeferValues;\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n */\nexports.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n  const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();\n  const visitedFragmentNames = new Set();\n  const subPatches = [];\n  const subFieldsAndPatches = {\n    fields: subFieldNodes,\n    patches: subPatches\n  };\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);\n    }\n  }\n  return subFieldsAndPatches;\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","collectSubFields","getDeferValues","getFieldEntryKey","doesFragmentConditionMatch","shouldIncludeNode","collectFields","memoize_js_1","require","graphql_1","directives_js_1","AccumulatorMap_js_1","collectFieldsImpl","schema","fragments","variableValues","runtimeType","selectionSet","fields","patches","visitedFragmentNames","selection","selections","kind","Kind","FIELD","add","INLINE_FRAGMENT","defer","patchFields","AccumulatorMap","push","label","FRAGMENT_SPREAD","fragName","name","has","fragment","Set","node","skip","getDirectiveValues","GraphQLSkipDirective","include","GraphQLIncludeDirective","type","typeConditionNode","typeCondition","conditionalType","typeFromAST","isAbstractType","possibleTypes","getPossibleTypes","includes","alias","GraphQLDeferDirective","undefined","memoize5","collectSubfields","returnType","fieldNodes","subFieldNodes","subPatches","subFieldsAndPatches"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/utils/cjs/collectFields.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectSubFields = exports.getDeferValues = exports.getFieldEntryKey = exports.doesFragmentConditionMatch = exports.shouldIncludeNode = exports.collectFields = void 0;\nconst memoize_js_1 = require(\"./memoize.js\");\nconst graphql_1 = require(\"graphql\");\nconst directives_js_1 = require(\"./directives.js\");\nconst AccumulatorMap_js_1 = require(\"./AccumulatorMap.js\");\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case graphql_1.Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                fields.add(getFieldEntryKey(selection), selection);\n                break;\n            }\n            case graphql_1.Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                const defer = getDeferValues(variableValues, selection);\n                if (defer) {\n                    const patchFields = new AccumulatorMap_js_1.AccumulatorMap();\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);\n                    patches.push({\n                        label: defer.label,\n                        fields: patchFields,\n                    });\n                }\n                else {\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);\n                }\n                break;\n            }\n            case graphql_1.Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const defer = getDeferValues(variableValues, selection);\n                if (visitedFragmentNames.has(fragName) && !defer) {\n                    continue;\n                }\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                if (!defer) {\n                    visitedFragmentNames.add(fragName);\n                }\n                if (defer) {\n                    const patchFields = new AccumulatorMap_js_1.AccumulatorMap();\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);\n                    patches.push({\n                        label: defer.label,\n                        fields: patchFields,\n                    });\n                }\n                else {\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);\n                }\n                break;\n            }\n        }\n    }\n}\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n */\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n    const fields = new AccumulatorMap_js_1.AccumulatorMap();\n    const patches = [];\n    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set());\n    return { fields, patches };\n}\nexports.collectFields = collectFields;\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n    const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);\n    if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n        return false;\n    }\n    const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);\n    if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n        return false;\n    }\n    return true;\n}\nexports.shouldIncludeNode = shouldIncludeNode;\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if ((0, graphql_1.isAbstractType)(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\nexports.doesFragmentConditionMatch = doesFragmentConditionMatch;\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\nexports.getFieldEntryKey = getFieldEntryKey;\n/**\n * Returns an object containing the `@defer` arguments if a field should be\n * deferred based on the experimental flag, defer directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getDeferValues(variableValues, node) {\n    const defer = (0, graphql_1.getDirectiveValues)(directives_js_1.GraphQLDeferDirective, node, variableValues);\n    if (!defer) {\n        return;\n    }\n    if (defer['if'] === false) {\n        return;\n    }\n    return {\n        label: typeof defer['label'] === 'string' ? defer['label'] : undefined,\n    };\n}\nexports.getDeferValues = getDeferValues;\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n */\nexports.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n    const subFieldNodes = new AccumulatorMap_js_1.AccumulatorMap();\n    const visitedFragmentNames = new Set();\n    const subPatches = [];\n    const subFieldsAndPatches = {\n        fields: subFieldNodes,\n        patches: subPatches,\n    };\n    for (const node of fieldNodes) {\n        if (node.selectionSet) {\n            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);\n        }\n    }\n    return subFieldsAndPatches;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}