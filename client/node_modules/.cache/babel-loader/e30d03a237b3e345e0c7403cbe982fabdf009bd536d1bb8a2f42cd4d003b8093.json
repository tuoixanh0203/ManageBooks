{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.correctASTNodes = exports.mapSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst getObjectTypeFromTypeMap_js_1 = require(\"./getObjectTypeFromTypeMap.js\");\nconst Interfaces_js_1 = require(\"./Interfaces.js\");\nconst rewire_js_1 = require(\"./rewire.js\");\nconst transformInputValue_js_1 = require(\"./transformInputValue.js\");\nfunction mapSchema(schema) {\n  let schemaMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, type => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, type => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const {\n    typeMap,\n    directives\n  } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);\n  return new graphql_1.GraphQLSchema({\n    ...schema.toConfig(),\n    query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),\n    mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),\n    subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives\n  });\n}\nexports.mapSchema = mapSchema;\nfunction mapTypes(originalTypeMap, schema, schemaMapper) {\n  let testFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const maybeNewType = typeMapper(originalType, schema);\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n  return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n  return mapTypes(originalTypeMap, schema, {\n    [Interfaces_js_1.MapperKind.ENUM_TYPE]: type => {\n      const config = type.toConfig();\n      const originalEnumValueConfigMap = config.values;\n      const newEnumValueConfigMap = {};\n      for (const externalValue in originalEnumValueConfigMap) {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n        if (mappedEnumValue === undefined) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      }\n      return correctASTNodes(new graphql_1.GraphQLEnumType({\n        ...config,\n        values: newEnumValueConfigMap\n      }));\n    }\n  }, type => (0, graphql_1.isEnumType)(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [Interfaces_js_1.MapperKind.ARGUMENT]: argumentConfig => {\n      if (argumentConfig.defaultValue === undefined) {\n        return argumentConfig;\n      }\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n      if (maybeNewType != null) {\n        return {\n          ...argumentConfig,\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        };\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n      if (inputFieldConfig.defaultValue === undefined) {\n        return inputFieldConfig;\n      }\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n      if (maybeNewType != null) {\n        return {\n          ...inputFieldConfig,\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        };\n      }\n    }\n  });\n}\nfunction getNewType(newTypeMap, type) {\n  if ((0, graphql_1.isListType)(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql_1.GraphQLList(newType) : null;\n  } else if ((0, graphql_1.isNonNullType)(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;\n  } else if ((0, graphql_1.isNamedType)(type)) {\n    const newType = newTypeMap[type.name];\n    return newType != null ? newType : null;\n  }\n  return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n      if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = {\n              ...newFieldConfig.astNode,\n              name: {\n                ...newFieldConfig.astNode.name,\n                value: newFieldName\n              }\n            };\n          }\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n      if ((0, graphql_1.isObjectType)(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        }));\n      } else if ((0, graphql_1.isInterfaceType)(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({\n          ...config,\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n  return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n      if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const argumentMapper = getArgumentMapper(schemaMapper);\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n        const newArgumentConfigMap = {};\n        for (const argumentName of argumentNames) {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n        newFieldConfigMap[fieldName] = {\n          ...originalFieldConfig,\n          args: newArgumentConfigMap\n        };\n      }\n      if ((0, graphql_1.isObjectType)(originalType)) {\n        newTypeMap[typeName] = new graphql_1.GraphQLObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        });\n      } else if ((0, graphql_1.isInterfaceType)(originalType)) {\n        newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({\n          ...config,\n          fields: newFieldConfigMap\n        });\n      } else {\n        newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        });\n      }\n    }\n  }\n  return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n  const newDirectives = [];\n  for (const directive of originalDirectives) {\n    const mappedDirective = directiveMapper(directive, schema);\n    if (mappedDirective === undefined) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  }\n  return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n  const type = schema.getType(typeName);\n  const specifiers = [Interfaces_js_1.MapperKind.TYPE];\n  if ((0, graphql_1.isObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);\n    }\n  } else if ((0, graphql_1.isInputObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);\n  } else if ((0, graphql_1.isInterfaceType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);\n  } else if ((0, graphql_1.isUnionType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);\n  } else if ((0, graphql_1.isEnumType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);\n  } else if ((0, graphql_1.isScalarType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);\n  }\n  return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n  while (!typeMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n  return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n  const type = schema.getType(typeName);\n  const specifiers = [Interfaces_js_1.MapperKind.FIELD];\n  if ((0, graphql_1.isObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if ((0, graphql_1.isInterfaceType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);\n  } else if ((0, graphql_1.isInputObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);\n  }\n  return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n  while (!fieldMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    // TODO: fix this as unknown cast\n    fieldMapper = schemaMapper[next];\n  }\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n  if ((0, graphql_1.isObjectType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const fields = [];\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n    return new graphql_1.GraphQLObjectType(config);\n  } else if ((0, graphql_1.isInterfaceType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const fields = [];\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n    return new graphql_1.GraphQLInterfaceType(config);\n  } else if ((0, graphql_1.isInputObjectType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const fields = [];\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n    return new graphql_1.GraphQLInputObjectType(config);\n  } else if ((0, graphql_1.isEnumType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const values = [];\n      for (const enumKey in config.values) {\n        const enumValueConfig = config.values[enumKey];\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        values\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        values: undefined\n      }));\n    }\n    return new graphql_1.GraphQLEnumType(config);\n  } else {\n    return type;\n  }\n}\nexports.correctASTNodes = correctASTNodes;","map":{"version":3,"names":["Object","defineProperty","exports","value","correctASTNodes","mapSchema","graphql_1","require","getObjectTypeFromTypeMap_js_1","Interfaces_js_1","rewire_js_1","transformInputValue_js_1","schema","schemaMapper","newTypeMap","mapArguments","mapFields","mapTypes","mapDefaultValues","mapEnumValues","getTypeMap","serializeInputValue","type","isLeafType","parseInputValue","originalDirectives","getDirectives","newDirectives","mapDirectives","typeMap","directives","rewireTypes","GraphQLSchema","toConfig","query","getObjectTypeFromTypeMap","getQueryType","mutation","getMutationType","subscription","getSubscriptionType","types","values","originalTypeMap","testFn","typeName","startsWith","originalType","typeMapper","getTypeMapper","maybeNewType","undefined","enumValueMapper","getEnumValueMapper","MapperKind","ENUM_TYPE","config","originalEnumValueConfigMap","newEnumValueConfigMap","externalValue","originalEnumValueConfig","mappedEnumValue","name","Array","isArray","newExternalValue","newEnumValueConfig","GraphQLEnumType","isEnumType","fn","ARGUMENT","argumentConfig","defaultValue","getNewType","INPUT_OBJECT_FIELD","inputFieldConfig","isListType","newType","ofType","GraphQLList","isNonNullType","GraphQLNonNull","isNamedType","isObjectType","isInterfaceType","isInputObjectType","fieldMapper","getFieldMapper","originalFieldConfigMap","fields","newFieldConfigMap","fieldName","originalFieldConfig","mappedField","newFieldName","newFieldConfig","astNode","GraphQLObjectType","GraphQLInterfaceType","GraphQLInputObjectType","argumentMapper","getArgumentMapper","originalArgumentConfigMap","args","argumentNames","keys","length","newArgumentConfigMap","argumentName","originalArgumentConfig","mappedArgument","newArgumentName","newArgumentConfig","directiveMapper","getDirectiveMapper","slice","directive","mappedDirective","push","getTypeSpecifiers","_a","_b","_c","getType","specifiers","TYPE","COMPOSITE_TYPE","OBJECT_TYPE","ROOT_OBJECT","QUERY","MUTATION","SUBSCRIPTION","INPUT_OBJECT_TYPE","ABSTRACT_TYPE","INTERFACE_TYPE","isUnionType","UNION_TYPE","isScalarType","SCALAR_TYPE","stack","next","pop","getFieldSpecifiers","FIELD","COMPOSITE_FIELD","OBJECT_FIELD","ROOT_FIELD","QUERY_ROOT_FIELD","MUTATION_ROOT_FIELD","SUBSCRIPTION_ROOT_FIELD","INTERFACE_FIELD","DIRECTIVE","ENUM_VALUE","fieldConfig","kind","Kind","OBJECT_TYPE_DEFINITION","extensionASTNodes","map","node","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","enumKey","enumValueConfig"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/mapSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.correctASTNodes = exports.mapSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst getObjectTypeFromTypeMap_js_1 = require(\"./getObjectTypeFromTypeMap.js\");\nconst Interfaces_js_1 = require(\"./Interfaces.js\");\nconst rewire_js_1 = require(\"./rewire.js\");\nconst transformInputValue_js_1 = require(\"./transformInputValue.js\");\nfunction mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, type => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, type => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);\n    return new graphql_1.GraphQLSchema({\n        ...schema.toConfig(),\n        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),\n        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),\n        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nexports.mapSchema = mapSchema;\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [Interfaces_js_1.MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new graphql_1.GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => (0, graphql_1.isEnumType)(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [Interfaces_js_1.MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if ((0, graphql_1.isListType)(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql_1.GraphQLList(newType) : null;\n    }\n    else if ((0, graphql_1.isNonNullType)(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;\n    }\n    else if ((0, graphql_1.isNamedType)(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if ((0, graphql_1.isObjectType)(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if ((0, graphql_1.isInterfaceType)(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if ((0, graphql_1.isObjectType)(originalType)) {\n                newTypeMap[typeName] = new graphql_1.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if ((0, graphql_1.isInterfaceType)(originalType)) {\n                newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [Interfaces_js_1.MapperKind.TYPE];\n    if ((0, graphql_1.isObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if ((0, graphql_1.isInputObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if ((0, graphql_1.isInterfaceType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);\n    }\n    else if ((0, graphql_1.isUnionType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);\n    }\n    else if ((0, graphql_1.isEnumType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);\n    }\n    else if ((0, graphql_1.isScalarType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [Interfaces_js_1.MapperKind.FIELD];\n    if ((0, graphql_1.isObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if ((0, graphql_1.isInterfaceType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);\n    }\n    else if ((0, graphql_1.isInputObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n    if ((0, graphql_1.isObjectType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLObjectType(config);\n    }\n    else if ((0, graphql_1.isInterfaceType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLInterfaceType(config);\n    }\n    else if ((0, graphql_1.isInputObjectType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLInputObjectType(config);\n    }\n    else if ((0, graphql_1.isEnumType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\nexports.correctASTNodes = correctASTNodes;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,eAAe,GAAGF,OAAO,CAACG,SAAS,GAAG,KAAK,CAAC;AACpD,MAAMC,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,6BAA6B,GAAGD,OAAO,CAAC,+BAA+B,CAAC;AAC9E,MAAME,eAAe,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMG,WAAW,GAAGH,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMI,wBAAwB,GAAGJ,OAAO,CAAC,0BAA0B,CAAC;AACpE,SAASF,SAAS,CAACO,MAAM,EAAqB;EAAA,IAAnBC,YAAY,uEAAG,CAAC,CAAC;EACxC,MAAMC,UAAU,GAAGC,YAAY,CAACC,SAAS,CAACC,QAAQ,CAACC,gBAAgB,CAACC,aAAa,CAACF,QAAQ,CAACC,gBAAgB,CAACN,MAAM,CAACQ,UAAU,EAAE,EAAER,MAAM,EAAED,wBAAwB,CAACU,mBAAmB,CAAC,EAAET,MAAM,EAAEC,YAAY,EAAES,IAAI,IAAI,CAAC,CAAC,EAAEhB,SAAS,CAACiB,UAAU,EAAED,IAAI,CAAC,CAAC,EAAEV,MAAM,EAAEC,YAAY,CAAC,EAAED,MAAM,EAAED,wBAAwB,CAACa,eAAe,CAAC,EAAEZ,MAAM,EAAEC,YAAY,EAAES,IAAI,IAAI,CAAC,CAAC,CAAC,EAAEhB,SAAS,CAACiB,UAAU,EAAED,IAAI,CAAC,CAAC,EAAEV,MAAM,EAAEC,YAAY,CAAC,EAAED,MAAM,EAAEC,YAAY,CAAC;EAC/a,MAAMY,kBAAkB,GAAGb,MAAM,CAACc,aAAa,EAAE;EACjD,MAAMC,aAAa,GAAGC,aAAa,CAACH,kBAAkB,EAAEb,MAAM,EAAEC,YAAY,CAAC;EAC7E,MAAM;IAAEgB,OAAO;IAAEC;EAAW,CAAC,GAAG,CAAC,CAAC,EAAEpB,WAAW,CAACqB,WAAW,EAAEjB,UAAU,EAAEa,aAAa,CAAC;EACvF,OAAO,IAAIrB,SAAS,CAAC0B,aAAa,CAAC;IAC/B,GAAGpB,MAAM,CAACqB,QAAQ,EAAE;IACpBC,KAAK,EAAE,CAAC,CAAC,EAAE1B,6BAA6B,CAAC2B,wBAAwB,EAAEN,OAAO,EAAE,CAAC,CAAC,EAAErB,6BAA6B,CAAC2B,wBAAwB,EAAErB,UAAU,EAAEF,MAAM,CAACwB,YAAY,EAAE,CAAC,CAAC;IAC3KC,QAAQ,EAAE,CAAC,CAAC,EAAE7B,6BAA6B,CAAC2B,wBAAwB,EAAEN,OAAO,EAAE,CAAC,CAAC,EAAErB,6BAA6B,CAAC2B,wBAAwB,EAAErB,UAAU,EAAEF,MAAM,CAAC0B,eAAe,EAAE,CAAC,CAAC;IACjLC,YAAY,EAAE,CAAC,CAAC,EAAE/B,6BAA6B,CAAC2B,wBAAwB,EAAEN,OAAO,EAAE,CAAC,CAAC,EAAErB,6BAA6B,CAAC2B,wBAAwB,EAAErB,UAAU,EAAEF,MAAM,CAAC4B,mBAAmB,EAAE,CAAC,CAAC;IACzLC,KAAK,EAAEzC,MAAM,CAAC0C,MAAM,CAACb,OAAO,CAAC;IAC7BC;EACJ,CAAC,CAAC;AACN;AACA5B,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B,SAASY,QAAQ,CAAC0B,eAAe,EAAE/B,MAAM,EAAEC,YAAY,EAAuB;EAAA,IAArB+B,MAAM,uEAAG,MAAM,IAAI;EACxE,MAAM9B,UAAU,GAAG,CAAC,CAAC;EACrB,KAAK,MAAM+B,QAAQ,IAAIF,eAAe,EAAE;IACpC,IAAI,CAACE,QAAQ,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MAC5B,MAAMC,YAAY,GAAGJ,eAAe,CAACE,QAAQ,CAAC;MAC9C,IAAIE,YAAY,IAAI,IAAI,IAAI,CAACH,MAAM,CAACG,YAAY,CAAC,EAAE;QAC/CjC,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACA,MAAMC,UAAU,GAAGC,aAAa,CAACrC,MAAM,EAAEC,YAAY,EAAEgC,QAAQ,CAAC;MAChE,IAAIG,UAAU,IAAI,IAAI,EAAE;QACpBlC,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACA,MAAMG,YAAY,GAAGF,UAAU,CAACD,YAAY,EAAEnC,MAAM,CAAC;MACrD,IAAIsC,YAAY,KAAKC,SAAS,EAAE;QAC5BrC,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACAjC,UAAU,CAAC+B,QAAQ,CAAC,GAAGK,YAAY;IACvC;EACJ;EACA,OAAOpC,UAAU;AACrB;AACA,SAASK,aAAa,CAACwB,eAAe,EAAE/B,MAAM,EAAEC,YAAY,EAAE;EAC1D,MAAMuC,eAAe,GAAGC,kBAAkB,CAACxC,YAAY,CAAC;EACxD,IAAI,CAACuC,eAAe,EAAE;IAClB,OAAOT,eAAe;EAC1B;EACA,OAAO1B,QAAQ,CAAC0B,eAAe,EAAE/B,MAAM,EAAE;IACrC,CAACH,eAAe,CAAC6C,UAAU,CAACC,SAAS,GAAGjC,IAAI,IAAI;MAC5C,MAAMkC,MAAM,GAAGlC,IAAI,CAACW,QAAQ,EAAE;MAC9B,MAAMwB,0BAA0B,GAAGD,MAAM,CAACd,MAAM;MAChD,MAAMgB,qBAAqB,GAAG,CAAC,CAAC;MAChC,KAAK,MAAMC,aAAa,IAAIF,0BAA0B,EAAE;QACpD,MAAMG,uBAAuB,GAAGH,0BAA0B,CAACE,aAAa,CAAC;QACzE,MAAME,eAAe,GAAGT,eAAe,CAACQ,uBAAuB,EAAEtC,IAAI,CAACwC,IAAI,EAAElD,MAAM,EAAE+C,aAAa,CAAC;QAClG,IAAIE,eAAe,KAAKV,SAAS,EAAE;UAC/BO,qBAAqB,CAACC,aAAa,CAAC,GAAGC,uBAAuB;QAClE,CAAC,MACI,IAAIG,KAAK,CAACC,OAAO,CAACH,eAAe,CAAC,EAAE;UACrC,MAAM,CAACI,gBAAgB,EAAEC,kBAAkB,CAAC,GAAGL,eAAe;UAC9DH,qBAAqB,CAACO,gBAAgB,CAAC,GACnCC,kBAAkB,KAAKf,SAAS,GAAGS,uBAAuB,GAAGM,kBAAkB;QACvF,CAAC,MACI,IAAIL,eAAe,KAAK,IAAI,EAAE;UAC/BH,qBAAqB,CAACC,aAAa,CAAC,GAAGE,eAAe;QAC1D;MACJ;MACA,OAAOzD,eAAe,CAAC,IAAIE,SAAS,CAAC6D,eAAe,CAAC;QACjD,GAAGX,MAAM;QACTd,MAAM,EAAEgB;MACZ,CAAC,CAAC,CAAC;IACP;EACJ,CAAC,EAAEpC,IAAI,IAAI,CAAC,CAAC,EAAEhB,SAAS,CAAC8D,UAAU,EAAE9C,IAAI,CAAC,CAAC;AAC/C;AACA,SAASJ,gBAAgB,CAACyB,eAAe,EAAE/B,MAAM,EAAEyD,EAAE,EAAE;EACnD,MAAMvD,UAAU,GAAGC,YAAY,CAAC4B,eAAe,EAAE/B,MAAM,EAAE;IACrD,CAACH,eAAe,CAAC6C,UAAU,CAACgB,QAAQ,GAAGC,cAAc,IAAI;MACrD,IAAIA,cAAc,CAACC,YAAY,KAAKrB,SAAS,EAAE;QAC3C,OAAOoB,cAAc;MACzB;MACA,MAAMrB,YAAY,GAAGuB,UAAU,CAAC9B,eAAe,EAAE4B,cAAc,CAACjD,IAAI,CAAC;MACrE,IAAI4B,YAAY,IAAI,IAAI,EAAE;QACtB,OAAO;UACH,GAAGqB,cAAc;UACjBC,YAAY,EAAEH,EAAE,CAACnB,YAAY,EAAEqB,cAAc,CAACC,YAAY;QAC9D,CAAC;MACL;IACJ;EACJ,CAAC,CAAC;EACF,OAAOxD,SAAS,CAACF,UAAU,EAAEF,MAAM,EAAE;IACjC,CAACH,eAAe,CAAC6C,UAAU,CAACoB,kBAAkB,GAAGC,gBAAgB,IAAI;MACjE,IAAIA,gBAAgB,CAACH,YAAY,KAAKrB,SAAS,EAAE;QAC7C,OAAOwB,gBAAgB;MAC3B;MACA,MAAMzB,YAAY,GAAGuB,UAAU,CAAC3D,UAAU,EAAE6D,gBAAgB,CAACrD,IAAI,CAAC;MAClE,IAAI4B,YAAY,IAAI,IAAI,EAAE;QACtB,OAAO;UACH,GAAGyB,gBAAgB;UACnBH,YAAY,EAAEH,EAAE,CAACnB,YAAY,EAAEyB,gBAAgB,CAACH,YAAY;QAChE,CAAC;MACL;IACJ;EACJ,CAAC,CAAC;AACN;AACA,SAASC,UAAU,CAAC3D,UAAU,EAAEQ,IAAI,EAAE;EAClC,IAAI,CAAC,CAAC,EAAEhB,SAAS,CAACsE,UAAU,EAAEtD,IAAI,CAAC,EAAE;IACjC,MAAMuD,OAAO,GAAGJ,UAAU,CAAC3D,UAAU,EAAEQ,IAAI,CAACwD,MAAM,CAAC;IACnD,OAAOD,OAAO,IAAI,IAAI,GAAG,IAAIvE,SAAS,CAACyE,WAAW,CAACF,OAAO,CAAC,GAAG,IAAI;EACtE,CAAC,MACI,IAAI,CAAC,CAAC,EAAEvE,SAAS,CAAC0E,aAAa,EAAE1D,IAAI,CAAC,EAAE;IACzC,MAAMuD,OAAO,GAAGJ,UAAU,CAAC3D,UAAU,EAAEQ,IAAI,CAACwD,MAAM,CAAC;IACnD,OAAOD,OAAO,IAAI,IAAI,GAAG,IAAIvE,SAAS,CAAC2E,cAAc,CAACJ,OAAO,CAAC,GAAG,IAAI;EACzE,CAAC,MACI,IAAI,CAAC,CAAC,EAAEvE,SAAS,CAAC4E,WAAW,EAAE5D,IAAI,CAAC,EAAE;IACvC,MAAMuD,OAAO,GAAG/D,UAAU,CAACQ,IAAI,CAACwC,IAAI,CAAC;IACrC,OAAOe,OAAO,IAAI,IAAI,GAAGA,OAAO,GAAG,IAAI;EAC3C;EACA,OAAO,IAAI;AACf;AACA,SAAS7D,SAAS,CAAC2B,eAAe,EAAE/B,MAAM,EAAEC,YAAY,EAAE;EACtD,MAAMC,UAAU,GAAG,CAAC,CAAC;EACrB,KAAK,MAAM+B,QAAQ,IAAIF,eAAe,EAAE;IACpC,IAAI,CAACE,QAAQ,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MAC5B,MAAMC,YAAY,GAAGJ,eAAe,CAACE,QAAQ,CAAC;MAC9C,IAAI,CAAC,CAAC,CAAC,EAAEvC,SAAS,CAAC6E,YAAY,EAAEpC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAEzC,SAAS,CAAC8E,eAAe,EAAErC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAEzC,SAAS,CAAC+E,iBAAiB,EAAEtC,YAAY,CAAC,EAAE;QAChJjC,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACA,MAAMuC,WAAW,GAAGC,cAAc,CAAC3E,MAAM,EAAEC,YAAY,EAAEgC,QAAQ,CAAC;MAClE,IAAIyC,WAAW,IAAI,IAAI,EAAE;QACrBxE,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACA,MAAMS,MAAM,GAAGT,YAAY,CAACd,QAAQ,EAAE;MACtC,MAAMuD,sBAAsB,GAAGhC,MAAM,CAACiC,MAAM;MAC5C,MAAMC,iBAAiB,GAAG,CAAC,CAAC;MAC5B,KAAK,MAAMC,SAAS,IAAIH,sBAAsB,EAAE;QAC5C,MAAMI,mBAAmB,GAAGJ,sBAAsB,CAACG,SAAS,CAAC;QAC7D,MAAME,WAAW,GAAGP,WAAW,CAACM,mBAAmB,EAAED,SAAS,EAAE9C,QAAQ,EAAEjC,MAAM,CAAC;QACjF,IAAIiF,WAAW,KAAK1C,SAAS,EAAE;UAC3BuC,iBAAiB,CAACC,SAAS,CAAC,GAAGC,mBAAmB;QACtD,CAAC,MACI,IAAI7B,KAAK,CAACC,OAAO,CAAC6B,WAAW,CAAC,EAAE;UACjC,MAAM,CAACC,YAAY,EAAEC,cAAc,CAAC,GAAGF,WAAW;UAClD,IAAIE,cAAc,CAACC,OAAO,IAAI,IAAI,EAAE;YAChCD,cAAc,CAACC,OAAO,GAAG;cACrB,GAAGD,cAAc,CAACC,OAAO;cACzBlC,IAAI,EAAE;gBACF,GAAGiC,cAAc,CAACC,OAAO,CAAClC,IAAI;gBAC9B3D,KAAK,EAAE2F;cACX;YACJ,CAAC;UACL;UACAJ,iBAAiB,CAACI,YAAY,CAAC,GAAGC,cAAc,KAAK5C,SAAS,GAAGyC,mBAAmB,GAAGG,cAAc;QACzG,CAAC,MACI,IAAIF,WAAW,KAAK,IAAI,EAAE;UAC3BH,iBAAiB,CAACC,SAAS,CAAC,GAAGE,WAAW;QAC9C;MACJ;MACA,IAAI,CAAC,CAAC,EAAEvF,SAAS,CAAC6E,YAAY,EAAEpC,YAAY,CAAC,EAAE;QAC3CjC,UAAU,CAAC+B,QAAQ,CAAC,GAAGzC,eAAe,CAAC,IAAIE,SAAS,CAAC2F,iBAAiB,CAAC;UACnE,GAAGzC,MAAM;UACTiC,MAAM,EAAEC;QACZ,CAAC,CAAC,CAAC;MACP,CAAC,MACI,IAAI,CAAC,CAAC,EAAEpF,SAAS,CAAC8E,eAAe,EAAErC,YAAY,CAAC,EAAE;QACnDjC,UAAU,CAAC+B,QAAQ,CAAC,GAAGzC,eAAe,CAAC,IAAIE,SAAS,CAAC4F,oBAAoB,CAAC;UACtE,GAAG1C,MAAM;UACTiC,MAAM,EAAEC;QACZ,CAAC,CAAC,CAAC;MACP,CAAC,MACI;QACD5E,UAAU,CAAC+B,QAAQ,CAAC,GAAGzC,eAAe,CAAC,IAAIE,SAAS,CAAC6F,sBAAsB,CAAC;UACxE,GAAG3C,MAAM;UACTiC,MAAM,EAAEC;QACZ,CAAC,CAAC,CAAC;MACP;IACJ;EACJ;EACA,OAAO5E,UAAU;AACrB;AACA,SAASC,YAAY,CAAC4B,eAAe,EAAE/B,MAAM,EAAEC,YAAY,EAAE;EACzD,MAAMC,UAAU,GAAG,CAAC,CAAC;EACrB,KAAK,MAAM+B,QAAQ,IAAIF,eAAe,EAAE;IACpC,IAAI,CAACE,QAAQ,CAACC,UAAU,CAAC,IAAI,CAAC,EAAE;MAC5B,MAAMC,YAAY,GAAGJ,eAAe,CAACE,QAAQ,CAAC;MAC9C,IAAI,CAAC,CAAC,CAAC,EAAEvC,SAAS,CAAC6E,YAAY,EAAEpC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,EAAEzC,SAAS,CAAC8E,eAAe,EAAErC,YAAY,CAAC,EAAE;QAC7FjC,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACA,MAAMqD,cAAc,GAAGC,iBAAiB,CAACxF,YAAY,CAAC;MACtD,IAAIuF,cAAc,IAAI,IAAI,EAAE;QACxBtF,UAAU,CAAC+B,QAAQ,CAAC,GAAGE,YAAY;QACnC;MACJ;MACA,MAAMS,MAAM,GAAGT,YAAY,CAACd,QAAQ,EAAE;MACtC,MAAMuD,sBAAsB,GAAGhC,MAAM,CAACiC,MAAM;MAC5C,MAAMC,iBAAiB,GAAG,CAAC,CAAC;MAC5B,KAAK,MAAMC,SAAS,IAAIH,sBAAsB,EAAE;QAC5C,MAAMI,mBAAmB,GAAGJ,sBAAsB,CAACG,SAAS,CAAC;QAC7D,MAAMW,yBAAyB,GAAGV,mBAAmB,CAACW,IAAI;QAC1D,IAAID,yBAAyB,IAAI,IAAI,EAAE;UACnCZ,iBAAiB,CAACC,SAAS,CAAC,GAAGC,mBAAmB;UAClD;QACJ;QACA,MAAMY,aAAa,GAAGxG,MAAM,CAACyG,IAAI,CAACH,yBAAyB,CAAC;QAC5D,IAAI,CAACE,aAAa,CAACE,MAAM,EAAE;UACvBhB,iBAAiB,CAACC,SAAS,CAAC,GAAGC,mBAAmB;UAClD;QACJ;QACA,MAAMe,oBAAoB,GAAG,CAAC,CAAC;QAC/B,KAAK,MAAMC,YAAY,IAAIJ,aAAa,EAAE;UACtC,MAAMK,sBAAsB,GAAGP,yBAAyB,CAACM,YAAY,CAAC;UACtE,MAAME,cAAc,GAAGV,cAAc,CAACS,sBAAsB,EAAElB,SAAS,EAAE9C,QAAQ,EAAEjC,MAAM,CAAC;UAC1F,IAAIkG,cAAc,KAAK3D,SAAS,EAAE;YAC9BwD,oBAAoB,CAACC,YAAY,CAAC,GAAGC,sBAAsB;UAC/D,CAAC,MACI,IAAI9C,KAAK,CAACC,OAAO,CAAC8C,cAAc,CAAC,EAAE;YACpC,MAAM,CAACC,eAAe,EAAEC,iBAAiB,CAAC,GAAGF,cAAc;YAC3DH,oBAAoB,CAACI,eAAe,CAAC,GAAGC,iBAAiB;UAC7D,CAAC,MACI,IAAIF,cAAc,KAAK,IAAI,EAAE;YAC9BH,oBAAoB,CAACC,YAAY,CAAC,GAAGE,cAAc;UACvD;QACJ;QACApB,iBAAiB,CAACC,SAAS,CAAC,GAAG;UAC3B,GAAGC,mBAAmB;UACtBW,IAAI,EAAEI;QACV,CAAC;MACL;MACA,IAAI,CAAC,CAAC,EAAErG,SAAS,CAAC6E,YAAY,EAAEpC,YAAY,CAAC,EAAE;QAC3CjC,UAAU,CAAC+B,QAAQ,CAAC,GAAG,IAAIvC,SAAS,CAAC2F,iBAAiB,CAAC;UACnD,GAAGzC,MAAM;UACTiC,MAAM,EAAEC;QACZ,CAAC,CAAC;MACN,CAAC,MACI,IAAI,CAAC,CAAC,EAAEpF,SAAS,CAAC8E,eAAe,EAAErC,YAAY,CAAC,EAAE;QACnDjC,UAAU,CAAC+B,QAAQ,CAAC,GAAG,IAAIvC,SAAS,CAAC4F,oBAAoB,CAAC;UACtD,GAAG1C,MAAM;UACTiC,MAAM,EAAEC;QACZ,CAAC,CAAC;MACN,CAAC,MACI;QACD5E,UAAU,CAAC+B,QAAQ,CAAC,GAAG,IAAIvC,SAAS,CAAC6F,sBAAsB,CAAC;UACxD,GAAG3C,MAAM;UACTiC,MAAM,EAAEC;QACZ,CAAC,CAAC;MACN;IACJ;EACJ;EACA,OAAO5E,UAAU;AACrB;AACA,SAASc,aAAa,CAACH,kBAAkB,EAAEb,MAAM,EAAEC,YAAY,EAAE;EAC7D,MAAMoG,eAAe,GAAGC,kBAAkB,CAACrG,YAAY,CAAC;EACxD,IAAIoG,eAAe,IAAI,IAAI,EAAE;IACzB,OAAOxF,kBAAkB,CAAC0F,KAAK,EAAE;EACrC;EACA,MAAMxF,aAAa,GAAG,EAAE;EACxB,KAAK,MAAMyF,SAAS,IAAI3F,kBAAkB,EAAE;IACxC,MAAM4F,eAAe,GAAGJ,eAAe,CAACG,SAAS,EAAExG,MAAM,CAAC;IAC1D,IAAIyG,eAAe,KAAKlE,SAAS,EAAE;MAC/BxB,aAAa,CAAC2F,IAAI,CAACF,SAAS,CAAC;IACjC,CAAC,MACI,IAAIC,eAAe,KAAK,IAAI,EAAE;MAC/B1F,aAAa,CAAC2F,IAAI,CAACD,eAAe,CAAC;IACvC;EACJ;EACA,OAAO1F,aAAa;AACxB;AACA,SAAS4F,iBAAiB,CAAC3G,MAAM,EAAEiC,QAAQ,EAAE;EACzC,IAAI2E,EAAE,EAAEC,EAAE,EAAEC,EAAE;EACd,MAAMpG,IAAI,GAAGV,MAAM,CAAC+G,OAAO,CAAC9E,QAAQ,CAAC;EACrC,MAAM+E,UAAU,GAAG,CAACnH,eAAe,CAAC6C,UAAU,CAACuE,IAAI,CAAC;EACpD,IAAI,CAAC,CAAC,EAAEvH,SAAS,CAAC6E,YAAY,EAAE7D,IAAI,CAAC,EAAE;IACnCsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAACwE,cAAc,EAAErH,eAAe,CAAC6C,UAAU,CAACyE,WAAW,CAAC;IAClG,IAAIlF,QAAQ,MAAM,CAAC2E,EAAE,GAAG5G,MAAM,CAACwB,YAAY,EAAE,MAAM,IAAI,IAAIoF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC1D,IAAI,CAAC,EAAE;MAC1F8D,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC0E,WAAW,EAAEvH,eAAe,CAAC6C,UAAU,CAAC2E,KAAK,CAAC;IAC7F,CAAC,MACI,IAAIpF,QAAQ,MAAM,CAAC4E,EAAE,GAAG7G,MAAM,CAAC0B,eAAe,EAAE,MAAM,IAAI,IAAImF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC3D,IAAI,CAAC,EAAE;MAClG8D,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC0E,WAAW,EAAEvH,eAAe,CAAC6C,UAAU,CAAC4E,QAAQ,CAAC;IAChG,CAAC,MACI,IAAIrF,QAAQ,MAAM,CAAC6E,EAAE,GAAG9G,MAAM,CAAC4B,mBAAmB,EAAE,MAAM,IAAI,IAAIkF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC5D,IAAI,CAAC,EAAE;MACtG8D,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC0E,WAAW,EAAEvH,eAAe,CAAC6C,UAAU,CAAC6E,YAAY,CAAC;IACpG;EACJ,CAAC,MACI,IAAI,CAAC,CAAC,EAAE7H,SAAS,CAAC+E,iBAAiB,EAAE/D,IAAI,CAAC,EAAE;IAC7CsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC8E,iBAAiB,CAAC;EACjE,CAAC,MACI,IAAI,CAAC,CAAC,EAAE9H,SAAS,CAAC8E,eAAe,EAAE9D,IAAI,CAAC,EAAE;IAC3CsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAACwE,cAAc,EAAErH,eAAe,CAAC6C,UAAU,CAAC+E,aAAa,EAAE5H,eAAe,CAAC6C,UAAU,CAACgF,cAAc,CAAC;EACnJ,CAAC,MACI,IAAI,CAAC,CAAC,EAAEhI,SAAS,CAACiI,WAAW,EAAEjH,IAAI,CAAC,EAAE;IACvCsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAACwE,cAAc,EAAErH,eAAe,CAAC6C,UAAU,CAAC+E,aAAa,EAAE5H,eAAe,CAAC6C,UAAU,CAACkF,UAAU,CAAC;EAC/I,CAAC,MACI,IAAI,CAAC,CAAC,EAAElI,SAAS,CAAC8D,UAAU,EAAE9C,IAAI,CAAC,EAAE;IACtCsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAACC,SAAS,CAAC;EACzD,CAAC,MACI,IAAI,CAAC,CAAC,EAAEjD,SAAS,CAACmI,YAAY,EAAEnH,IAAI,CAAC,EAAE;IACxCsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAACoF,WAAW,CAAC;EAC3D;EACA,OAAOd,UAAU;AACrB;AACA,SAAS3E,aAAa,CAACrC,MAAM,EAAEC,YAAY,EAAEgC,QAAQ,EAAE;EACnD,MAAM+E,UAAU,GAAGL,iBAAiB,CAAC3G,MAAM,EAAEiC,QAAQ,CAAC;EACtD,IAAIG,UAAU;EACd,MAAM2F,KAAK,GAAG,CAAC,GAAGf,UAAU,CAAC;EAC7B,OAAO,CAAC5E,UAAU,IAAI2F,KAAK,CAACjC,MAAM,GAAG,CAAC,EAAE;IACpC;IACA,MAAMkC,IAAI,GAAGD,KAAK,CAACE,GAAG,EAAE;IACxB7F,UAAU,GAAGnC,YAAY,CAAC+H,IAAI,CAAC;EACnC;EACA,OAAO5F,UAAU,IAAI,IAAI,GAAGA,UAAU,GAAG,IAAI;AACjD;AACA,SAAS8F,kBAAkB,CAAClI,MAAM,EAAEiC,QAAQ,EAAE;EAC1C,IAAI2E,EAAE,EAAEC,EAAE,EAAEC,EAAE;EACd,MAAMpG,IAAI,GAAGV,MAAM,CAAC+G,OAAO,CAAC9E,QAAQ,CAAC;EACrC,MAAM+E,UAAU,GAAG,CAACnH,eAAe,CAAC6C,UAAU,CAACyF,KAAK,CAAC;EACrD,IAAI,CAAC,CAAC,EAAEzI,SAAS,CAAC6E,YAAY,EAAE7D,IAAI,CAAC,EAAE;IACnCsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC0F,eAAe,EAAEvI,eAAe,CAAC6C,UAAU,CAAC2F,YAAY,CAAC;IACpG,IAAIpG,QAAQ,MAAM,CAAC2E,EAAE,GAAG5G,MAAM,CAACwB,YAAY,EAAE,MAAM,IAAI,IAAIoF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC1D,IAAI,CAAC,EAAE;MAC1F8D,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC4F,UAAU,EAAEzI,eAAe,CAAC6C,UAAU,CAAC6F,gBAAgB,CAAC;IACvG,CAAC,MACI,IAAItG,QAAQ,MAAM,CAAC4E,EAAE,GAAG7G,MAAM,CAAC0B,eAAe,EAAE,MAAM,IAAI,IAAImF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC3D,IAAI,CAAC,EAAE;MAClG8D,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC4F,UAAU,EAAEzI,eAAe,CAAC6C,UAAU,CAAC8F,mBAAmB,CAAC;IAC1G,CAAC,MACI,IAAIvG,QAAQ,MAAM,CAAC6E,EAAE,GAAG9G,MAAM,CAAC4B,mBAAmB,EAAE,MAAM,IAAI,IAAIkF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC5D,IAAI,CAAC,EAAE;MACtG8D,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC4F,UAAU,EAAEzI,eAAe,CAAC6C,UAAU,CAAC+F,uBAAuB,CAAC;IAC9G;EACJ,CAAC,MACI,IAAI,CAAC,CAAC,EAAE/I,SAAS,CAAC8E,eAAe,EAAE9D,IAAI,CAAC,EAAE;IAC3CsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAAC0F,eAAe,EAAEvI,eAAe,CAAC6C,UAAU,CAACgG,eAAe,CAAC;EAC3G,CAAC,MACI,IAAI,CAAC,CAAC,EAAEhJ,SAAS,CAAC+E,iBAAiB,EAAE/D,IAAI,CAAC,EAAE;IAC7CsG,UAAU,CAACN,IAAI,CAAC7G,eAAe,CAAC6C,UAAU,CAACoB,kBAAkB,CAAC;EAClE;EACA,OAAOkD,UAAU;AACrB;AACA,SAASrC,cAAc,CAAC3E,MAAM,EAAEC,YAAY,EAAEgC,QAAQ,EAAE;EACpD,MAAM+E,UAAU,GAAGkB,kBAAkB,CAAClI,MAAM,EAAEiC,QAAQ,CAAC;EACvD,IAAIyC,WAAW;EACf,MAAMqD,KAAK,GAAG,CAAC,GAAGf,UAAU,CAAC;EAC7B,OAAO,CAACtC,WAAW,IAAIqD,KAAK,CAACjC,MAAM,GAAG,CAAC,EAAE;IACrC;IACA,MAAMkC,IAAI,GAAGD,KAAK,CAACE,GAAG,EAAE;IACxB;IACAvD,WAAW,GAAGzE,YAAY,CAAC+H,IAAI,CAAC;EACpC;EACA,OAAOtD,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG,IAAI;AAC9E;AACA,SAASe,iBAAiB,CAACxF,YAAY,EAAE;EACrC,MAAMuF,cAAc,GAAGvF,YAAY,CAACJ,eAAe,CAAC6C,UAAU,CAACgB,QAAQ,CAAC;EACxE,OAAO8B,cAAc,IAAI,IAAI,GAAGA,cAAc,GAAG,IAAI;AACzD;AACA,SAASc,kBAAkB,CAACrG,YAAY,EAAE;EACtC,MAAMoG,eAAe,GAAGpG,YAAY,CAACJ,eAAe,CAAC6C,UAAU,CAACiG,SAAS,CAAC;EAC1E,OAAOtC,eAAe,IAAI,IAAI,GAAGA,eAAe,GAAG,IAAI;AAC3D;AACA,SAAS5D,kBAAkB,CAACxC,YAAY,EAAE;EACtC,MAAMuC,eAAe,GAAGvC,YAAY,CAACJ,eAAe,CAAC6C,UAAU,CAACkG,UAAU,CAAC;EAC3E,OAAOpG,eAAe,IAAI,IAAI,GAAGA,eAAe,GAAG,IAAI;AAC3D;AACA,SAAShD,eAAe,CAACkB,IAAI,EAAE;EAC3B,IAAI,CAAC,CAAC,EAAEhB,SAAS,CAAC6E,YAAY,EAAE7D,IAAI,CAAC,EAAE;IACnC,MAAMkC,MAAM,GAAGlC,IAAI,CAACW,QAAQ,EAAE;IAC9B,IAAIuB,MAAM,CAACwC,OAAO,IAAI,IAAI,EAAE;MACxB,MAAMP,MAAM,GAAG,EAAE;MACjB,KAAK,MAAME,SAAS,IAAInC,MAAM,CAACiC,MAAM,EAAE;QACnC,MAAMgE,WAAW,GAAGjG,MAAM,CAACiC,MAAM,CAACE,SAAS,CAAC;QAC5C,IAAI8D,WAAW,CAACzD,OAAO,IAAI,IAAI,EAAE;UAC7BP,MAAM,CAAC6B,IAAI,CAACmC,WAAW,CAACzD,OAAO,CAAC;QACpC;MACJ;MACAxC,MAAM,CAACwC,OAAO,GAAG;QACb,GAAGxC,MAAM,CAACwC,OAAO;QACjB0D,IAAI,EAAEpJ,SAAS,CAACqJ,IAAI,CAACC,sBAAsB;QAC3CnE;MACJ,CAAC;IACL;IACA,IAAIjC,MAAM,CAACqG,iBAAiB,IAAI,IAAI,EAAE;MAClCrG,MAAM,CAACqG,iBAAiB,GAAGrG,MAAM,CAACqG,iBAAiB,CAACC,GAAG,CAACC,IAAI,KAAK;QAC7D,GAAGA,IAAI;QACPL,IAAI,EAAEpJ,SAAS,CAACqJ,IAAI,CAACK,qBAAqB;QAC1CvE,MAAM,EAAEtC;MACZ,CAAC,CAAC,CAAC;IACP;IACA,OAAO,IAAI7C,SAAS,CAAC2F,iBAAiB,CAACzC,MAAM,CAAC;EAClD,CAAC,MACI,IAAI,CAAC,CAAC,EAAElD,SAAS,CAAC8E,eAAe,EAAE9D,IAAI,CAAC,EAAE;IAC3C,MAAMkC,MAAM,GAAGlC,IAAI,CAACW,QAAQ,EAAE;IAC9B,IAAIuB,MAAM,CAACwC,OAAO,IAAI,IAAI,EAAE;MACxB,MAAMP,MAAM,GAAG,EAAE;MACjB,KAAK,MAAME,SAAS,IAAInC,MAAM,CAACiC,MAAM,EAAE;QACnC,MAAMgE,WAAW,GAAGjG,MAAM,CAACiC,MAAM,CAACE,SAAS,CAAC;QAC5C,IAAI8D,WAAW,CAACzD,OAAO,IAAI,IAAI,EAAE;UAC7BP,MAAM,CAAC6B,IAAI,CAACmC,WAAW,CAACzD,OAAO,CAAC;QACpC;MACJ;MACAxC,MAAM,CAACwC,OAAO,GAAG;QACb,GAAGxC,MAAM,CAACwC,OAAO;QACjB0D,IAAI,EAAEpJ,SAAS,CAACqJ,IAAI,CAACM,yBAAyB;QAC9CxE;MACJ,CAAC;IACL;IACA,IAAIjC,MAAM,CAACqG,iBAAiB,IAAI,IAAI,EAAE;MAClCrG,MAAM,CAACqG,iBAAiB,GAAGrG,MAAM,CAACqG,iBAAiB,CAACC,GAAG,CAACC,IAAI,KAAK;QAC7D,GAAGA,IAAI;QACPL,IAAI,EAAEpJ,SAAS,CAACqJ,IAAI,CAACO,wBAAwB;QAC7CzE,MAAM,EAAEtC;MACZ,CAAC,CAAC,CAAC;IACP;IACA,OAAO,IAAI7C,SAAS,CAAC4F,oBAAoB,CAAC1C,MAAM,CAAC;EACrD,CAAC,MACI,IAAI,CAAC,CAAC,EAAElD,SAAS,CAAC+E,iBAAiB,EAAE/D,IAAI,CAAC,EAAE;IAC7C,MAAMkC,MAAM,GAAGlC,IAAI,CAACW,QAAQ,EAAE;IAC9B,IAAIuB,MAAM,CAACwC,OAAO,IAAI,IAAI,EAAE;MACxB,MAAMP,MAAM,GAAG,EAAE;MACjB,KAAK,MAAME,SAAS,IAAInC,MAAM,CAACiC,MAAM,EAAE;QACnC,MAAMgE,WAAW,GAAGjG,MAAM,CAACiC,MAAM,CAACE,SAAS,CAAC;QAC5C,IAAI8D,WAAW,CAACzD,OAAO,IAAI,IAAI,EAAE;UAC7BP,MAAM,CAAC6B,IAAI,CAACmC,WAAW,CAACzD,OAAO,CAAC;QACpC;MACJ;MACAxC,MAAM,CAACwC,OAAO,GAAG;QACb,GAAGxC,MAAM,CAACwC,OAAO;QACjB0D,IAAI,EAAEpJ,SAAS,CAACqJ,IAAI,CAACQ,4BAA4B;QACjD1E;MACJ,CAAC;IACL;IACA,IAAIjC,MAAM,CAACqG,iBAAiB,IAAI,IAAI,EAAE;MAClCrG,MAAM,CAACqG,iBAAiB,GAAGrG,MAAM,CAACqG,iBAAiB,CAACC,GAAG,CAACC,IAAI,KAAK;QAC7D,GAAGA,IAAI;QACPL,IAAI,EAAEpJ,SAAS,CAACqJ,IAAI,CAACS,2BAA2B;QAChD3E,MAAM,EAAEtC;MACZ,CAAC,CAAC,CAAC;IACP;IACA,OAAO,IAAI7C,SAAS,CAAC6F,sBAAsB,CAAC3C,MAAM,CAAC;EACvD,CAAC,MACI,IAAI,CAAC,CAAC,EAAElD,SAAS,CAAC8D,UAAU,EAAE9C,IAAI,CAAC,EAAE;IACtC,MAAMkC,MAAM,GAAGlC,IAAI,CAACW,QAAQ,EAAE;IAC9B,IAAIuB,MAAM,CAACwC,OAAO,IAAI,IAAI,EAAE;MACxB,MAAMtD,MAAM,GAAG,EAAE;MACjB,KAAK,MAAM2H,OAAO,IAAI7G,MAAM,CAACd,MAAM,EAAE;QACjC,MAAM4H,eAAe,GAAG9G,MAAM,CAACd,MAAM,CAAC2H,OAAO,CAAC;QAC9C,IAAIC,eAAe,CAACtE,OAAO,IAAI,IAAI,EAAE;UACjCtD,MAAM,CAAC4E,IAAI,CAACgD,eAAe,CAACtE,OAAO,CAAC;QACxC;MACJ;MACAxC,MAAM,CAACwC,OAAO,GAAG;QACb,GAAGxC,MAAM,CAACwC,OAAO;QACjBtD;MACJ,CAAC;IACL;IACA,IAAIc,MAAM,CAACqG,iBAAiB,IAAI,IAAI,EAAE;MAClCrG,MAAM,CAACqG,iBAAiB,GAAGrG,MAAM,CAACqG,iBAAiB,CAACC,GAAG,CAACC,IAAI,KAAK;QAC7D,GAAGA,IAAI;QACPrH,MAAM,EAAES;MACZ,CAAC,CAAC,CAAC;IACP;IACA,OAAO,IAAI7C,SAAS,CAAC6D,eAAe,CAACX,MAAM,CAAC;EAChD,CAAC,MACI;IACD,OAAOlC,IAAI;EACf;AACJ;AACApB,OAAO,CAACE,eAAe,GAAGA,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}