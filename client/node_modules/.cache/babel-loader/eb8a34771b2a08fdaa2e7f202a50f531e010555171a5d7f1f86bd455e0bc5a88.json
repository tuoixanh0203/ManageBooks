{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectSubFields = exports.collectFields = void 0;\nconst memoize_js_1 = require(\"./memoize.js\");\nconst graphql_1 = require(\"graphql\");\n// Taken from GraphQL-JS v16 for backwards compat\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case graphql_1.Kind.FIELD:\n        {\n          if (!shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          const name = getFieldEntryKey(selection);\n          const fieldList = fields.get(name);\n          if (fieldList !== undefined) {\n            fieldList.push(selection);\n          } else {\n            fields.set(name, [selection]);\n          }\n          break;\n        }\n      case graphql_1.Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n            continue;\n          }\n          collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n      case graphql_1.Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n          if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n            continue;\n          }\n          visitedFragmentNames.add(fragName);\n          const fragment = fragments[fragName];\n          if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n            continue;\n          }\n          collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n  return fields;\n}\nexports.collectFields = collectFields;\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);\n  if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n    return false;\n  }\n  const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);\n  if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n    return false;\n  }\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if ((0, graphql_1.isAbstractType)(conditionalType)) {\n    const possibleTypes = schema.getPossibleTypes(conditionalType);\n    return possibleTypes.includes(type);\n  }\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\nexports.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n  for (const fieldNode of fieldNodes) {\n    if (fieldNode.selectionSet) {\n      collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  }\n  return subFieldNodes;\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","collectSubFields","collectFields","memoize_js_1","require","graphql_1","schema","fragments","variableValues","runtimeType","selectionSet","fields","visitedFragmentNames","selection","selections","kind","Kind","FIELD","shouldIncludeNode","name","getFieldEntryKey","fieldList","get","undefined","push","set","INLINE_FRAGMENT","doesFragmentConditionMatch","FRAGMENT_SPREAD","fragName","has","add","fragment","node","skip","getDirectiveValues","GraphQLSkipDirective","include","GraphQLIncludeDirective","type","typeConditionNode","typeCondition","conditionalType","typeFromAST","isAbstractType","possibleTypes","getPossibleTypes","includes","alias","memoize5","fieldNodes","subFieldNodes","Map","Set","fieldNode"],"sources":["C:/Users/Admin/Documents/Web/GRAPHQL/node_modules/@graphql-tools/schema/node_modules/@graphql-tools/utils/cjs/collectFields.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectSubFields = exports.collectFields = void 0;\nconst memoize_js_1 = require(\"./memoize.js\");\nconst graphql_1 = require(\"graphql\");\n// Taken from GraphQL-JS v16 for backwards compat\nfunction collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case graphql_1.Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const name = getFieldEntryKey(selection);\n                const fieldList = fields.get(name);\n                if (fieldList !== undefined) {\n                    fieldList.push(selection);\n                }\n                else {\n                    fields.set(name, [selection]);\n                }\n                break;\n            }\n            case graphql_1.Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n            case graphql_1.Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                visitedFragmentNames.add(fragName);\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n        }\n    }\n    return fields;\n}\nexports.collectFields = collectFields;\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(variableValues, node) {\n    const skip = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLSkipDirective, node, variableValues);\n    if ((skip === null || skip === void 0 ? void 0 : skip['if']) === true) {\n        return false;\n    }\n    const include = (0, graphql_1.getDirectiveValues)(graphql_1.GraphQLIncludeDirective, node, variableValues);\n    if ((include === null || include === void 0 ? void 0 : include['if']) === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = (0, graphql_1.typeFromAST)(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if ((0, graphql_1.isAbstractType)(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\nexports.collectSubFields = (0, memoize_js_1.memoize5)(function collectSubFields(schema, fragments, variableValues, type, fieldNodes) {\n    const subFieldNodes = new Map();\n    const visitedFragmentNames = new Set();\n    for (const fieldNode of fieldNodes) {\n        if (fieldNode.selectionSet) {\n            collectFields(schema, fragments, variableValues, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n        }\n    }\n    return subFieldNodes;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}