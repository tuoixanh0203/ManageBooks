{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateReferencedFieldsByType = void 0;\nconst graphql_1 = require(\"graphql\");\nconst usage_reporting_protobuf_1 = require(\"@apollo/usage-reporting-protobuf\");\nfunction calculateReferencedFieldsByType(_ref) {\n  let {\n    document,\n    schema,\n    resolvedOperationName\n  } = _ref;\n  const documentSeparatedByOperation = (0, graphql_1.separateOperations)(document);\n  const filteredDocument = documentSeparatedByOperation[resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : \"\"];\n  if (!filteredDocument) {\n    throw Error(`shouldn't happen: operation '${resolvedOperationName !== null && resolvedOperationName !== void 0 ? resolvedOperationName : \"\"}' not found`);\n  }\n  const typeInfo = new graphql_1.TypeInfo(schema);\n  const interfaces = new Set();\n  const referencedFieldSetByType = Object.create(null);\n  (0, graphql_1.visit)(filteredDocument, (0, graphql_1.visitWithTypeInfo)(typeInfo, {\n    Field(field) {\n      const fieldName = field.name.value;\n      const parentType = typeInfo.getParentType();\n      if (!parentType) {\n        throw Error(`shouldn't happen: missing parent type for field ${fieldName}`);\n      }\n      const parentTypeName = parentType.name;\n      if (!referencedFieldSetByType[parentTypeName]) {\n        referencedFieldSetByType[parentTypeName] = new Set();\n        if ((0, graphql_1.isInterfaceType)(parentType)) {\n          interfaces.add(parentTypeName);\n        }\n      }\n      referencedFieldSetByType[parentTypeName].add(fieldName);\n    }\n  }));\n  const referencedFieldsByType = Object.create(null);\n  for (const [typeName, fieldNames] of Object.entries(referencedFieldSetByType)) {\n    referencedFieldsByType[typeName] = new usage_reporting_protobuf_1.ReferencedFieldsForType({\n      fieldNames: [...fieldNames],\n      isInterface: interfaces.has(typeName)\n    });\n  }\n  return referencedFieldsByType;\n}\nexports.calculateReferencedFieldsByType = calculateReferencedFieldsByType;","map":{"version":3,"mappings":";;;;;;AAAA;AASA;AASA,SAAgBA,+BAA+B,OAQ9C;EAAA,IAR+C;IAC9CC,QAAQ;IACRC,MAAM;IACNC;EAAqB,CAKtB;EASC,MAAMC,4BAA4B,GAAG,gCAAkB,EAACH,QAAQ,CAAC;EACjE,MAAMI,gBAAgB,GACpBD,4BAA4B,CAACD,qBAAqB,aAArBA,qBAAqB,cAArBA,qBAAqB,GAAI,EAAE,CAAC;EAC3D,IAAI,CAACE,gBAAgB,EAAE;IAGrB,MAAMC,KAAK,CACT,gCAAgCH,qBAAqB,aAArBA,qBAAqB,cAArBA,qBAAqB,GAAI,EAAE,aAAa,CACzE;;EAEH,MAAMI,QAAQ,GAAG,IAAIC,kBAAQ,CAACN,MAAM,CAAC;EACrC,MAAMO,UAAU,GAAG,IAAIC,GAAG,EAAU;EACpC,MAAMC,wBAAwB,GAAgCC,MAAM,CAACC,MAAM,CACzE,IAAI,CACL;EACD,mBAAK,EACHR,gBAAgB,EAChB,+BAAiB,EAACE,QAAQ,EAAE;IAC1BO,KAAK,CAACC,KAAK;MACT,MAAMC,SAAS,GAAGD,KAAK,CAACE,IAAI,CAACC,KAAK;MAClC,MAAMC,UAAU,GAAGZ,QAAQ,CAACa,aAAa,EAAE;MAC3C,IAAI,CAACD,UAAU,EAAE;QACf,MAAMb,KAAK,CACT,mDAAmDU,SAAS,EAAE,CAC/D;;MAEH,MAAMK,cAAc,GAAGF,UAAU,CAACF,IAAI;MACtC,IAAI,CAACN,wBAAwB,CAACU,cAAc,CAAC,EAAE;QAC7CV,wBAAwB,CAACU,cAAc,CAAC,GAAG,IAAIX,GAAG,EAAU;QAC5D,IAAI,6BAAe,EAACS,UAAU,CAAC,EAAE;UAC/BV,UAAU,CAACa,GAAG,CAACD,cAAc,CAAC;;;MAKlCV,wBAAwB,CAACU,cAAc,CAAE,CAACC,GAAG,CAACN,SAAS,CAAC;IAC1D;GACD,CAAC,CACH;EAKD,MAAMO,sBAAsB,GAAGX,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;EAClD,KAAK,MAAM,CAACW,QAAQ,EAAEC,UAAU,CAAC,IAAIb,MAAM,CAACc,OAAO,CACjDf,wBAAwB,CACzB,EAAE;IACDY,sBAAsB,CAACC,QAAQ,CAAC,GAAG,IAAIG,kDAAuB,CAAC;MAC7DF,UAAU,EAAE,CAAC,GAAGA,UAAU,CAAC;MAC3BG,WAAW,EAAEnB,UAAU,CAACoB,GAAG,CAACL,QAAQ;KACrC,CAAC;;EAEJ,OAAOD,sBAAsB;AAC/B;AAtEAO","names":["calculateReferencedFieldsByType","document","schema","resolvedOperationName","documentSeparatedByOperation","filteredDocument","Error","typeInfo","graphql_1","interfaces","Set","referencedFieldSetByType","Object","create","Field","field","fieldName","name","value","parentType","getParentType","parentTypeName","add","referencedFieldsByType","typeName","fieldNames","entries","usage_reporting_protobuf_1","isInterface","has","exports"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\@apollo\\utils.usagereporting\\src\\calculateReferencedFieldsByType.ts"],"sourcesContent":["import {\n  DocumentNode,\n  GraphQLSchema,\n  isInterfaceType,\n  separateOperations,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from \"graphql\";\nimport { ReferencedFieldsForType } from \"@apollo/usage-reporting-protobuf\";\n\nexport interface OperationDerivedData {\n  signature: string;\n  referencedFieldsByType: ReferencedFieldsByType;\n}\n\nexport type ReferencedFieldsByType = Record<string, ReferencedFieldsForType>;\n\nexport function calculateReferencedFieldsByType({\n  document,\n  schema,\n  resolvedOperationName,\n}: {\n  document: DocumentNode;\n  resolvedOperationName: string | null;\n  schema: GraphQLSchema;\n}): ReferencedFieldsByType {\n  // If the document contains multiple operations, we only care about fields\n  // referenced in the operation we're using and in fragments that are\n  // (transitively) spread by that operation. (This is because Studio's field\n  // usage accounting is all by operation, not by document.) This does mean that\n  // a field can be textually present in a GraphQL document (and need to exist\n  // for validation) without being represented in the reported referenced fields\n  // structure, but we'd need to change the data model of Studio to be based on\n  // documents rather than fields if we wanted to improve that.\n  const documentSeparatedByOperation = separateOperations(document);\n  const filteredDocument =\n    documentSeparatedByOperation[resolvedOperationName ?? \"\"];\n  if (!filteredDocument) {\n    // This shouldn't happen because we only should call this function on\n    // properly executable documents.\n    throw Error(\n      `shouldn't happen: operation '${resolvedOperationName ?? \"\"}' not found`,\n    );\n  }\n  const typeInfo = new TypeInfo(schema);\n  const interfaces = new Set<string>();\n  const referencedFieldSetByType: Record<string, Set<string>> = Object.create(\n    null,\n  );\n  visit(\n    filteredDocument,\n    visitWithTypeInfo(typeInfo, {\n      Field(field) {\n        const fieldName = field.name.value;\n        const parentType = typeInfo.getParentType();\n        if (!parentType) {\n          throw Error(\n            `shouldn't happen: missing parent type for field ${fieldName}`,\n          );\n        }\n        const parentTypeName = parentType.name;\n        if (!referencedFieldSetByType[parentTypeName]) {\n          referencedFieldSetByType[parentTypeName] = new Set<string>();\n          if (isInterfaceType(parentType)) {\n            interfaces.add(parentTypeName);\n          }\n        }\n\n        // We know this is set to an empty Set if it didn't exist immediately above\n        referencedFieldSetByType[parentTypeName]!.add(fieldName);\n      },\n    }),\n  );\n\n  // Convert from initial representation (which uses Sets to avoid quadratic\n  // behavior) to the protobufjs objects. (We could also use js_use_toArray here\n  // but that seems a little overkill.)\n  const referencedFieldsByType = Object.create(null);\n  for (const [typeName, fieldNames] of Object.entries(\n    referencedFieldSetByType,\n  )) {\n    referencedFieldsByType[typeName] = new ReferencedFieldsForType({\n      fieldNames: [...fieldNames],\n      isInterface: interfaces.has(typeName),\n    });\n  }\n  return referencedFieldsByType;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}