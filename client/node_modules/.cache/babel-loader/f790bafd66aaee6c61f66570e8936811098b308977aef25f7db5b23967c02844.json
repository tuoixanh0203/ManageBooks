{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = void 0;\nconst graphql_1 = require(\"graphql\");\nconst schemaInstrumentation_1 = require(\"./utils/schemaInstrumentation\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst dispatcher_1 = require(\"./utils/dispatcher\");\nconst utils_keyvaluecache_1 = require(\"@apollo/utils.keyvaluecache\");\nconst createSHA_1 = __importDefault(require(\"./utils/createSHA\"));\nconst runHttpQuery_1 = require(\"./runHttpQuery\");\nconst apollo_server_env_1 = require(\"apollo-server-env\");\nexports.APQ_CACHE_PREFIX = 'apq:';\nfunction computeQueryHash(query) {\n  return (0, createSHA_1.default)('sha256').update(query).digest('hex');\n}\nfunction isBadUserInputGraphQLError(error) {\n  var _a;\n  return ((_a = error.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && (error.message.startsWith(`Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `) || error.message.startsWith(`Variable \"$${error.nodes[0].variable.name.value}\" of required type `) || error.message.startsWith(`Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `));\n}\nasync function processGraphQLRequest(config, requestContext) {\n  var _a, _b;\n  const logger = requestContext.logger || console;\n  const metrics = requestContext.metrics = requestContext.metrics || Object.create(null);\n  const dispatcher = await initializeRequestListenerDispatcher();\n  await initializeDataSources();\n  const request = requestContext.request;\n  let {\n    query,\n    extensions\n  } = request;\n  let queryHash;\n  let persistedQueryCache;\n  metrics.persistedQueryHit = false;\n  metrics.persistedQueryRegister = false;\n  if (extensions === null || extensions === void 0 ? void 0 : extensions.persistedQuery) {\n    if (!config.persistedQueries || !config.persistedQueries.cache) {\n      return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotSupportedError());\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse(new graphql_1.GraphQLError('Unsupported persisted query version'));\n    }\n    persistedQueryCache = config.persistedQueries.cache;\n    if (!(persistedQueryCache instanceof utils_keyvaluecache_1.PrefixingKeyValueCache)) {\n      persistedQueryCache = new utils_keyvaluecache_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);\n    }\n    queryHash = extensions.persistedQuery.sha256Hash;\n    if (query === undefined) {\n      query = await persistedQueryCache.get(queryHash);\n      if (query) {\n        metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse(new apollo_server_errors_1.PersistedQueryNotFoundError());\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse(new graphql_1.GraphQLError('provided sha does not match query'));\n      }\n      metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse(new graphql_1.GraphQLError('GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.'));\n  }\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n  await dispatcher.invokeHook('didResolveSource', requestContext);\n  if (config.documentStore) {\n    try {\n      requestContext.document = await config.documentStore.get(queryHash);\n    } catch (err) {\n      logger.warn('An error occurred while attempting to read from the documentStore. ' + (err === null || err === void 0 ? void 0 : err.message) || err);\n    }\n  }\n  if (!requestContext.document) {\n    const parsingDidEnd = await dispatcher.invokeDidStartHook('parsingDidStart', requestContext);\n    try {\n      requestContext.document = parse(query, config.parseOptions);\n      await parsingDidEnd();\n    } catch (syntaxError) {\n      await parsingDidEnd(syntaxError);\n      return await sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);\n    }\n    const validationDidEnd = await dispatcher.invokeDidStartHook('validationDidStart', requestContext);\n    const validationErrors = validate(requestContext.document);\n    if (validationErrors.length === 0) {\n      await validationDidEnd();\n    } else {\n      await validationDidEnd(validationErrors);\n      return await sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);\n    }\n    if (config.documentStore) {\n      Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch(err => logger.warn('Could not store validated document. ' + (err === null || err === void 0 ? void 0 : err.message) || err));\n    }\n  }\n  const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);\n  requestContext.operation = operation || undefined;\n  requestContext.operationName = ((_a = operation === null || operation === void 0 ? void 0 : operation.name) === null || _a === void 0 ? void 0 : _a.value) || null;\n  try {\n    await dispatcher.invokeHook('didResolveOperation', requestContext);\n  } catch (err) {\n    return await sendErrorResponse(err);\n  }\n  if (metrics.persistedQueryRegister && persistedQueryCache) {\n    Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== 'undefined' ? {\n      ttl: config.persistedQueries.ttl\n    } : Object.create(null))).catch(logger.warn);\n  }\n  let response = await dispatcher.invokeHooksUntilNonNull('responseForOperation', requestContext);\n  if (response == null) {\n    const executionListeners = [];\n    (await dispatcher.invokeHook('executionDidStart', requestContext)).forEach(executionListener => {\n      if (executionListener) {\n        executionListeners.push(executionListener);\n      }\n    });\n    executionListeners.reverse();\n    const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);\n    if (executionDispatcher.hasHook('willResolveField')) {\n      const invokeWillResolveField = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        return executionDispatcher.invokeSyncDidStartHook('willResolveField', ...args);\n      };\n      Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, {\n        value: invokeWillResolveField\n      });\n      if (config.fieldResolver) {\n        Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {\n          value: config.fieldResolver\n        });\n      }\n      (0, schemaInstrumentation_1.enablePluginsForSchemaResolvers)(config.schema);\n    }\n    try {\n      const result = await execute(requestContext);\n      const resultErrors = (_b = result.errors) === null || _b === void 0 ? void 0 : _b.map(e => {\n        if (isBadUserInputGraphQLError(e)) {\n          return (0, apollo_server_errors_1.fromGraphQLError)(e, {\n            errorClass: apollo_server_errors_1.UserInputError\n          });\n        }\n        return e;\n      });\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n      response = {\n        ...result,\n        errors: resultErrors ? formatErrors(resultErrors) : undefined\n      };\n      await executionDispatcher.invokeHook('executionDidEnd');\n    } catch (executionError) {\n      await executionDispatcher.invokeHook('executionDidEnd', executionError);\n      return await sendErrorResponse(executionError);\n    }\n  }\n  if (config.formatResponse) {\n    const formattedResponse = config.formatResponse(response, requestContext);\n    if (formattedResponse != null) {\n      response = formattedResponse;\n    }\n  }\n  return sendResponse(response);\n  function parse(query, parseOptions) {\n    return (0, graphql_1.parse)(query, parseOptions);\n  }\n  function validate(document) {\n    let rules = graphql_1.specifiedRules;\n    if (config.validationRules) {\n      rules = rules.concat(config.validationRules);\n    }\n    return (0, graphql_1.validate)(config.schema, document, rules);\n  }\n  async function execute(requestContext) {\n    const {\n      request,\n      document\n    } = requestContext;\n    const executionArgs = {\n      schema: config.schema,\n      document,\n      rootValue: typeof config.rootValue === 'function' ? config.rootValue(document) : config.rootValue,\n      contextValue: requestContext.context,\n      variableValues: request.variables,\n      operationName: request.operationName,\n      fieldResolver: config.fieldResolver\n    };\n    if (config.executor) {\n      return await config.executor(requestContext);\n    } else {\n      return await (0, graphql_1.execute)(executionArgs);\n    }\n  }\n  async function sendResponse(response) {\n    requestContext.response = {\n      ...requestContext.response,\n      errors: response.errors,\n      data: response.data,\n      extensions: response.extensions\n    };\n    if (response.http) {\n      if (!requestContext.response.http) {\n        requestContext.response.http = {\n          headers: new apollo_server_env_1.Headers()\n        };\n      }\n      if (response.http.status) {\n        requestContext.response.http.status = response.http.status;\n      }\n      for (const [name, value] of response.http.headers) {\n        requestContext.response.http.headers.set(name, value);\n      }\n    }\n    await dispatcher.invokeHook('willSendResponse', requestContext);\n    return requestContext.response;\n  }\n  async function didEncounterErrors(errors) {\n    requestContext.errors = errors;\n    return await dispatcher.invokeHook('didEncounterErrors', requestContext);\n  }\n  async function sendErrorResponse(errorOrErrors, errorClass) {\n    const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n    await didEncounterErrors(errors);\n    const response = {\n      errors: formatErrors(errors.map(err => err instanceof apollo_server_errors_1.ApolloError && !errorClass ? err : (0, apollo_server_errors_1.fromGraphQLError)(err, errorClass && {\n        errorClass\n      })))\n    };\n    if (errors.every(err => err instanceof apollo_server_errors_1.PersistedQueryNotSupportedError || err instanceof apollo_server_errors_1.PersistedQueryNotFoundError)) {\n      response.http = {\n        status: 200,\n        headers: new apollo_server_env_1.Headers({\n          'Cache-Control': 'private, no-cache, must-revalidate'\n        })\n      };\n    } else if (errors.length === 1 && errors[0] instanceof runHttpQuery_1.HttpQueryError) {\n      response.http = {\n        status: errors[0].statusCode,\n        headers: new apollo_server_env_1.Headers(errors[0].headers)\n      };\n    }\n    return sendResponse(response);\n  }\n  function formatErrors(errors) {\n    return (0, apollo_server_errors_1.formatApolloErrors)(errors, {\n      formatter: config.formatError,\n      debug: requestContext.debug\n    });\n  }\n  async function initializeRequestListenerDispatcher() {\n    const requestListeners = [];\n    if (config.plugins) {\n      for (const plugin of config.plugins) {\n        if (!plugin.requestDidStart) continue;\n        const listener = await plugin.requestDidStart(requestContext);\n        if (listener) {\n          requestListeners.push(listener);\n        }\n      }\n    }\n    return new dispatcher_1.Dispatcher(requestListeners);\n  }\n  async function initializeDataSources() {\n    if (config.dataSources) {\n      const context = requestContext.context;\n      const dataSources = config.dataSources();\n      const initializers = [];\n      for (const dataSource of Object.values(dataSources)) {\n        if (dataSource.initialize) {\n          initializers.push(dataSource.initialize({\n            context,\n            cache: requestContext.cache\n          }));\n        }\n      }\n      await Promise.all(initializers);\n      if ('dataSources' in context) {\n        throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');\n      }\n      context.dataSources = dataSources;\n    }\n  }\n}\nexports.processGraphQLRequest = processGraphQLRequest;","map":{"version":3,"mappings":"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","names":["exports","computeQueryHash","query","update","digest","isBadUserInputGraphQLError","error","nodes","length","kind","graphql_1","VARIABLE_DEFINITION","message","startsWith","variable","name","value","processGraphQLRequest","config","requestContext","logger","console","metrics","Object","create","dispatcher","initializeRequestListenerDispatcher","initializeDataSources","request","extensions","queryHash","persistedQueryCache","persistedQueryHit","persistedQueryRegister","persistedQuery","persistedQueries","cache","sendErrorResponse","apollo_server_errors_1","version","utils_keyvaluecache_1","sha256Hash","undefined","get","computedQueryHash","source","invokeHook","documentStore","document","err","warn","parsingDidEnd","invokeDidStartHook","parse","parseOptions","syntaxError","validationDidEnd","validationErrors","validate","Promise","resolve","set","catch","operation","operationName","ttl","response","invokeHooksUntilNonNull","executionListeners","forEach","executionListener","push","reverse","executionDispatcher","dispatcher_1","hasHook","invokeWillResolveField","args","invokeSyncDidStartHook","defineProperty","context","schemaInstrumentation_1","fieldResolver","schema","result","execute","resultErrors","errors","map","e","errorClass","didEncounterErrors","formatErrors","executionError","formatResponse","formattedResponse","sendResponse","rules","validationRules","concat","executionArgs","rootValue","contextValue","variableValues","variables","executor","data","http","headers","apollo_server_env_1","status","errorOrErrors","Array","isArray","every","runHttpQuery_1","statusCode","formatter","formatError","debug","requestListeners","plugins","plugin","requestDidStart","listener","dataSources","initializers","dataSource","values","initialize","all","Error"],"sources":["C:\\Users\\Admin\\Documents\\Web\\GRAPHQL\\node_modules\\apollo-server-core\\src\\requestPipeline.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  specifiedRules,\n  DocumentNode,\n  getOperationAST,\n  ExecutionArgs,\n  GraphQLError,\n  GraphQLFormattedError,\n  validate as graphqlValidate,\n  parse as graphqlParse,\n  execute as graphqlExecute,\n  Kind,\n  ParseOptions,\n} from 'graphql';\nimport type { DataSource } from 'apollo-datasource';\nimport type { PersistedQueryOptions } from './graphqlOptions';\nimport {\n  symbolExecutionDispatcherWillResolveField,\n  enablePluginsForSchemaResolvers,\n  symbolUserFieldResolver,\n} from './utils/schemaInstrumentation';\nimport {\n  ApolloError,\n  fromGraphQLError,\n  SyntaxError,\n  ValidationError,\n  PersistedQueryNotSupportedError,\n  PersistedQueryNotFoundError,\n  formatApolloErrors,\n  UserInputError,\n} from 'apollo-server-errors';\nimport type {\n  GraphQLRequest,\n  GraphQLResponse,\n  GraphQLRequestContext,\n  GraphQLExecutor,\n  GraphQLExecutionResult,\n  ValidationRule,\n  BaseContext,\n} from 'apollo-server-types';\nimport type {\n  ApolloServerPlugin,\n  GraphQLRequestListener,\n  GraphQLRequestContextDidResolveSource,\n  GraphQLRequestContextExecutionDidStart,\n  GraphQLRequestContextResponseForOperation,\n  GraphQLRequestContextDidResolveOperation,\n  GraphQLRequestContextParsingDidStart,\n  GraphQLRequestContextValidationDidStart,\n  GraphQLRequestContextWillSendResponse,\n  GraphQLRequestContextDidEncounterErrors,\n  GraphQLRequestExecutionListener,\n} from 'apollo-server-plugin-base';\n\nimport { Dispatcher } from './utils/dispatcher';\nimport {\n  KeyValueCache,\n  PrefixingKeyValueCache,\n} from '@apollo/utils.keyvaluecache';\n\nexport { GraphQLRequest, GraphQLResponse, GraphQLRequestContext };\n\nimport createSHA from './utils/createSHA';\nimport { HttpQueryError } from './runHttpQuery';\nimport type { DocumentStore } from './types';\nimport { Headers } from 'apollo-server-env';\n\nexport const APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query: string) {\n  return createSHA('sha256').update(query).digest('hex');\n}\n\nexport interface GraphQLRequestPipelineConfig<TContext> {\n  schema: GraphQLSchema;\n\n  rootValue?: ((document: DocumentNode) => any) | any;\n  validationRules?: ValidationRule[];\n  executor?: GraphQLExecutor;\n  fieldResolver?: GraphQLFieldResolver<any, TContext>;\n\n  dataSources?: () => DataSources<TContext>;\n\n  persistedQueries?: PersistedQueryOptions;\n\n  formatError?: (error: GraphQLError) => GraphQLFormattedError;\n  formatResponse?: (\n    response: GraphQLResponse,\n    requestContext: GraphQLRequestContext<TContext>,\n  ) => GraphQLResponse | null;\n\n  plugins?: ApolloServerPlugin[];\n  documentStore?: DocumentStore | null;\n\n  parseOptions?: ParseOptions;\n}\n\nexport type DataSources<TContext> = {\n  [name: string]: DataSource<TContext>;\n};\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nfunction isBadUserInputGraphQLError(error: GraphQLError): Boolean {\n  return (\n    error.nodes?.length === 1 &&\n    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&\n    (error.message.startsWith(\n      `Variable \"$${error.nodes[0].variable.name.value}\" got invalid value `,\n    ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of required type `,\n      ) ||\n      error.message.startsWith(\n        `Variable \"$${error.nodes[0].variable.name.value}\" of non-null type `,\n      ))\n  );\n}\n\nexport async function processGraphQLRequest<TContext extends BaseContext>(\n  config: GraphQLRequestPipelineConfig<TContext>,\n  requestContext: Mutable<GraphQLRequestContext<TContext>>,\n): Promise<GraphQLResponse> {\n  // For legacy reasons, this exported method may exist without a `logger` on\n  // the context.  We'll need to make sure we account for that, even though\n  // all of our own machinery will certainly set it now.\n  const logger = requestContext.logger || console;\n\n  // If request context's `metrics` already exists, preserve it, but _ensure_ it\n  // exists there and shorthand it for use throughout this function.\n  const metrics = (requestContext.metrics =\n    requestContext.metrics || Object.create(null));\n\n  const dispatcher = await initializeRequestListenerDispatcher();\n  await initializeDataSources();\n\n  const request = requestContext.request;\n\n  let { query, extensions } = request;\n\n  let queryHash: string;\n\n  let persistedQueryCache: KeyValueCache | undefined;\n  metrics.persistedQueryHit = false;\n  metrics.persistedQueryRegister = false;\n\n  if (extensions?.persistedQuery) {\n    // It looks like we've received a persisted query. Check if we\n    // support them.\n    if (!config.persistedQueries || !config.persistedQueries.cache) {\n      return await sendErrorResponse(new PersistedQueryNotSupportedError());\n    } else if (extensions.persistedQuery.version !== 1) {\n      return await sendErrorResponse(\n        new GraphQLError('Unsupported persisted query version'),\n      );\n    }\n\n    // We'll store a reference to the persisted query cache so we can actually\n    // do the write at a later point in the request pipeline processing.\n    persistedQueryCache = config.persistedQueries.cache;\n\n    // This is a bit hacky, but if `config` came from direct use of the old\n    // apollo-server 1.0-style middleware (graphqlExpress etc, not via the\n    // ApolloServer class), it won't have been converted to\n    // PrefixingKeyValueCache yet.\n    if (!(persistedQueryCache instanceof PrefixingKeyValueCache)) {\n      persistedQueryCache = new PrefixingKeyValueCache(\n        persistedQueryCache,\n        APQ_CACHE_PREFIX,\n      );\n    }\n\n    queryHash = extensions.persistedQuery.sha256Hash;\n\n    if (query === undefined) {\n      query = await persistedQueryCache.get(queryHash);\n      if (query) {\n        metrics.persistedQueryHit = true;\n      } else {\n        return await sendErrorResponse(new PersistedQueryNotFoundError());\n      }\n    } else {\n      const computedQueryHash = computeQueryHash(query);\n\n      // The provided hash must exactly match the SHA-256 hash of\n      // the query string. This prevents hash hijacking, where a\n      // new and potentially malicious query is associated with\n      // an existing hash.\n      if (queryHash !== computedQueryHash) {\n        return await sendErrorResponse(\n          new GraphQLError('provided sha does not match query'),\n        );\n      }\n\n      // We won't write to the persisted query cache until later.\n      // Deferring the writing gives plugins the ability to \"win\" from use of\n      // the cache, but also have their say in whether or not the cache is\n      // written to (by interrupting the request with an error).\n      metrics.persistedQueryRegister = true;\n    }\n  } else if (query) {\n    // TODO: We'll compute the APQ query hash to use as our cache key for\n    // now, but this should be replaced with the new operation ID algorithm.\n    queryHash = computeQueryHash(query);\n  } else {\n    return await sendErrorResponse(\n      new GraphQLError(\n        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',\n      ),\n    );\n  }\n\n  requestContext.queryHash = queryHash;\n  requestContext.source = query;\n\n  // Let the plugins know that we now have a STRING of what we hope will\n  // parse and validate into a document we can execute on.  Unless we have\n  // retrieved this from our APQ cache, there's no guarantee that it is\n  // syntactically correct, so this string should not be trusted as a valid\n  // document until after it's parsed and validated.\n  await dispatcher.invokeHook(\n    'didResolveSource',\n    requestContext as GraphQLRequestContextDidResolveSource<TContext>,\n  );\n\n  // If we're configured with a document store (by default, we are), we'll\n  // utilize the operation's hash to lookup the AST from the previously\n  // parsed-and-validated operation.  Failure to retrieve anything from the\n  // cache just means we're committed to doing the parsing and validation.\n  if (config.documentStore) {\n    try {\n      requestContext.document = await config.documentStore.get(queryHash);\n    } catch (err) {\n      logger.warn(\n        'An error occurred while attempting to read from the documentStore. ' +\n          (err as Error)?.message || err,\n      );\n    }\n  }\n\n  // If we still don't have a document, we'll need to parse and validate it.\n  // With success, we'll attempt to save it into the store for future use.\n  if (!requestContext.document) {\n    const parsingDidEnd = await dispatcher.invokeDidStartHook(\n      'parsingDidStart',\n      requestContext as GraphQLRequestContextParsingDidStart<TContext>,\n    );\n\n    try {\n      requestContext.document = parse(query, config.parseOptions);\n      await parsingDidEnd();\n    } catch (syntaxError) {\n      await parsingDidEnd(syntaxError as Error);\n      // XXX: This cast is pretty sketchy, as other error types can be thrown\n      // by parsingDidEnd!\n      return await sendErrorResponse(syntaxError as GraphQLError, SyntaxError);\n    }\n\n    const validationDidEnd = await dispatcher.invokeDidStartHook(\n      'validationDidStart',\n      requestContext as GraphQLRequestContextValidationDidStart<TContext>,\n    );\n\n    const validationErrors = validate(requestContext.document);\n\n    if (validationErrors.length === 0) {\n      await validationDidEnd();\n    } else {\n      await validationDidEnd(validationErrors);\n      return await sendErrorResponse(validationErrors, ValidationError);\n    }\n\n    if (config.documentStore) {\n      // The underlying cache store behind the `documentStore` returns a\n      // `Promise` which is resolved (or rejected), eventually, based on the\n      // success or failure (respectively) of the cache save attempt.  While\n      // it's certainly possible to `await` this `Promise`, we don't care about\n      // whether or not it's successful at this point.  We'll instead proceed\n      // to serve the rest of the request and just hope that this works out.\n      // If it doesn't work, the next request will have another opportunity to\n      // try again.  Errors will surface as warnings, as appropriate.\n      //\n      // While it shouldn't normally be necessary to wrap this `Promise` in a\n      // `Promise.resolve` invocation, it seems that the underlying cache store\n      // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n      Promise.resolve(\n        config.documentStore.set(queryHash, requestContext.document),\n      ).catch((err) =>\n        logger.warn(\n          'Could not store validated document. ' + err?.message || err,\n        ),\n      );\n    }\n  }\n\n  // TODO: If we want to guarantee an operation has been set when invoking\n  // `willExecuteOperation` and executionDidStart`, we need to throw an\n  // error here and not leave this to `buildExecutionContext` in\n  // `graphql-js`.\n  const operation = getOperationAST(\n    requestContext.document,\n    request.operationName,\n  );\n\n  requestContext.operation = operation || undefined;\n  // We'll set `operationName` to `null` for anonymous operations.\n  requestContext.operationName = operation?.name?.value || null;\n\n  try {\n    await dispatcher.invokeHook(\n      'didResolveOperation',\n      requestContext as GraphQLRequestContextDidResolveOperation<TContext>,\n    );\n  } catch (err) {\n    // XXX: This cast is pretty sketchy, as other error types can be thrown\n    // by didResolveOperation!\n    return await sendErrorResponse(err as GraphQLError);\n  }\n\n  // Now that we've gone through the pre-execution phases of the request\n  // pipeline, and given plugins appropriate ability to object (by throwing\n  // an error) and not actually write, we'll write to the cache if it was\n  // determined earlier in the request pipeline that we should do so.\n  if (metrics.persistedQueryRegister && persistedQueryCache) {\n    // While it shouldn't normally be necessary to wrap this `Promise` in a\n    // `Promise.resolve` invocation, it seems that the underlying cache store\n    // is returning a non-native `Promise` (e.g. Bluebird, etc.).\n    Promise.resolve(\n      persistedQueryCache.set(\n        queryHash,\n        query,\n        config.persistedQueries &&\n          typeof config.persistedQueries.ttl !== 'undefined'\n          ? {\n              ttl: config.persistedQueries.ttl,\n            }\n          : Object.create(null),\n      ),\n    ).catch(logger.warn);\n  }\n\n  let response: GraphQLResponse | null =\n    await dispatcher.invokeHooksUntilNonNull(\n      'responseForOperation',\n      requestContext as GraphQLRequestContextResponseForOperation<TContext>,\n    );\n  if (response == null) {\n    // This execution dispatcher code is duplicated in `pluginTestHarness`\n    // right now.\n\n    const executionListeners: GraphQLRequestExecutionListener<TContext>[] = [];\n    (\n      await dispatcher.invokeHook(\n        'executionDidStart',\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      )\n    ).forEach((executionListener) => {\n      if (executionListener) {\n        executionListeners.push(executionListener);\n      }\n    });\n    executionListeners.reverse();\n\n    const executionDispatcher = new Dispatcher(executionListeners);\n\n    if (executionDispatcher.hasHook('willResolveField')) {\n      // Create a callback that will trigger the execution dispatcher's\n      // `willResolveField` hook.  We will attach this to the context on a\n      // symbol so it can be invoked by our `wrapField` method during execution.\n      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =\n        (...args) =>\n          executionDispatcher.invokeSyncDidStartHook(\n            'willResolveField',\n            ...args,\n          );\n\n      Object.defineProperty(\n        requestContext.context,\n        symbolExecutionDispatcherWillResolveField,\n        { value: invokeWillResolveField },\n      );\n\n      // If the user has provided a custom field resolver, we will attach\n      // it to the context so we can still invoke it after we've wrapped the\n      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of\n      // the `schemaInstrumentation` module.\n      if (config.fieldResolver) {\n        Object.defineProperty(requestContext.context, symbolUserFieldResolver, {\n          value: config.fieldResolver,\n        });\n      }\n\n      // If the schema is already enabled, this is a no-op.  Otherwise, the\n      // schema will be augmented so it is able to invoke willResolveField. Note\n      // that if we never see a plugin with willResolveField then we will never\n      // need to instrument the schema, which might be a small performance gain.\n      // (For example, this can happen if you pass `fieldLevelInstrumentation:\n      // () => false` to the usage reporting plugin and disable the cache\n      // control plugin. We can consider changing the cache control plugin to\n      // have a \"static cache control only\" mode that doesn't use\n      // willResolveField too if this proves to be helpful in practice.)\n      enablePluginsForSchemaResolvers(config.schema);\n    }\n\n    try {\n      const result = await execute(\n        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,\n      );\n\n      // The first thing that execution does is coerce the request's variables\n      // to the types declared in the operation, which can lead to errors if\n      // they are of the wrong type. It also makes sure that all non-null\n      // variables are required and get non-null values. If any of these things\n      // lead to errors, we change them into UserInputError so that their code\n      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client\n      // errors.\n      //\n      // This is hacky! Hopefully graphql-js will give us a way to separate\n      // variable resolution from execution later; see\n      // https://github.com/graphql/graphql-js/issues/3169\n      const resultErrors = result.errors?.map((e) => {\n        if (isBadUserInputGraphQLError(e)) {\n          return fromGraphQLError(e, {\n            errorClass: UserInputError,\n          });\n        }\n        return e;\n      });\n\n      if (resultErrors) {\n        await didEncounterErrors(resultErrors);\n      }\n\n      response = {\n        ...result,\n        errors: resultErrors ? formatErrors(resultErrors) : undefined,\n      };\n\n      await executionDispatcher.invokeHook('executionDidEnd');\n    } catch (executionError) {\n      await executionDispatcher.invokeHook(\n        'executionDidEnd',\n        executionError as Error,\n      );\n      // XXX: This cast is pretty sketchy, as other error types can be thrown\n      // in the try block!\n      return await sendErrorResponse(executionError as GraphQLError);\n    }\n  }\n\n  if (config.formatResponse) {\n    const formattedResponse: GraphQLResponse | null = config.formatResponse(\n      response,\n      requestContext,\n    );\n    if (formattedResponse != null) {\n      response = formattedResponse;\n    }\n  }\n\n  return sendResponse(response);\n\n  function parse(query: string, parseOptions?: ParseOptions): DocumentNode {\n    return graphqlParse(query, parseOptions);\n  }\n\n  function validate(document: DocumentNode): ReadonlyArray<GraphQLError> {\n    let rules = specifiedRules;\n    if (config.validationRules) {\n      rules = rules.concat(config.validationRules);\n    }\n\n    return graphqlValidate(config.schema, document, rules);\n  }\n\n  async function execute(\n    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,\n  ): Promise<GraphQLExecutionResult> {\n    const { request, document } = requestContext;\n\n    const executionArgs: ExecutionArgs = {\n      schema: config.schema,\n      document,\n      rootValue:\n        typeof config.rootValue === 'function'\n          ? config.rootValue(document)\n          : config.rootValue,\n      contextValue: requestContext.context,\n      variableValues: request.variables,\n      operationName: request.operationName,\n      fieldResolver: config.fieldResolver,\n    };\n\n    if (config.executor) {\n      // XXX Nothing guarantees that the only errors thrown or returned\n      // in result.errors are GraphQLErrors, even though other code\n      // (eg usage reporting) assumes that.\n      return await config.executor(requestContext);\n    } else {\n      return await graphqlExecute(executionArgs);\n    }\n  }\n\n  async function sendResponse(\n    response: GraphQLResponse,\n  ): Promise<GraphQLResponse> {\n    requestContext.response = {\n      ...requestContext.response,\n      errors: response.errors,\n      data: response.data,\n      extensions: response.extensions,\n    };\n    if (response.http) {\n      if (!requestContext.response.http) {\n        requestContext.response.http = {\n          headers: new Headers(),\n        };\n      }\n      if (response.http.status) {\n        requestContext.response.http.status = response.http.status;\n      }\n      for (const [name, value] of response.http.headers) {\n        requestContext.response.http.headers.set(name, value);\n      }\n    }\n    await dispatcher.invokeHook(\n      'willSendResponse',\n      requestContext as GraphQLRequestContextWillSendResponse<TContext>,\n    );\n    return requestContext.response;\n  }\n\n  // Note that we ensure that all calls to didEncounterErrors are followed by\n  // calls to willSendResponse. (The usage reporting plugin depends on this.)\n  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {\n    requestContext.errors = errors;\n\n    return await dispatcher.invokeHook(\n      'didEncounterErrors',\n      requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,\n    );\n  }\n\n  async function sendErrorResponse(\n    errorOrErrors: ReadonlyArray<GraphQLError> | GraphQLError,\n    errorClass?: typeof ApolloError,\n  ) {\n    // If a single error is passed, it should still be encapsulated in an array.\n    const errors = Array.isArray(errorOrErrors)\n      ? errorOrErrors\n      : [errorOrErrors];\n\n    await didEncounterErrors(errors);\n\n    const response: GraphQLResponse = {\n      errors: formatErrors(\n        errors.map((err) =>\n          err instanceof ApolloError && !errorClass\n            ? err\n            : fromGraphQLError(\n                err,\n                errorClass && {\n                  errorClass,\n                },\n              ),\n        ),\n      ),\n    };\n\n    // Persisted query errors (especially \"not found\") need to be uncached,\n    // because hopefully we're about to fill in the APQ cache and the same\n    // request will succeed next time. We also want a 200 response to avoid any\n    // error handling that may mask the contents of an error response.\n    if (\n      errors.every(\n        (err) =>\n          err instanceof PersistedQueryNotSupportedError ||\n          err instanceof PersistedQueryNotFoundError,\n      )\n    ) {\n      response.http = {\n        status: 200,\n        headers: new Headers({\n          'Cache-Control': 'private, no-cache, must-revalidate',\n        }),\n      };\n    } else if (errors.length === 1 && errors[0] instanceof HttpQueryError) {\n      response.http = {\n        status: errors[0].statusCode,\n        headers: new Headers(errors[0].headers),\n      };\n    }\n\n    return sendResponse(response);\n  }\n\n  function formatErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReadonlyArray<GraphQLFormattedError> {\n    return formatApolloErrors(errors, {\n      formatter: config.formatError,\n      debug: requestContext.debug,\n    });\n  }\n\n  async function initializeRequestListenerDispatcher(): Promise<\n    Dispatcher<GraphQLRequestListener<TContext>>\n  > {\n    const requestListeners: GraphQLRequestListener<TContext>[] = [];\n    if (config.plugins) {\n      for (const plugin of config.plugins) {\n        if (!plugin.requestDidStart) continue;\n        const listener = await plugin.requestDidStart(requestContext);\n        if (listener) {\n          requestListeners.push(listener);\n        }\n      }\n    }\n    return new Dispatcher(requestListeners);\n  }\n\n  async function initializeDataSources() {\n    if (config.dataSources) {\n      const context = requestContext.context;\n\n      const dataSources = config.dataSources();\n\n      const initializers: any[] = [];\n      for (const dataSource of Object.values(dataSources)) {\n        if (dataSource.initialize) {\n          initializers.push(\n            dataSource.initialize({\n              context,\n              cache: requestContext.cache,\n            }),\n          );\n        }\n      }\n\n      await Promise.all(initializers);\n\n      if ('dataSources' in context) {\n        throw new Error(\n          'Please use the dataSources config option instead of putting dataSources on the context yourself.',\n        );\n      }\n\n      (context as any).dataSources = dataSources;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}